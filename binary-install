#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER';
  package Exporter;require 5.006;our$Debug=0;our$ExportLevel=0;our$Verbose ||= 0;our$VERSION='5.74';our (%Cache);sub as_heavy {require Exporter::Heavy;my$c=(caller(1))[3];$c =~ s/.*:://;\&{"Exporter::Heavy::heavy_$c"}}sub export {goto &{as_heavy()}}sub import {my$pkg=shift;my$callpkg=caller($ExportLevel);if ($pkg eq "Exporter" and @_ and $_[0]eq "import"){*{$callpkg."::import"}=\&import;return}my$exports=\@{"$pkg\::EXPORT"};my$fail=${$pkg .'::'}{EXPORT_FAIL}&& \@{"$pkg\::EXPORT_FAIL"};return export$pkg,$callpkg,@_ if$Verbose or $Debug or $fail && @$fail > 1;my$export_cache=($Cache{$pkg}||= {});my$args=@_ or @_=@$exports;if ($args and not %$export_cache){s/^&//,$export_cache->{$_}=1 foreach (@$exports,@{"$pkg\::EXPORT_OK"})}my$heavy;if ($args or $fail){($heavy=(/\W/ or $args and not exists$export_cache->{$_}or $fail and @$fail and $_ eq $fail->[0]))and last foreach (@_)}else {($heavy=/\W/)and last foreach (@_)}return export$pkg,$callpkg,($args ? @_ : ())if$heavy;local$SIG{__WARN__}=sub {require Carp;&Carp::carp}if not $SIG{__WARN__};*{"$callpkg\::$_"}=\&{"$pkg\::$_"}foreach @_}sub export_fail {my$self=shift;@_}sub export_to_level {goto &{as_heavy()}}sub export_tags {goto &{as_heavy()}}sub export_ok_tags {goto &{as_heavy()}}sub require_version {goto &{as_heavy()}}1;
EXPORTER

$fatpacked{"Exporter/Heavy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_HEAVY';
  package Exporter::Heavy;use strict;no strict 'refs';require Exporter;our$VERSION=$Exporter::VERSION;sub _rebuild_cache {my ($pkg,$exports,$cache)=@_;s/^&// foreach @$exports;@{$cache}{@$exports}=(1)x @$exports;my$ok=\@{"${pkg}::EXPORT_OK"};if (@$ok){s/^&// foreach @$ok;@{$cache}{@$ok}=(1)x @$ok}}sub heavy_export {my$oldwarn=$SIG{__WARN__};local$SIG{__WARN__}=sub {local$SIG{__WARN__}=$oldwarn;my$text=shift;if ($text =~ s/ at \S*Exporter\S*.pm line \d+.*\n//){require Carp;local$Carp::CarpLevel=1;Carp::carp($text)}else {warn$text}};local$SIG{__DIE__}=sub {require Carp;local$Carp::CarpLevel=1;Carp::croak("$_[0]Illegal null symbol in \@${1}::EXPORT")if $_[0]=~ /^Unable to create sub named "(.*?)::"/};my($pkg,$callpkg,@imports)=@_;my($type,$sym,$cache_is_current,$oops);my($exports,$export_cache)=(\@{"${pkg}::EXPORT"},$Exporter::Cache{$pkg}||= {});if (@imports){if (!%$export_cache){_rebuild_cache ($pkg,$exports,$export_cache);$cache_is_current=1}if (grep m{^[/!:]},@imports){my$tagsref=\%{"${pkg}::EXPORT_TAGS"};my$tagdata;my%imports;my($remove,$spec,@names,@allexports);unshift@imports,':DEFAULT' if$imports[0]=~ m/^!/;for$spec (@imports){$remove=$spec =~ s/^!//;if ($spec =~ s/^://){if ($spec eq 'DEFAULT'){@names=@$exports}elsif ($tagdata=$tagsref->{$spec}){@names=@$tagdata}else {warn qq["$spec" is not defined in %${pkg}::EXPORT_TAGS];++$oops;next}}elsif ($spec =~ m:^/(.*)/$:){my$patn=$1;@allexports=keys %$export_cache unless@allexports;@names=grep(/$patn/,@allexports)}else {@names=($spec)}warn "Import ".($remove ? "del":"add").": @names " if$Exporter::Verbose;if ($remove){for$sym (@names){delete$imports{$sym}}}else {@imports{@names}=(1)x @names}}@imports=keys%imports}my@carp;for$sym (@imports){if (!$export_cache->{$sym}){if ($sym =~ m/^\d/){$pkg->VERSION($sym);if (@imports==1){@imports=@$exports;last}if (@imports==2 and!$imports[1]){@imports=();last}}elsif ($sym !~ s/^&// ||!$export_cache->{$sym}){unless ($cache_is_current){%$export_cache=();_rebuild_cache ($pkg,$exports,$export_cache);$cache_is_current=1}if (!$export_cache->{$sym}){push@carp,qq["$sym" is not exported by the $pkg module];$oops++}}}}if ($oops){require Carp;Carp::croak(join("\n",@carp,"Can't continue after import errors"))}}else {@imports=@$exports}my($fail,$fail_cache)=(\@{"${pkg}::EXPORT_FAIL"},$Exporter::FailCache{$pkg}||= {});if (@$fail){if (!%$fail_cache){my@expanded=map {/^\w/ ? ($_,'&'.$_): $_}@$fail;warn "${pkg}::EXPORT_FAIL cached: @expanded" if$Exporter::Verbose;@{$fail_cache}{@expanded}=(1)x @expanded}my@failed;for$sym (@imports){push(@failed,$sym)if$fail_cache->{$sym}}if (@failed){@failed=$pkg->export_fail(@failed);for$sym (@failed){require Carp;Carp::carp(qq["$sym" is not implemented by the $pkg module ],"on this architecture")}if (@failed){require Carp;Carp::croak("Can't continue after import errors")}}}warn "Importing into $callpkg from $pkg: ",join(", ",sort@imports)if$Exporter::Verbose;for$sym (@imports){(*{"${callpkg}::$sym"}=\&{"${pkg}::$sym"},next)unless$sym =~ s/^(\W)//;$type=$1;no warnings 'once';*{"${callpkg}::$sym"}=$type eq '&' ? \&{"${pkg}::$sym"}: $type eq '$' ? \${"${pkg}::$sym"}: $type eq '@' ? \@{"${pkg}::$sym"}: $type eq '%' ? \%{"${pkg}::$sym"}: $type eq '*' ? *{"${pkg}::$sym"}: do {require Carp;Carp::croak("Can't export symbol: $type$sym")}}}sub heavy_export_to_level {my$pkg=shift;my$level=shift;(undef)=shift;my$callpkg=caller($level);$pkg->export($callpkg,@_)}sub _push_tags {my($pkg,$var,$syms)=@_;my@nontag=();my$export_tags=\%{"${pkg}::EXPORT_TAGS"};push(@{"${pkg}::$var"},map {$export_tags->{$_}? @{$export_tags->{$_}}: scalar(push(@nontag,$_),$_)}(@$syms)? @$syms : keys %$export_tags);if (@nontag and $^W){require Carp;Carp::carp(join(", ",@nontag)." are not tags of $pkg")}}sub heavy_require_version {my($self,$wanted)=@_;my$pkg=ref$self || $self;return ${pkg}->VERSION($wanted)}sub heavy_export_tags {_push_tags((caller)[0],"EXPORT",\@_)}sub heavy_export_ok_tags {_push_tags((caller)[0],"EXPORT_OK",\@_)}1;
EXPORTER_HEAVY

$fatpacked{"File/Path.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_PATH';
  package File::Path;use 5.005_04;use strict;use Cwd 'getcwd';use File::Basename ();use File::Spec ();BEGIN {if ($] < 5.006){eval 'use Symbol'}}use Exporter ();use vars qw($VERSION @ISA @EXPORT @EXPORT_OK);$VERSION='2.18';$VERSION=eval$VERSION;@ISA=qw(Exporter);@EXPORT=qw(mkpath rmtree);@EXPORT_OK=qw(make_path remove_tree);BEGIN {for (qw(VMS MacOS MSWin32 os2)){no strict 'refs';*{"_IS_\U$_"}=$^O eq $_ ? sub () {1}: sub () {0}}*_FORCE_WRITABLE=(grep {$^O eq $_}qw(amigaos dos epoc MSWin32 MacOS os2))? sub () {1}: sub () {0};*_NEED_STAT_CHECK=!(_IS_MSWIN32())? sub () {1}: sub () {0}}sub _carp {require Carp;goto&Carp::carp}sub _croak {require Carp;goto&Carp::croak}sub _error {my$arg=shift;my$message=shift;my$object=shift;if ($arg->{error}){$object='' unless defined$object;$message .= ": $!" if $!;push @{${$arg->{error}}},{$object=>$message }}else {_carp(defined($object)? "$message for $object: $!" : "$message: $!")}}sub __is_arg {my ($arg)=@_;return (ref$arg eq 'HASH')}sub make_path {push @_,{}unless @_ and __is_arg($_[-1]);goto&mkpath}sub mkpath {my$old_style=!(@_ and __is_arg($_[-1]));my$data;my$paths;if ($old_style){my ($verbose,$mode);($paths,$verbose,$mode)=@_;$paths=[$paths]unless UNIVERSAL::isa($paths,'ARRAY');$data->{verbose}=$verbose;$data->{mode}=defined$mode ? $mode : oct '777'}else {my%args_permitted=map {$_=>1}(qw|chmod error group mask mode owner uid user verbose|);my%not_on_win32_args=map {$_=>1}(qw|group owner uid user|);my@bad_args=();my@win32_implausible_args=();my$arg=pop @_;for my$k (sort keys %{$arg}){if (!$args_permitted{$k}){push@bad_args,$k}elsif ($not_on_win32_args{$k}and _IS_MSWIN32){push@win32_implausible_args,$k}else {$data->{$k}=$arg->{$k}}}_carp("Unrecognized option(s) passed to mkpath() or make_path(): @bad_args")if@bad_args;_carp("Option(s) implausible on Win32 passed to mkpath() or make_path(): @win32_implausible_args")if@win32_implausible_args;$data->{mode}=delete$data->{mask}if exists$data->{mask};$data->{mode}=oct '777' unless exists$data->{mode};${$data->{error}}=[]if exists$data->{error};unless (@win32_implausible_args){$data->{owner}=delete$data->{user}if exists$data->{user};$data->{owner}=delete$data->{uid}if exists$data->{uid};if (exists$data->{owner}and $data->{owner}=~ /\D/){my$uid=(getpwnam$data->{owner})[2];if (defined$uid){$data->{owner}=$uid}else {_error($data,"unable to map $data->{owner} to a uid, ownership not changed");delete$data->{owner}}}if (exists$data->{group}and $data->{group}=~ /\D/){my$gid=(getgrnam$data->{group})[2];if (defined$gid){$data->{group}=$gid}else {_error($data,"unable to map $data->{group} to a gid, group ownership not changed");delete$data->{group}}}if (exists$data->{owner}and not exists$data->{group}){$data->{group}=-1}if (exists$data->{group}and not exists$data->{owner}){$data->{owner}=-1}}$paths=[@_]}return _mkpath($data,$paths)}sub _mkpath {my$data=shift;my$paths=shift;my (@created);for my$path (@{$paths}){next unless defined($path)and length($path);$path .= '/' if _IS_OS2 and $path =~ /^\w:\z/s;if (_IS_VMS){next if$path eq '/';$path=VMS::Filespec::unixify($path)}next if -d $path;my$parent=File::Basename::dirname($path);unless (-d $parent or $path eq $parent){push(@created,_mkpath($data,[$parent]))}print "mkdir $path\n" if$data->{verbose};if (mkdir($path,$data->{mode})){push(@created,$path);if (exists$data->{owner}){if (!chown$data->{owner},$data->{group},$path){_error($data,"Cannot change ownership of $path to $data->{owner}:$data->{group}")}}if (exists$data->{chmod}){if (!chmod$data->{chmod},$path){_error($data,"Cannot change permissions of $path to $data->{chmod}")}}}else {my$save_bang=$!;my ($e,$e1)=($save_bang,$^E);$e .= "; $e1" if$e ne $e1;if (!-d $path){$!=$save_bang;if ($data->{error}){push @{${$data->{error}}},{$path=>$e }}else {_croak("mkdir $path: $e")}}}}return@created}sub remove_tree {push @_,{}unless @_ and __is_arg($_[-1]);goto&rmtree}sub _is_subdir {my ($dir,$test)=@_;my ($dv,$dd)=File::Spec->splitpath($dir,1);my ($tv,$td)=File::Spec->splitpath($test,1);return 0 if$dv ne $tv;my@d=File::Spec->splitdir($dd);my@t=File::Spec->splitdir($td);return 0 if@t < @d;return join('/',@d)eq join('/',splice@t,0,+@d)}sub rmtree {my$old_style=!(@_ and __is_arg($_[-1]));my ($arg,$data,$paths);if ($old_style){my ($verbose,$safe);($paths,$verbose,$safe)=@_;$data->{verbose}=$verbose;$data->{safe}=defined$safe ? $safe : 0;if (defined($paths)and length($paths)){$paths=[$paths]unless UNIVERSAL::isa($paths,'ARRAY')}else {_carp("No root path(s) specified\n");return 0}}else {my%args_permitted=map {$_=>1}(qw|error keep_root result safe verbose|);my@bad_args=();my$arg=pop @_;for my$k (sort keys %{$arg}){if (!$args_permitted{$k}){push@bad_args,$k}else {$data->{$k}=$arg->{$k}}}_carp("Unrecognized option(s) passed to remove_tree(): @bad_args")if@bad_args;${$data->{error}}=[]if exists$data->{error};${$data->{result}}=[]if exists$data->{result};$paths=[@_]}$data->{prefix}='';$data->{depth}=0;my@clean_path;$data->{cwd}=getcwd()or do {_error($data,"cannot fetch initial working directory");return 0};for ($data->{cwd}){/\A(.*)\Z/s;$_=$1}for my$p (@$paths){my$ortho_root=_IS_MSWIN32 ? _slash_lc($p): $p;my$ortho_cwd=_IS_MSWIN32 ? _slash_lc($data->{cwd}): $data->{cwd};my$ortho_root_length=length($ortho_root);$ortho_root_length-- if _IS_VMS;if ($ortho_root_length && _is_subdir($ortho_root,$ortho_cwd)){local $!=0;_error($data,"cannot remove path when cwd is $data->{cwd}",$p);next}if (_IS_MACOS){$p=":$p" unless$p =~ /:/;$p .= ":" unless$p =~ /:\z/}elsif (_IS_MSWIN32){$p =~ s{[/\\]\z}{}}else {$p =~ s{/\z}{}}push@clean_path,$p}@{$data}{qw(device inode)}=(lstat$data->{cwd})[0,1 ]or do {_error($data,"cannot stat initial working directory",$data->{cwd});return 0};return _rmtree($data,\@clean_path)}sub _rmtree {my$data=shift;my$paths=shift;my$count=0;my$curdir=File::Spec->curdir();my$updir=File::Spec->updir();my (@files,$root);ROOT_DIR: foreach my$root (@$paths){my$canon=$data->{prefix}? File::Spec->catfile($data->{prefix},$root): $root;my ($ldev,$lino,$perm)=(lstat$root)[0,1,2 ]or next ROOT_DIR;if (-d _){$root=VMS::Filespec::vmspath(VMS::Filespec::pathify($root))if _IS_VMS;if (!chdir($root)){my$root_fh;if (open($root_fh,'<',$root)){my ($fh_dev,$fh_inode)=(stat$root_fh)[0,1];$perm &= oct '7777';my$nperm=$perm | oct '700';local $@;if (!($data->{safe}or $nperm==$perm or!-d _ or $fh_dev ne $ldev or $fh_inode ne $lino or eval {chmod($nperm,$root_fh)})){_error($data,"cannot make child directory read-write-exec",$canon);next ROOT_DIR}close$root_fh}if (!chdir($root)){_error($data,"cannot chdir to child",$canon);next ROOT_DIR}}my ($cur_dev,$cur_inode,$perm)=(stat$curdir)[0,1,2 ]or do {_error($data,"cannot stat current working directory",$canon);next ROOT_DIR};if (_NEED_STAT_CHECK){($ldev eq $cur_dev and $lino eq $cur_inode)or _croak("directory $canon changed before chdir, expected dev=$ldev ino=$lino, actual dev=$cur_dev ino=$cur_inode, aborting.")}$perm &= oct '7777';my$nperm=$perm | oct '700';if (!($data->{safe}or $nperm==$perm or chmod($nperm,$curdir))){_error($data,"cannot make directory read+writeable",$canon);$nperm=$perm}my$d;$d=gensym()if $] < 5.006;if (!opendir$d,$curdir){_error($data,"cannot opendir",$canon);@files=()}else {if (!defined ${^TAINT} or ${^TAINT}){@files=map {/\A(.*)\z/s;$1}readdir$d}else {@files=readdir$d}closedir$d}if (_IS_VMS){@files=map {$_ eq '.' ? '.;' : $_}reverse@files}@files=grep {$_ ne $updir and $_ ne $curdir}@files;if (@files){my$narg={%$data};@{$narg}{qw(device inode cwd prefix depth)}=($cur_dev,$cur_inode,$updir,$canon,$data->{depth}+ 1);$count += _rmtree($narg,\@files)}if ($nperm!=$perm and not chmod($perm,$curdir)){_error($data,"cannot reset chmod",$canon)}chdir($data->{cwd})or _croak("cannot chdir to $data->{cwd} from $canon: $!, aborting.");($cur_dev,$cur_inode)=(stat$curdir)[0,1 ]or _croak("cannot stat prior working directory $data->{cwd}: $!, aborting.");if (_NEED_STAT_CHECK){($data->{device}eq $cur_dev and $data->{inode}eq $cur_inode)or _croak("previous directory $data->{cwd} " ."changed before entering $canon, " ."expected dev=$ldev ino=$lino, " ."actual dev=$cur_dev ino=$cur_inode, aborting.")}if ($data->{depth}or!$data->{keep_root}){if ($data->{safe}&& (_IS_VMS ?!&VMS::Filespec::candelete($root):!-w $root)){print "skipped $root\n" if$data->{verbose};next ROOT_DIR}if (_FORCE_WRITABLE and!chmod$perm | oct '700',$root){_error($data,"cannot make directory writeable",$canon)}print "rmdir $root\n" if$data->{verbose};if (rmdir$root){push @{${$data->{result}}},$root if$data->{result};++$count}else {_error($data,"cannot remove directory",$canon);if (_FORCE_WRITABLE &&!chmod($perm,(_IS_VMS ? VMS::Filespec::fileify($root): $root))){_error($data,sprintf("cannot restore permissions to 0%o",$perm),$canon)}}}}else {$root=VMS::Filespec::vmsify("./$root")if _IS_VMS &&!File::Spec->file_name_is_absolute($root)&& ($root !~ m/(?<!\^)[\]>]+/);if ($data->{safe}&& (_IS_VMS ?!&VMS::Filespec::candelete($root):!(-l $root || -w $root))){print "skipped $root\n" if$data->{verbose};next ROOT_DIR}my$nperm=$perm & oct '7777' | oct '600';if (_FORCE_WRITABLE and $nperm!=$perm and not chmod$nperm,$root){_error($data,"cannot make file writeable",$canon)}print "unlink $canon\n" if$data->{verbose};for (;;){if (unlink$root){push @{${$data->{result}}},$root if$data->{result}}else {_error($data,"cannot unlink file",$canon);_FORCE_WRITABLE and chmod($perm,$root)or _error($data,sprintf("cannot restore permissions to 0%o",$perm),$canon);last}++$count;last unless _IS_VMS && lstat$root}}}return$count}sub _slash_lc {my$path=shift;$path =~ tr{\\}{/};return lc($path)}1;
FILE_PATH

$fatpacked{"File/Temp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_TEMP';
  package File::Temp;our$VERSION='0.2311';use 5.006;use strict;use Carp;use File::Spec 0.8;use Cwd ();use File::Path 2.06 qw/rmtree/;use Fcntl 1.03;use IO::Seekable;use Errno;use Scalar::Util 'refaddr';require VMS::Stdio if $^O eq 'VMS';eval {require Carp::Heavy};require Symbol if $] < 5.006;use parent 0.221 qw/IO::Handle IO::Seekable/;use overload '""'=>"STRINGIFY",'0+'=>"NUMIFY",fallback=>1;our$DEBUG=0;our$KEEP_ALL=0;use Exporter 5.57 'import';our@EXPORT_OK=qw{tempfile tempdir tmpnam tmpfile mktemp mkstemp mkstemps mkdtemp unlink0 cleanup SEEK_SET SEEK_CUR SEEK_END};our%EXPORT_TAGS=('POSIX'=>[qw/tmpnam tmpfile/],'mktemp'=>[qw/mktemp mkstemp mkstemps mkdtemp/],'seekable'=>[qw/SEEK_SET SEEK_CUR SEEK_END/],);Exporter::export_tags('POSIX','mktemp','seekable');my@CHARS=(qw/A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9 _/);use constant MAX_TRIES=>1000;use constant MINX=>4;use constant TEMPXXX=>'X' x 10;use constant STANDARD=>0;use constant MEDIUM=>1;use constant HIGH=>2;my$OPENFLAGS=O_CREAT | O_EXCL | O_RDWR;my$LOCKFLAG;unless ($^O eq 'MacOS'){for my$oflag (qw/NOFOLLOW BINARY LARGEFILE NOINHERIT/){my ($bit,$func)=(0,"Fcntl::O_" .$oflag);no strict 'refs';$OPENFLAGS |= $bit if eval {local$SIG{__DIE__}=sub {};local$SIG{__WARN__}=sub {};$bit=&$func();1}}$LOCKFLAG=eval {local$SIG{__DIE__}=sub {};local$SIG{__WARN__}=sub {};&Fcntl::O_EXLOCK()}}my$OPENTEMPFLAGS=$OPENFLAGS;unless ($^O eq 'MacOS'){for my$oflag (qw/TEMPORARY/){my ($bit,$func)=(0,"Fcntl::O_" .$oflag);local($@);no strict 'refs';$OPENTEMPFLAGS |= $bit if eval {local$SIG{__DIE__}=sub {};local$SIG{__WARN__}=sub {};$bit=&$func();1}}}my%FILES_CREATED_BY_OBJECT;sub _gettemp {croak 'Usage: ($fh, $name) = _gettemp($template, OPTIONS);' unless scalar(@_)>= 1;my$tempErrStr;my%options=("open"=>0,"mkdir"=>0,"suffixlen"=>0,"unlink_on_close"=>0,"use_exlock"=>0,"ErrStr"=>\$tempErrStr,"file_permissions"=>undef,);my$template=shift;if (ref($template)){carp "File::Temp::_gettemp: template must not be a reference";return ()}if (scalar(@_)% 2!=0){carp "File::Temp::_gettemp: Must have even number of options";return ()}%options=(%options,@_)if @_;${$options{ErrStr}}=undef;if ($options{"open"}&& $options{"mkdir"}){${$options{ErrStr}}="doopen and domkdir can not both be true\n";return ()}my$start=length($template)- 1 - $options{"suffixlen"};if (substr($template,$start - MINX + 1,MINX)ne 'X' x MINX){${$options{ErrStr}}="The template must end with at least ".MINX ." 'X' characters\n";return ()}my$path=_replace_XX($template,$options{"suffixlen"});my ($volume,$directories,$file);my$parent;if ($options{"mkdir"}){($volume,$directories,$file)=File::Spec->splitpath($path,1);my@dirs=File::Spec->splitdir($directories);if ($#dirs==0){$parent=File::Spec->curdir}else {if ($^O eq 'VMS'){$parent=File::Spec->catdir($volume,@dirs[0..$#dirs-1]);$parent='sys$disk:[]' if$parent eq ''}else {$parent=File::Spec->catdir(@dirs[0..$#dirs-1]);$parent=File::Spec->catpath($volume,$parent,'')}}}else {($volume,$directories,$file)=File::Spec->splitpath($path);$parent=File::Spec->catpath($volume,$directories,'');$parent=File::Spec->curdir unless$directories ne ''}unless (-e $parent){${$options{ErrStr}}="Parent directory ($parent) does not exist";return ()}unless (-d $parent){${$options{ErrStr}}="Parent directory ($parent) is not a directory";return ()}if (File::Temp->safe_level==MEDIUM){my$safeerr;unless (_is_safe($parent,\$safeerr)){${$options{ErrStr}}="Parent directory ($parent) is not safe ($safeerr)";return ()}}elsif (File::Temp->safe_level==HIGH){my$safeerr;unless (_is_verysafe($parent,\$safeerr)){${$options{ErrStr}}="Parent directory ($parent) is not safe ($safeerr)";return ()}}my$perms=$options{file_permissions};my$has_perms=defined$perms;$perms=0600 unless$has_perms;for (my$i=0;$i < MAX_TRIES;$i++){if ($options{"open"}){my$fh;if ($] < 5.006){$fh=&Symbol::gensym}local $^F=2;my$open_success=undef;if ($^O eq 'VMS' and $options{"unlink_on_close"}&&!$KEEP_ALL){$fh=VMS::Stdio::vmssysopen($path,$OPENFLAGS,$perms,'fop=dlt');$open_success=$fh}else {my$flags=(($options{"unlink_on_close"}&&!$KEEP_ALL)? $OPENTEMPFLAGS : $OPENFLAGS);$flags |= $LOCKFLAG if (defined$LOCKFLAG && $options{use_exlock});$open_success=sysopen($fh,$path,$flags,$perms)}if ($open_success){chmod($perms,$path)unless$has_perms;return ($fh,$path)}else {unless ($!{EEXIST}){${$options{ErrStr}}="Could not create temp file $path: $!";return ()}}}elsif ($options{"mkdir"}){if (mkdir($path,0700)){chmod(0700,$path);return undef,$path}else {unless ($!{EEXIST}){${$options{ErrStr}}="Could not create directory $path: $!";return ()}}}else {return (undef,$path)unless -e $path}my$original=$path;my$counter=0;my$MAX_GUESS=50;do {$path=_replace_XX($template,$options{"suffixlen"});$counter++}until ($path ne $original || $counter > $MAX_GUESS);if ($counter > $MAX_GUESS){${$options{ErrStr}}="Tried to get a new temp name different to the previous value $MAX_GUESS times.\nSomething wrong with template?? ($template)";return ()}}${$options{ErrStr}}="Have exceeded the maximum number of attempts (" .MAX_TRIES .") to open temp file/dir";return ()}sub _replace_XX {croak 'Usage: _replace_XX($template, $ignore)' unless scalar(@_)==2;my ($path,$ignore)=@_;my$end=($] >= 5.006 ? "\\z" : "\\Z");if ($ignore){substr($path,0,- $ignore)=~ s/X(?=X*$end)/$CHARS[ int( rand( @CHARS ) ) ]/ge}else {$path =~ s/X(?=X*$end)/$CHARS[ int( rand( @CHARS ) ) ]/ge}return$path}sub _force_writable {my$file=shift;chmod 0600,$file}sub _is_safe {my$path=shift;my$err_ref=shift;my@info=stat($path);unless (scalar(@info)){$$err_ref="stat(path) returned no values";return 0};return 1 if $^O eq 'VMS';if ($info[4]> File::Temp->top_system_uid()&& $info[4]!=$>){Carp::cluck(sprintf "uid=$info[4] topuid=%s euid=$> path='$path'",File::Temp->top_system_uid());$$err_ref="Directory owned neither by root nor the current user" if ref($err_ref);return 0}if (($info[2]& &Fcntl::S_IWGRP)|| ($info[2]& &Fcntl::S_IWOTH)){unless (-d $path){$$err_ref="Path ($path) is not a directory" if ref($err_ref);return 0}unless (-k $path){$$err_ref="Sticky bit not set on $path when dir is group|world writable" if ref($err_ref);return 0}}return 1}sub _is_verysafe {require POSIX;my$path=shift;print "_is_verysafe testing $path\n" if$DEBUG;return 1 if $^O eq 'VMS';my$err_ref=shift;local($@);my$chown_restricted;$chown_restricted=&POSIX::_PC_CHOWN_RESTRICTED()if eval {&POSIX::_PC_CHOWN_RESTRICTED();1};if (defined$chown_restricted){return _is_safe($path,$err_ref)if POSIX::sysconf($chown_restricted)}unless (File::Spec->file_name_is_absolute($path)){$path=File::Spec->rel2abs($path)}my ($volume,$directories,undef)=File::Spec->splitpath($path,1);my@dirs=File::Spec->splitdir($directories);for my$pos (0.. $#dirs){my$dir=File::Spec->catpath($volume,File::Spec->catdir(@dirs[0.. $#dirs - $pos]),'');print "TESTING DIR $dir\n" if$DEBUG;return 0 unless _is_safe($dir,$err_ref)}return 1}sub _can_unlink_opened_file {if (grep $^O eq $_,qw/MSWin32 os2 VMS dos MacOS haiku/){return 0}else {return 1}}sub _can_do_level {my$level=shift;return 1 if$level==STANDARD;if ($^O eq 'MSWin32' || $^O eq 'os2' || $^O eq 'cygwin' || $^O eq 'dos' || $^O eq 'MacOS' || $^O eq 'mpeix'){return 0}else {return 1}}{my (%files_to_unlink,%dirs_to_unlink);END {local($.,$@,$!,$^E,$?);cleanup(at_exit=>1)}sub cleanup {my%h=@_;my$at_exit=delete$h{at_exit};$at_exit=0 if not defined$at_exit;{my@k=sort keys%h;die "unrecognized parameters: @k" if@k}if (!$KEEP_ALL){my@files=(exists$files_to_unlink{$$}? @{$files_to_unlink{$$}}: ());for my$file (@files){close($file->[0]);if (-f $file->[1]){_force_writable($file->[1]);unlink$file->[1]or warn "Error removing ".$file->[1]}}my@dirs=(exists$dirs_to_unlink{$$}? @{$dirs_to_unlink{$$}}: ());my ($cwd,$cwd_to_remove);for my$dir (@dirs){if (-d $dir){if ($at_exit){$cwd=Cwd::abs_path(File::Spec->curdir)if not defined$cwd;my$abs=Cwd::abs_path($dir);if ($abs eq $cwd){$cwd_to_remove=$dir;next}}eval {rmtree($dir,$DEBUG,0)};warn $@ if ($@ && $^W)}}if (defined$cwd_to_remove){chdir$cwd_to_remove or die "cannot chdir to $cwd_to_remove: $!";my$updir=File::Spec->updir;chdir$updir or die "cannot chdir to $updir: $!";eval {rmtree($cwd_to_remove,$DEBUG,0)};warn $@ if ($@ && $^W)}@{$files_to_unlink{$$}}=()if exists$files_to_unlink{$$};@{$dirs_to_unlink{$$}}=()if exists$dirs_to_unlink{$$}}}sub _deferred_unlink {croak 'Usage:  _deferred_unlink($fh, $fname, $isdir)' unless scalar(@_)==3;my ($fh,$fname,$isdir)=@_;warn "Setting up deferred removal of $fname\n" if$DEBUG;$fname=Cwd::abs_path($fname);($fname)=$fname =~ /^(.*)$/;if ($isdir){if (-d $fname){$fname=VMS::Filespec::vmspath($fname)if $^O eq 'VMS';$dirs_to_unlink{$$}=[]unless exists$dirs_to_unlink{$$};push (@{$dirs_to_unlink{$$}},$fname)}else {carp "Request to remove directory $fname could not be completed since it does not exist!\n" if $^W}}else {if (-f $fname){$files_to_unlink{$$}=[]unless exists$files_to_unlink{$$};push(@{$files_to_unlink{$$}},[$fh,$fname])}else {carp "Request to remove file $fname could not be completed since it is not there!\n" if $^W}}}}sub _parse_args {my$leading_template=(scalar(@_)% 2==1 ? shift(@_): '');my%args=@_;%args=map +(uc($_)=>$args{$_}),keys%args;my@template=(exists$args{TEMPLATE}? $args{TEMPLATE}: $leading_template ? $leading_template : ());delete$args{TEMPLATE};return(\@template,\%args)}sub new {my$proto=shift;my$class=ref($proto)|| $proto;my ($maybe_template,$args)=_parse_args(@_);my$unlink=(exists$args->{UNLINK}? $args->{UNLINK}: 1);delete$args->{UNLINK};delete$args->{OPEN};my ($fh,$path)=tempfile(@$maybe_template,%$args);print "Tmp: $fh - $path\n" if$DEBUG;${*$fh}=$path;$FILES_CREATED_BY_OBJECT{$$}{$path}=1;%{*$fh}=%$args;bless$fh,$class;$fh->unlink_on_destroy($unlink);return$fh}sub newdir {my$self=shift;my ($maybe_template,$args)=_parse_args(@_);my$cleanup=(exists$args->{CLEANUP}? $args->{CLEANUP}: 1);delete$args->{CLEANUP};my$tempdir=tempdir(@$maybe_template,%$args);my$real_dir=Cwd::abs_path($tempdir);($real_dir)=$real_dir =~ /^(.*)$/;return bless {DIRNAME=>$tempdir,REALNAME=>$real_dir,CLEANUP=>$cleanup,LAUNCHPID=>$$,},"File::Temp::Dir"}sub filename {my$self=shift;return ${*$self}}sub STRINGIFY {my$self=shift;return$self->filename}sub NUMIFY {return refaddr($_[0])}sub unlink_on_destroy {my$self=shift;if (@_){${*$self}{UNLINK}=shift}return ${*$self}{UNLINK}}sub DESTROY {local($.,$@,$!,$^E,$?);my$self=shift;my$file=$self->filename;my$was_created_by_proc;if (exists$FILES_CREATED_BY_OBJECT{$$}{$file}){$was_created_by_proc=1;delete$FILES_CREATED_BY_OBJECT{$$}{$file}}if (${*$self}{UNLINK}&&!$KEEP_ALL){print "# --------->   Unlinking $self\n" if$DEBUG;return unless$was_created_by_proc;_force_writable($file);unlink1($self,$file)or unlink($file)}}sub tempfile {if (@_ && $_[0]eq 'File::Temp'){croak "'tempfile' can't be called as a method"}my%options=("DIR"=>undef,"SUFFIX"=>'',"UNLINK"=>0,"OPEN"=>1,"TMPDIR"=>0,"EXLOCK"=>0,"PERMS"=>undef,);my ($maybe_template,$args)=_parse_args(@_);my$template=@$maybe_template ? $maybe_template->[0]: undef;%options=(%options,%$args);if (!$options{"OPEN"}){warn "tempfile(): temporary filename requested but not opened.\nPossibly unsafe, consider using tempfile() with OPEN set to true\n" if $^W}if ($options{"DIR"}and $^O eq 'VMS'){$options{"DIR"}=VMS::Filespec::vmspath($options{"DIR"})}if (defined$template){if ($options{"DIR"}){$template=File::Spec->catfile($options{"DIR"},$template)}elsif ($options{TMPDIR}){$template=File::Spec->catfile(_wrap_file_spec_tmpdir(),$template)}}else {if ($options{"DIR"}){$template=File::Spec->catfile($options{"DIR"},TEMPXXX)}else {$template=File::Spec->catfile(_wrap_file_spec_tmpdir(),TEMPXXX)}}$template .= $options{"SUFFIX"};my$unlink_on_close=(wantarray ? 0 : 1);my ($fh,$path,$errstr);croak "Error in tempfile() using template $template: $errstr" unless (($fh,$path)=_gettemp($template,"open"=>$options{OPEN},"mkdir"=>0,"unlink_on_close"=>$unlink_on_close,"suffixlen"=>length($options{SUFFIX}),"ErrStr"=>\$errstr,"use_exlock"=>$options{EXLOCK},"file_permissions"=>$options{PERMS},));_deferred_unlink($fh,$path,0)if$options{"UNLINK"};if (wantarray()){if ($options{'OPEN'}){return ($fh,$path)}else {return (undef,$path)}}else {unlink0($fh,$path)or croak "Error unlinking file $path using unlink0";return$fh}}{my ($alt_tmpdir,$checked);sub _wrap_file_spec_tmpdir {return File::Spec->tmpdir unless $^O eq "MSWin32" && ${^TAINT};if ($checked){return$alt_tmpdir ? $alt_tmpdir : File::Spec->tmpdir}my$xxpath=_replace_XX("X" x 10,0);my$tmpdir=File::Spec->tmpdir;my$testpath=File::Spec->catdir($tmpdir,$xxpath);if (mkdir($testpath,0700)){$checked=1;rmdir$testpath;return$tmpdir}require Win32;my$local_app=File::Spec->catdir(Win32::GetFolderPath(Win32::CSIDL_LOCAL_APPDATA()),'Temp');$testpath=File::Spec->catdir($local_app,$xxpath);if (-e $local_app or mkdir($local_app,0700)){if (mkdir($testpath,0700)){$checked=1;rmdir$testpath;return$alt_tmpdir=$local_app}}croak << "HERE"}}sub tempdir {if (@_ && $_[0]eq 'File::Temp'){croak "'tempdir' can't be called as a method"}my%options=("CLEANUP"=>0,"DIR"=>'',"TMPDIR"=>0,);my ($maybe_template,$args)=_parse_args(@_);my$template=@$maybe_template ? $maybe_template->[0]: undef;%options=(%options,%$args);if (defined$template){if ($options{'TMPDIR'}|| $options{'DIR'}){$template=VMS::Filespec::vmspath($template)if $^O eq 'VMS';my ($volume,$directories,undef)=File::Spec->splitpath($template,1);$template=(File::Spec->splitdir($directories))[-1];if ($options{"DIR"}){$template=File::Spec->catdir($options{"DIR"},$template)}elsif ($options{TMPDIR}){$template=File::Spec->catdir(_wrap_file_spec_tmpdir(),$template)}}}else {if ($options{"DIR"}){$template=File::Spec->catdir($options{"DIR"},TEMPXXX)}else {$template=File::Spec->catdir(_wrap_file_spec_tmpdir(),TEMPXXX)}}my$tempdir;my$suffixlen=0;if ($^O eq 'VMS'){$template =~ m/([\.\]:>]+)$/;$suffixlen=length($1)}if (($^O eq 'MacOS')&& (substr($template,-1)eq ':')){++$suffixlen}my$errstr;croak "Error in tempdir() using $template: $errstr" unless ((undef,$tempdir)=_gettemp($template,"open"=>0,"mkdir"=>1,"suffixlen"=>$suffixlen,"ErrStr"=>\$errstr,));if ($options{'CLEANUP'}&& -d $tempdir){_deferred_unlink(undef,$tempdir,1)}return$tempdir}sub mkstemp {croak "Usage: mkstemp(template)" if scalar(@_)!=1;my$template=shift;my ($fh,$path,$errstr);croak "Error in mkstemp using $template: $errstr" unless (($fh,$path)=_gettemp($template,"open"=>1,"mkdir"=>0,"suffixlen"=>0,"ErrStr"=>\$errstr,));if (wantarray()){return ($fh,$path)}else {return$fh}}sub mkstemps {croak "Usage: mkstemps(template, suffix)" if scalar(@_)!=2;my$template=shift;my$suffix=shift;$template .= $suffix;my ($fh,$path,$errstr);croak "Error in mkstemps using $template: $errstr" unless (($fh,$path)=_gettemp($template,"open"=>1,"mkdir"=>0,"suffixlen"=>length($suffix),"ErrStr"=>\$errstr,));if (wantarray()){return ($fh,$path)}else {return$fh}}sub mkdtemp {croak "Usage: mkdtemp(template)" if scalar(@_)!=1;my$template=shift;my$suffixlen=0;if ($^O eq 'VMS'){$template =~ m/([\.\]:>]+)$/;$suffixlen=length($1)}if (($^O eq 'MacOS')&& (substr($template,-1)eq ':')){++$suffixlen}my ($junk,$tmpdir,$errstr);croak "Error creating temp directory from template $template\: $errstr" unless (($junk,$tmpdir)=_gettemp($template,"open"=>0,"mkdir"=>1,"suffixlen"=>$suffixlen,"ErrStr"=>\$errstr,));return$tmpdir}sub mktemp {croak "Usage: mktemp(template)" if scalar(@_)!=1;my$template=shift;my ($tmpname,$junk,$errstr);croak "Error getting name to temp file from template $template: $errstr" unless (($junk,$tmpname)=_gettemp($template,"open"=>0,"mkdir"=>0,"suffixlen"=>0,"ErrStr"=>\$errstr,));return$tmpname}sub tmpnam {my$tmpdir=_wrap_file_spec_tmpdir();croak "Error temporary directory is not writable" if$tmpdir eq '';my$template=File::Spec->catfile($tmpdir,TEMPXXX);if (wantarray()){return mkstemp($template)}else {return mktemp($template)}}sub tmpfile {my ($fh,$file)=tmpnam();unlink0($fh,$file)or return undef;return$fh}sub tempnam {croak 'Usage tempnam($dir, $prefix)' unless scalar(@_)==2;my ($dir,$prefix)=@_;$prefix .= 'XXXXXXXX';my$template=File::Spec->catfile($dir,$prefix);return mktemp($template)}sub unlink0 {croak 'Usage: unlink0(filehandle, filename)' unless scalar(@_)==2;my ($fh,$path)=@_;cmpstat($fh,$path)or return 0;if (_can_unlink_opened_file()){return 1 if$KEEP_ALL;croak "unlink0: $path has become a directory!" if -d $path;unlink($path)or return 0;my@fh=stat$fh;print "Link count = $fh[3] \n" if$DEBUG;return 1 if$fh[3]==0 || $^O eq 'cygwin'}_deferred_unlink($fh,$path,0);return 1}sub cmpstat {croak 'Usage: cmpstat(filehandle, filename)' unless scalar(@_)==2;my ($fh,$path)=@_;warn "Comparing stat\n" if$DEBUG;my@fh;{local ($^W)=0;@fh=stat$fh}return unless@fh;if ($fh[3]> 1 && $^W){carp "unlink0: fstat found too many links; SB=@fh" if $^W}my@path=stat$path;unless (@path){carp "unlink0: $path is gone already" if $^W;return}unless (-f $path){confess "panic: $path is no longer a file: SB=@fh"}my@okstat=(0..$#fh);if ($^O eq 'MSWin32'){@okstat=(1,2,3,4,5,7,8,9,10)}elsif ($^O eq 'os2'){@okstat=(0,2..$#fh)}elsif ($^O eq 'VMS'){@okstat=(0,1)}elsif ($^O eq 'dos'){@okstat=(0,2..7,11..$#fh)}elsif ($^O eq 'mpeix'){@okstat=(0..4,8..10)}for (@okstat){print "Comparing: $_ : $fh[$_] and $path[$_]\n" if$DEBUG;unless ($fh[$_]eq $path[$_]){warn "Did not match $_ element of stat\n" if$DEBUG;return 0}}return 1}sub unlink1 {croak 'Usage: unlink1(filehandle, filename)' unless scalar(@_)==2;my ($fh,$path)=@_;cmpstat($fh,$path)or return 0;close($fh)or return 0;_force_writable($path);return 1 if$KEEP_ALL;return unlink($path)}{my$LEVEL=STANDARD;sub safe_level {my$self=shift;if (@_){my$level=shift;if (($level!=STANDARD)&& ($level!=MEDIUM)&& ($level!=HIGH)){carp "safe_level: Specified level ($level) not STANDARD, MEDIUM or HIGH - ignoring\n" if $^W}else {if ($] < 5.006 && $level!=STANDARD){croak "Currently requires perl 5.006 or newer to do the safe checks"}$LEVEL=$level if _can_do_level($level)}}return$LEVEL}}{my$TopSystemUID=10;$TopSystemUID=197108 if $^O eq 'interix';sub top_system_uid {my$self=shift;if (@_){my$newuid=shift;croak "top_system_uid: UIDs should be numeric" unless$newuid =~ /^\d+$/s;$TopSystemUID=$newuid}return$TopSystemUID}}package File::Temp::Dir;our$VERSION='0.2311';use File::Path qw/rmtree/;use strict;use overload '""'=>"STRINGIFY",'0+'=>\&File::Temp::NUMIFY,fallback=>1;sub dirname {my$self=shift;return$self->{DIRNAME}}sub STRINGIFY {my$self=shift;return$self->dirname}sub unlink_on_destroy {my$self=shift;if (@_){$self->{CLEANUP}=shift}return$self->{CLEANUP}}sub DESTROY {my$self=shift;local($.,$@,$!,$^E,$?);if ($self->unlink_on_destroy && $$==$self->{LAUNCHPID}&&!$File::Temp::KEEP_ALL){if (-d $self->{REALNAME}){eval {rmtree($self->{REALNAME},$File::Temp::DEBUG,0)};warn $@ if ($@ && $^W)}}}1;
  Couldn't find a writable temp directory in taint mode. Tried:
    $tmpdir
    $local_app
  
  Try setting and untainting the TMPDIR environment variable.
  HERE
FILE_TEMP

$fatpacked{"File/Which.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_WHICH';
  package File::Which;use strict;use warnings;use base qw(Exporter);use File::Spec ();our$VERSION='1.27';our@EXPORT='which';our@EXPORT_OK='where';use constant IS_VMS=>($^O eq 'VMS');use constant IS_MAC=>($^O eq 'MacOS');use constant IS_WIN=>($^O eq 'MSWin32' or $^O eq 'dos' or $^O eq 'os2');use constant IS_DOS=>IS_WIN();use constant IS_CYG=>($^O eq 'cygwin' || $^O eq 'msys');our$IMPLICIT_CURRENT_DIR=IS_WIN || IS_VMS || IS_MAC;my@PATHEXT=('');if (IS_WIN){if ($ENV{PATHEXT}){push@PATHEXT,split /;/,$ENV{PATHEXT}}else {push@PATHEXT,qw{.com .exe .bat}}}elsif (IS_VMS){push@PATHEXT,qw{.exe .com}}elsif (IS_CYG){push@PATHEXT,qw{.exe .com}}sub which {my ($exec)=@_;return undef unless defined$exec;return undef if$exec eq '';my$all=wantarray;my@results=();if (IS_VMS){my$symbol=`SHOW SYMBOL $exec`;chomp($symbol);unless ($?){return$symbol unless$all;push@results,$symbol}}if (IS_MAC){my@aliases=split /\,/,$ENV{Aliases};for my$alias (@aliases){if (lc($alias)eq lc($exec)){chomp(my$file=`Alias $alias`);last unless$file;return$file unless$all;push@results,$file;last}}}return$exec if!IS_VMS and!IS_MAC and!IS_WIN and $exec =~ /\// and -f $exec and -x $exec;my@path;if($^O eq 'MSWin32'){@path=split /;/,$ENV{PATH};s/"//g for@path;@path=grep length,@path}else {@path=File::Spec->path}if ($IMPLICIT_CURRENT_DIR){unshift@path,File::Spec->curdir}for my$base (map {File::Spec->catfile($_,$exec)}@path){for my$ext (@PATHEXT){my$file=$base.$ext;next if -d $file;if (-x _ or (IS_MAC || ((IS_WIN or IS_CYG)and grep {$file =~ /$_\z/i}@PATHEXT[1..$#PATHEXT])and -e _)){return$file unless$all;push@results,$file}}}if ($all){return@results}else {return undef}}sub where {my@res=which($_[0]);return@res}1;
FILE_WHICH

$fatpacked{"File/pushd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_PUSHD';
  use strict;use warnings;package File::pushd;our$VERSION='1.016';our@EXPORT=qw(pushd tempd);our@ISA=qw(Exporter);use Exporter;use Carp;use Cwd qw(getcwd abs_path);use File::Path qw(rmtree);use File::Temp qw();use File::Spec;use overload q{""}=>sub {File::Spec->canonpath($_[0]->{_pushd})},fallback=>1;sub pushd {unless (defined wantarray){warnings::warnif(void=>'Useless use of File::pushd::pushd in void context');return}my ($target_dir,$options)=@_;$options->{untaint_pattern}||= qr{^([-+@\w./]+)$};$target_dir="." unless defined$target_dir;croak "Can't locate directory $target_dir" unless -d $target_dir;my$tainted_orig=getcwd;my$orig;if ($tainted_orig =~ $options->{untaint_pattern}){$orig=$1}else {$orig=$tainted_orig}my$tainted_dest;eval {$tainted_dest=$target_dir ? abs_path($target_dir): $orig};croak "Can't locate absolute path for $target_dir: $@" if $@;my$dest;if ($tainted_dest =~ $options->{untaint_pattern}){$dest=$1}else {$dest=$tainted_dest}if ($dest ne $orig){chdir$dest or croak "Can't chdir to $dest\: $!"}my$self=bless {_pushd=>$dest,_original=>$orig },__PACKAGE__;return$self}sub tempd {unless (defined wantarray){warnings::warnif(void=>'Useless use of File::pushd::tempd in void context');return}my ($options)=@_;my$dir;eval {$dir=pushd(File::Temp::tempdir(CLEANUP=>0),$options)};croak $@ if $@;$dir->{_tempd}=1;$dir->{_owner}=$$;return$dir}sub preserve {my$self=shift;return 1 if!$self->{"_tempd"};if (@_==0){return$self->{_preserve}=1}else {return$self->{_preserve}=$_[0]? 1 : 0}}sub DESTROY {my ($self)=@_;my$orig=$self->{_original};chdir$orig if$orig;if ($self->{_tempd}&& $self->{_owner}==$$ &&!$self->{_preserve}){my$err=do {local $@;eval {rmtree($self->{_pushd})};$@};carp$err if$err}}1;
FILE_PUSHD

$fatpacked{"Getopt/Long.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG';
  use 5.004;use strict;use warnings;package Getopt::Long;use vars qw($VERSION);$VERSION=2.52;use vars qw($VERSION_STRING);$VERSION_STRING="2.52";use Exporter;use vars qw(@ISA @EXPORT @EXPORT_OK);@ISA=qw(Exporter);sub GetOptions(@);sub GetOptionsFromArray(@);sub GetOptionsFromString(@);sub Configure(@);sub HelpMessage(@);sub VersionMessage(@);BEGIN {@EXPORT=qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);@EXPORT_OK=qw(&HelpMessage &VersionMessage &Configure &GetOptionsFromArray &GetOptionsFromString)}use vars@EXPORT,@EXPORT_OK;use vars qw($error $debug $major_version $minor_version);use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order $passthrough);use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);my$bundling_values;sub config(@);sub ConfigDefaults();sub ParseOptionSpec($$);sub OptCtl($);sub FindOption($$$$$);sub ValidValue ($$$$$);my$requested_version=0;sub ConfigDefaults() {if (defined$ENV{"POSIXLY_CORRECT"}){$genprefix="(--|-)";$autoabbrev=0;$bundling=0;$getopt_compat=0;$order=$REQUIRE_ORDER}else {$genprefix="(--|-|\\+)";$autoabbrev=1;$bundling=0;$getopt_compat=1;$order=$PERMUTE}$debug=0;$error=0;$ignorecase=1;$passthrough=0;$gnu_compat=0;$longprefix="(--)";$bundling_values=0}sub import {my$pkg=shift;my@syms=();my@config=();my$dest=\@syms;for (@_){if ($_ eq ':config'){$dest=\@config;next}push(@$dest,$_)}local$Exporter::ExportLevel=1;push(@syms,qw(&GetOptions))if@syms;$requested_version=0;$pkg->SUPER::import(@syms);Configure(@config)if@config}($REQUIRE_ORDER,$PERMUTE,$RETURN_IN_ORDER)=(0..2);($major_version,$minor_version)=$VERSION =~ /^(\d+)\.(\d+)/;ConfigDefaults();package Getopt::Long::Parser;my$default_config=do {Getopt::Long::Configure ()};sub new {my$that=shift;my$class=ref($that)|| $that;my%atts=@_;my$self={caller_pkg=>(caller)[0]};bless ($self,$class);if (defined$atts{config}){my$save=Getopt::Long::Configure ($default_config,@{$atts{config}});$self->{settings}=Getopt::Long::Configure ($save);delete ($atts{config})}else {$self->{settings}=$default_config}if (%atts){die(__PACKAGE__.": unhandled attributes: ".join(" ",sort(keys(%atts)))."\n")}$self}sub configure {my ($self)=shift;my$save=Getopt::Long::Configure ($self->{settings},@_);$self->{settings}=Getopt::Long::Configure ($save)}sub getoptions {my ($self)=shift;return$self->getoptionsfromarray(\@ARGV,@_)}sub getoptionsfromarray {my ($self)=shift;my$save=Getopt::Long::Configure ($self->{settings});my$ret=0;$Getopt::Long::caller=$self->{caller_pkg};eval {local ($SIG{__DIE__})='DEFAULT';$ret=Getopt::Long::GetOptionsFromArray (@_)};Getopt::Long::Configure ($save);die ($@)if $@;return$ret}package Getopt::Long;use constant CTL_TYPE=>0;use constant CTL_CNAME=>1;use constant CTL_DEFAULT=>2;use constant CTL_DEST=>3;use constant CTL_DEST_SCALAR=>0;use constant CTL_DEST_ARRAY=>1;use constant CTL_DEST_HASH=>2;use constant CTL_DEST_CODE=>3;use constant CTL_AMIN=>4;use constant CTL_AMAX=>5;use constant PAT_INT=>"[-+]?_*[0-9][0-9_]*";use constant PAT_XINT=>"(?:"."[-+]?_*[1-9][0-9_]*"."|"."0x_*[0-9a-f][0-9a-f_]*"."|"."0b_*[01][01_]*"."|"."0[0-7_]*".")";use constant PAT_FLOAT=>"[-+]?"."(?=[0-9.])"."[0-9_]*"."(\.[0-9_]+)?"."([eE][-+]?[0-9_]+)?";sub GetOptions(@) {unshift(@_,\@ARGV);goto&GetOptionsFromArray}sub GetOptionsFromString(@) {my ($string)=shift;require Text::ParseWords;my$args=[Text::ParseWords::shellwords($string)];$caller ||= (caller)[0];my$ret=GetOptionsFromArray($args,@_);return ($ret,$args)if wantarray;if (@$args){$ret=0;warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n")}$ret}sub GetOptionsFromArray(@) {my ($argv,@optionlist)=@_;my$argend='--';my%opctl=();my$pkg=$caller || (caller)[0];my@ret=();my%linkage;my$userlinkage;my$opt;my$prefix=$genprefix;$error='';if ($debug){local ($^W)=0;print STDERR ("Getopt::Long $Getopt::Long::VERSION_STRING ","called from package \"$pkg\".","\n  ","argv: ",defined($argv)? UNIVERSAL::isa($argv,'ARRAY')? "(@$argv)" : $argv : "<undef>","\n  ","autoabbrev=$autoabbrev,"."bundling=$bundling,","bundling_values=$bundling_values,","getopt_compat=$getopt_compat,","gnu_compat=$gnu_compat,","order=$order,","\n  ","ignorecase=$ignorecase,","requested_version=$requested_version,","passthrough=$passthrough,","genprefix=\"$genprefix\",","longprefix=\"$longprefix\".","\n")}$userlinkage=undef;if (@optionlist && ref($optionlist[0])and UNIVERSAL::isa($optionlist[0],'HASH')){$userlinkage=shift (@optionlist);print STDERR ("=> user linkage: $userlinkage\n")if$debug}if (@optionlist && $optionlist[0]=~ /^\W+$/ &&!($optionlist[0]eq '<>' && @optionlist > 0 && ref($optionlist[1]))){$prefix=shift (@optionlist);$prefix =~ s/(\W)/\\$1/g;$prefix="([" .$prefix ."])";print STDERR ("=> prefix=\"$prefix\"\n")if$debug}%opctl=();while (@optionlist){my$opt=shift (@optionlist);unless (defined($opt)){$error .= "Undefined argument in option spec\n";next}$opt=$+ if$opt =~ /^$prefix+(.*)$/s;if ($opt eq '<>'){if ((defined$userlinkage)&&!(@optionlist > 0 && ref($optionlist[0]))&& (exists$userlinkage->{$opt})&& ref($userlinkage->{$opt})){unshift (@optionlist,$userlinkage->{$opt})}unless (@optionlist > 0 && ref($optionlist[0])&& ref($optionlist[0])eq 'CODE'){$error .= "Option spec <> requires a reference to a subroutine\n";shift (@optionlist)if@optionlist && ref($optionlist[0]);next}$linkage{'<>'}=shift (@optionlist);next}my ($name,$orig)=ParseOptionSpec ($opt,\%opctl);unless (defined$name){$error .= $orig;shift (@optionlist)if@optionlist && ref($optionlist[0]);next}if (defined$userlinkage){unless (@optionlist > 0 && ref($optionlist[0])){if (exists$userlinkage->{$orig}&& ref($userlinkage->{$orig})){print STDERR ("=> found userlinkage for \"$orig\": ","$userlinkage->{$orig}\n")if$debug;unshift (@optionlist,$userlinkage->{$orig})}else {next}}}if (@optionlist > 0 && ref($optionlist[0])){print STDERR ("=> link \"$orig\" to $optionlist[0]\n")if$debug;my$rl=ref($linkage{$orig}=shift (@optionlist));if ($rl eq "ARRAY"){$opctl{$name}[CTL_DEST]=CTL_DEST_ARRAY}elsif ($rl eq "HASH"){$opctl{$name}[CTL_DEST]=CTL_DEST_HASH}elsif ($rl eq "SCALAR" || $rl eq "REF"){}elsif ($rl eq "CODE"){}else {$error .= "Invalid option linkage for \"$opt\"\n"}}else {my$ov=$orig;$ov =~ s/\W/_/g;if ($opctl{$name}[CTL_DEST]==CTL_DEST_ARRAY){print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")if$debug;eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;")}elsif ($opctl{$name}[CTL_DEST]==CTL_DEST_HASH){print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")if$debug;eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;")}else {print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")if$debug;eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;")}}if ($opctl{$name}[CTL_TYPE]eq 'I' && ($opctl{$name}[CTL_DEST]==CTL_DEST_ARRAY || $opctl{$name}[CTL_DEST]==CTL_DEST_HASH)){$error .= "Invalid option linkage for \"$opt\"\n"}}$error .= "GetOptionsFromArray: 1st parameter is not an array reference\n" unless$argv && UNIVERSAL::isa($argv,'ARRAY');die ($error)if$error;$error=0;if (defined($auto_version)? $auto_version : ($requested_version >= 2.3203)){if (!defined($opctl{version})){$opctl{version}=['','version',0,CTL_DEST_CODE,undef];$linkage{version}=\&VersionMessage}$auto_version=1}if (defined($auto_help)? $auto_help : ($requested_version >= 2.3203)){if (!defined($opctl{help})&&!defined($opctl{'?'})){$opctl{help}=$opctl{'?'}=['','help',0,CTL_DEST_CODE,undef];$linkage{help}=\&HelpMessage}$auto_help=1}if ($debug){my ($arrow,$k,$v);$arrow="=> ";while (($k,$v)=each(%opctl)){print STDERR ($arrow,"\$opctl{$k} = $v ",OptCtl($v),"\n");$arrow="   "}}my$goon=1;while ($goon && @$argv > 0){$opt=shift (@$argv);print STDERR ("=> arg \"",$opt,"\"\n")if$debug;if (defined($opt)&& $opt eq $argend){push (@ret,$argend)if$passthrough;last}my$tryopt=$opt;my$found;my$key;my$arg;my$ctl;($found,$opt,$ctl,$arg,$key)=FindOption ($argv,$prefix,$argend,$opt,\%opctl);if ($found){next unless defined$opt;my$argcnt=0;while (defined$arg){my$given=$opt;print STDERR ("=> cname for \"$opt\" is ")if$debug;$opt=$ctl->[CTL_CNAME];print STDERR ("\"$ctl->[CTL_CNAME]\"\n")if$debug;if (defined$linkage{$opt}){print STDERR ("=> ref(\$L{$opt}) -> ",ref($linkage{$opt}),"\n")if$debug;if (ref($linkage{$opt})eq 'SCALAR' || ref($linkage{$opt})eq 'REF'){if ($ctl->[CTL_TYPE]eq '+'){print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")if$debug;if (defined ${$linkage{$opt}}){${$linkage{$opt}}+= $arg}else {${$linkage{$opt}}=$arg}}elsif ($ctl->[CTL_DEST]==CTL_DEST_ARRAY){print STDERR ("=> ref(\$L{$opt}) auto-vivified"," to ARRAY\n")if$debug;my$t=$linkage{$opt};$$t=$linkage{$opt}=[];print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")if$debug;push (@{$linkage{$opt}},$arg)}elsif ($ctl->[CTL_DEST]==CTL_DEST_HASH){print STDERR ("=> ref(\$L{$opt}) auto-vivified"," to HASH\n")if$debug;my$t=$linkage{$opt};$$t=$linkage{$opt}={};print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")if$debug;$linkage{$opt}->{$key}=$arg}else {print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")if$debug;${$linkage{$opt}}=$arg}}elsif (ref($linkage{$opt})eq 'ARRAY'){print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")if$debug;push (@{$linkage{$opt}},$arg)}elsif (ref($linkage{$opt})eq 'HASH'){print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")if$debug;$linkage{$opt}->{$key}=$arg}elsif (ref($linkage{$opt})eq 'CODE'){print STDERR ("=> &L{$opt}(\"$opt\"",$ctl->[CTL_DEST]==CTL_DEST_HASH ? ", \"$key\"" : "",", \"$arg\")\n")if$debug;my$eval_error=do {local $@;local$SIG{__DIE__}='DEFAULT';eval {&{$linkage{$opt}}(Getopt::Long::CallBack->new (name=>$opt,given=>$given,ctl=>$ctl,opctl=>\%opctl,linkage=>\%linkage,prefix=>$prefix,),$ctl->[CTL_DEST]==CTL_DEST_HASH ? ($key): (),$arg)};$@};print STDERR ("=> die($eval_error)\n")if$debug && $eval_error ne '';if ($eval_error =~ /^!/){if ($eval_error =~ /^!FINISH\b/){$goon=0}}elsif ($eval_error ne ''){warn ($eval_error);$error++}}else {print STDERR ("Invalid REF type \"",ref($linkage{$opt}),"\" in linkage\n");die("Getopt::Long -- internal error!\n")}}elsif ($ctl->[CTL_DEST]==CTL_DEST_ARRAY){if (defined$userlinkage->{$opt}){print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")if$debug;push (@{$userlinkage->{$opt}},$arg)}else {print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")if$debug;$userlinkage->{$opt}=[$arg]}}elsif ($ctl->[CTL_DEST]==CTL_DEST_HASH){if (defined$userlinkage->{$opt}){print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")if$debug;$userlinkage->{$opt}->{$key}=$arg}else {print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")if$debug;$userlinkage->{$opt}={$key=>$arg}}}else {if ($ctl->[CTL_TYPE]eq '+'){print STDERR ("=> \$L{$opt} += \"$arg\"\n")if$debug;if (defined$userlinkage->{$opt}){$userlinkage->{$opt}+= $arg}else {$userlinkage->{$opt}=$arg}}else {print STDERR ("=>\$L{$opt} = \"$arg\"\n")if$debug;$userlinkage->{$opt}=$arg}}$argcnt++;last if$argcnt >= $ctl->[CTL_AMAX]&& $ctl->[CTL_AMAX]!=-1;undef($arg);if ($argcnt < $ctl->[CTL_AMIN]){if (@$argv){if (ValidValue($ctl,$argv->[0],1,$argend,$prefix)){$arg=shift(@$argv);if ($ctl->[CTL_TYPE]=~ /^[iIo]$/){$arg =~ tr/_//d;$arg=$ctl->[CTL_TYPE]eq 'o' && $arg =~ /^0/ ? oct($arg): 0+$arg}($key,$arg)=$arg =~ /^([^=]+)=(.*)/ if$ctl->[CTL_DEST]==CTL_DEST_HASH;next}warn("Value \"$$argv[0]\" invalid for option $opt\n");$error++}else {warn("Insufficient arguments for option $opt\n");$error++}}if (@$argv && ValidValue($ctl,$argv->[0],0,$argend,$prefix)){$arg=shift(@$argv);if ($ctl->[CTL_TYPE]=~ /^[iIo]$/){$arg =~ tr/_//d;$arg=$ctl->[CTL_TYPE]eq 'o' && $arg =~ /^0/ ? oct($arg): 0+$arg}($key,$arg)=$arg =~ /^([^=]+)=(.*)/ if$ctl->[CTL_DEST]==CTL_DEST_HASH;next}}}elsif ($order==$PERMUTE){my$cb;if (defined ($cb=$linkage{'<>'})){print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")if$debug;my$eval_error=do {local $@;local$SIG{__DIE__}='DEFAULT';eval {&$cb($tryopt)};$@};print STDERR ("=> die($eval_error)\n")if$debug && $eval_error ne '';if ($eval_error =~ /^!/){if ($eval_error =~ /^!FINISH\b/){$goon=0}}elsif ($eval_error ne ''){warn ($eval_error);$error++}}else {print STDERR ("=> saving \"$tryopt\" ","(not an option, may permute)\n")if$debug;push (@ret,$tryopt)}next}else {unshift (@$argv,$tryopt);return ($error==0)}}if (@ret && ($order==$PERMUTE || $passthrough)){print STDERR ("=> restoring \"",join('" "',@ret),"\"\n")if$debug;unshift (@$argv,@ret)}return ($error==0)}sub OptCtl ($) {my ($v)=@_;my@v=map {defined($_)? ($_): ("<undef>")}@$v;"[".join(",","\"$v[CTL_TYPE]\"","\"$v[CTL_CNAME]\"","\"$v[CTL_DEFAULT]\"",("\$","\@","\%","\&")[$v[CTL_DEST]|| 0],$v[CTL_AMIN]|| '',$v[CTL_AMAX]|| '',)."]"}sub ParseOptionSpec ($$) {my ($opt,$opctl)=@_;if ($opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Aliases
  		     (?: \| (?: . [^|!+=:]* )? )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x){return (undef,"Error in option spec: \"$opt\"\n")}my ($names,$spec)=($1,$2);$spec='' unless defined$spec;my$orig;my@names;if (defined$names){@names=split (/\|/,$names);$orig=$names[0]}else {@names=('');$orig=''}my$entry;if ($spec eq '' || $spec eq '+' || $spec eq '!'){$entry=[$spec,$orig,undef,CTL_DEST_SCALAR,0,0]}elsif ($spec =~ /^:(-?\d+|\+)([@%])?$/){my$def=$1;my$dest=$2;my$type=$def eq '+' ? 'I' : 'i';$dest ||= '$';$dest=$dest eq '@' ? CTL_DEST_ARRAY : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;$entry=[$type,$orig,$def eq '+' ? undef : $def,$dest,0,1]}else {my ($mand,$type,$dest)=$spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;return (undef,"Cannot repeat while bundling: \"$opt\"\n")if$bundling && defined($4);my ($mi,$cm,$ma)=($5,$6,$7);return (undef,"{0} is useless in option spec: \"$opt\"\n")if defined($mi)&&!$mi &&!defined($ma)&&!defined($cm);$type='i' if$type eq 'n';$dest ||= '$';$dest=$dest eq '@' ? CTL_DEST_ARRAY : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;$mi=$mand eq '=' ? 1 : 0 unless defined$mi;$mand=$mi ? '=' : ':';$ma=$mi ? $mi : 1 unless defined$ma || defined$cm;return (undef,"Max must be greater than zero in option spec: \"$opt\"\n")if defined($ma)&&!$ma;return (undef,"Max less than min in option spec: \"$opt\"\n")if defined($ma)&& $ma < $mi;$entry=[$type,$orig,undef,$dest,$mi,$ma||-1]}my$dups='';for (@names){$_=lc ($_)if$ignorecase > (($bundling && length($_)==1)? 1 : 0);if (exists$opctl->{$_}){$dups .= "Duplicate specification \"$opt\" for option \"$_\"\n"}if ($spec eq '!'){$opctl->{"no$_"}=$entry;$opctl->{"no-$_"}=$entry;$opctl->{$_}=[@$entry];$opctl->{$_}->[CTL_TYPE]=''}else {$opctl->{$_}=$entry}}if ($dups && $^W){for (split(/\n+/,$dups)){warn($_."\n")}}($names[0],$orig)}sub FindOption ($$$$$) {my ($argv,$prefix,$argend,$opt,$opctl)=@_;print STDERR ("=> find \"$opt\"\n")if$debug;return (0)unless defined($opt);return (0)unless$opt =~ /^($prefix)(.*)$/s;return (0)if$opt eq "-" &&!defined$opctl->{''};$opt=substr($opt,length($1));my$starter=$1;print STDERR ("=> split \"$starter\"+\"$opt\"\n")if$debug;my$optarg;my$rest;if (($starter=~/^$longprefix$/ || ($getopt_compat && ($bundling==0 || $bundling==2)))&& (my$oppos=index($opt,'=',1))> 0){my$optorg=$opt;$opt=substr($optorg,0,$oppos);$optarg=substr($optorg,$oppos + 1);print STDERR ("=> option \"",$opt,"\", optarg = \"$optarg\"\n")if$debug}my$tryopt=$opt;if (($bundling || $bundling_values)&& $starter eq '-'){$tryopt=$ignorecase ? lc($opt): $opt;if ($bundling==2 && length($tryopt)> 1 && defined ($opctl->{$tryopt})){print STDERR ("=> $starter$tryopt overrides unbundling\n")if$debug}elsif ($bundling_values){$tryopt=$opt;$rest=length ($tryopt)> 0 ? substr ($tryopt,1): '';$tryopt=substr ($tryopt,0,1);$tryopt=lc ($tryopt)if$ignorecase > 1;print STDERR ("=> $starter$tryopt unbundled from ","$starter$tryopt$rest\n")if$debug;$optarg=$rest eq '' ? undef : $rest;$rest=undef}else {$tryopt=$opt;$rest=length ($tryopt)> 0 ? substr ($tryopt,1): '';$tryopt=substr ($tryopt,0,1);$tryopt=lc ($tryopt)if$ignorecase > 1;print STDERR ("=> $starter$tryopt unbundled from ","$starter$tryopt$rest\n")if$debug;$rest=undef unless$rest ne ''}}elsif ($autoabbrev && $opt ne ""){my@names=sort(keys (%$opctl));$opt=lc ($opt)if$ignorecase;$tryopt=$opt;my$pat=quotemeta ($opt);my@hits=grep (/^$pat/,@names);print STDERR ("=> ",scalar(@hits)," hits (@hits) with \"$pat\" ","out of ",scalar(@names),"\n")if$debug;unless ((@hits <= 1)|| (grep ($_ eq $opt,@hits)==1)){my%hit;for (@hits){my$hit=$opctl->{$_}->[CTL_CNAME]if defined$opctl->{$_}->[CTL_CNAME];$hit="no" .$hit if$opctl->{$_}->[CTL_TYPE]eq '!';$hit{$hit}=1}if (keys(%hit)==2){if ($auto_version && exists($hit{version})){delete$hit{version}}elsif ($auto_help && exists($hit{help})){delete$hit{help}}}unless (keys(%hit)==1){return (0)if$passthrough;warn ("Option ",$opt," is ambiguous (",join(", ",@hits),")\n");$error++;return (1,undef)}@hits=keys(%hit)}if (@hits==1 && $hits[0]ne $opt){$tryopt=$hits[0];$tryopt=lc ($tryopt)if$ignorecase > (($bundling && length($tryopt)==1)? 1 : 0);print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")if$debug}}elsif ($ignorecase){$tryopt=lc ($opt)}my$ctl=$opctl->{$tryopt};unless (defined$ctl){return (0)if$passthrough;if ($bundling==1 && length($starter)==1){$opt=substr($opt,0,1);unshift (@$argv,$starter.$rest)if defined$rest}if ($opt eq ""){warn ("Missing option after ",$starter,"\n")}else {warn ("Unknown option: ",$opt,"\n")}$error++;return (1,undef)}$opt=$tryopt;print STDERR ("=> found ",OptCtl($ctl)," for \"",$opt,"\"\n")if$debug;my$type=$ctl->[CTL_TYPE];my$arg;if ($type eq '' || $type eq '!' || $type eq '+'){if (defined$optarg){return (0)if$passthrough;warn ("Option ",$opt," does not take an argument\n");$error++;undef$opt;undef$optarg if$bundling_values}elsif ($type eq '' || $type eq '+'){$arg=1}else {$opt =~ s/^no-?//i;$arg=0}unshift (@$argv,$starter.$rest)if defined$rest;return (1,$opt,$ctl,$arg)}my$mand=$ctl->[CTL_AMIN];if ($gnu_compat){my$optargtype=0;if (defined($optarg)){$optargtype=(length($optarg)==0)? 1 : 2}elsif (defined$rest || @$argv > 0){$optargtype=3}if(($optargtype==0)&&!$mand){if ($type eq 'I'){my@c=@$ctl;$c[CTL_TYPE]='+';return (1,$opt,\@c,1)}my$val =defined($ctl->[CTL_DEFAULT])? $ctl->[CTL_DEFAULT]: $type eq 's' ? '' : 0;return (1,$opt,$ctl,$val)}return (1,$opt,$ctl,$type eq 's' ? '' : 0)if$optargtype==1}if (defined$optarg ? ($optarg eq ''):!(defined$rest || @$argv > 0)){if ($mand || $ctl->[CTL_DEST]==CTL_DEST_HASH){return (0)if$passthrough;warn ("Option ",$opt," requires an argument\n");$error++;return (1,undef)}if ($type eq 'I'){my@c=@$ctl;$c[CTL_TYPE]='+';return (1,$opt,\@c,1)}return (1,$opt,$ctl,defined($ctl->[CTL_DEFAULT])? $ctl->[CTL_DEFAULT]: $type eq 's' ? '' : 0)}$arg=(defined$rest ? $rest : (defined$optarg ? $optarg : shift (@$argv)));my$key;if ($ctl->[CTL_DEST]==CTL_DEST_HASH && defined$arg){($key,$arg)=($arg =~ /^([^=]*)=(.*)$/s)? ($1,$2): ($arg,defined($ctl->[CTL_DEFAULT])? $ctl->[CTL_DEFAULT]: ($mand ? undef : ($type eq 's' ? "" : 1)));if (!defined$arg){warn ("Option $opt, key \"$key\", requires a value\n");$error++;unshift (@$argv,$starter.$rest)if defined$rest;return (1,undef)}}my$key_valid=$ctl->[CTL_DEST]==CTL_DEST_HASH ? "[^=]+=" : "";if ($type eq 's'){return (1,$opt,$ctl,$arg,$key)if$mand;return (1,$opt,$ctl,$arg,$key)if$ctl->[CTL_DEST]==CTL_DEST_HASH;return (1,$opt,$ctl,$arg,$key)if defined$optarg || defined$rest;return (1,$opt,$ctl,$arg,$key)if$arg eq "-";if ($arg eq $argend || $arg =~ /^$prefix.+/){unshift (@$argv,$arg);$arg=''}}elsif ($type eq 'i' || $type eq 'I' || $type eq 'o'){my$o_valid=$type eq 'o' ? PAT_XINT : PAT_INT;if ($bundling && defined$rest && $rest =~ /^($key_valid)($o_valid)(.*)$/si){($key,$arg,$rest)=($1,$2,$+);chop($key)if$key;$arg=($type eq 'o' && $arg =~ /^0/)? oct($arg): 0+$arg;unshift (@$argv,$starter.$rest)if defined$rest && $rest ne ''}elsif ($arg =~ /^$o_valid$/si){$arg =~ tr/_//d;$arg=($type eq 'o' && $arg =~ /^0/)? oct($arg): 0+$arg}else {if (defined$optarg || $mand){if ($passthrough){unshift (@$argv,defined$rest ? $starter.$rest : $arg)unless defined$optarg;return (0)}warn ("Value \"",$arg,"\" invalid for option ",$opt," (",$type eq 'o' ? "extended " : '',"number expected)\n");$error++;unshift (@$argv,$starter.$rest)if defined$rest;return (1,undef)}else {unshift (@$argv,defined$rest ? $starter.$rest : $arg);if ($type eq 'I'){my@c=@$ctl;$c[CTL_TYPE]='+';return (1,$opt,\@c,1)}$arg=defined($ctl->[CTL_DEFAULT])? $ctl->[CTL_DEFAULT]: 0}}}elsif ($type eq 'f'){my$o_valid=PAT_FLOAT;if ($bundling && defined$rest && $rest =~ /^($key_valid)($o_valid)(.*)$/s){$arg =~ tr/_//d;($key,$arg,$rest)=($1,$2,$+);chop($key)if$key;unshift (@$argv,$starter.$rest)if defined$rest && $rest ne ''}elsif ($arg =~ /^$o_valid$/){$arg =~ tr/_//d}else {if (defined$optarg || $mand){if ($passthrough){unshift (@$argv,defined$rest ? $starter.$rest : $arg)unless defined$optarg;return (0)}warn ("Value \"",$arg,"\" invalid for option ",$opt," (real number expected)\n");$error++;unshift (@$argv,$starter.$rest)if defined$rest;return (1,undef)}else {unshift (@$argv,defined$rest ? $starter.$rest : $arg);$arg=0.0}}}else {die("Getopt::Long internal error (Can't happen)\n")}return (1,$opt,$ctl,$arg,$key)}sub ValidValue ($$$$$) {my ($ctl,$arg,$mand,$argend,$prefix)=@_;if ($ctl->[CTL_DEST]==CTL_DEST_HASH){return 0 unless$arg =~ /[^=]+=(.*)/;$arg=$1}my$type=$ctl->[CTL_TYPE];if ($type eq 's'){return (1)if$mand;return (1)if$arg eq "-";return 0 if$arg eq $argend || $arg =~ /^$prefix.+/;return 1}elsif ($type eq 'i' || $type eq 'I' || $type eq 'o'){my$o_valid=$type eq 'o' ? PAT_XINT : PAT_INT;return$arg =~ /^$o_valid$/si}elsif ($type eq 'f'){my$o_valid=PAT_FLOAT;return$arg =~ /^$o_valid$/}die("ValidValue: Cannot happen\n")}sub Configure (@) {my (@options)=@_;my$prevconfig=[$error,$debug,$major_version,$minor_version,$caller,$autoabbrev,$getopt_compat,$ignorecase,$bundling,$order,$gnu_compat,$passthrough,$genprefix,$auto_version,$auto_help,$longprefix,$bundling_values ];if (ref($options[0])eq 'ARRAY'){($error,$debug,$major_version,$minor_version,$caller,$autoabbrev,$getopt_compat,$ignorecase,$bundling,$order,$gnu_compat,$passthrough,$genprefix,$auto_version,$auto_help,$longprefix,$bundling_values)=@{shift(@options)}}my$opt;for$opt (@options){my$try=lc ($opt);my$action=1;if ($try =~ /^no_?(.*)$/s){$action=0;$try=$+}if (($try eq 'default' or $try eq 'defaults')&& $action){ConfigDefaults ()}elsif (($try eq 'posix_default' or $try eq 'posix_defaults')){local$ENV{POSIXLY_CORRECT};$ENV{POSIXLY_CORRECT}=1 if$action;ConfigDefaults ()}elsif ($try eq 'auto_abbrev' or $try eq 'autoabbrev'){$autoabbrev=$action}elsif ($try eq 'getopt_compat'){$getopt_compat=$action;$genprefix=$action ? "(--|-|\\+)" : "(--|-)"}elsif ($try eq 'gnu_getopt'){if ($action){$gnu_compat=1;$bundling=1;$getopt_compat=0;$genprefix="(--|-)";$order=$PERMUTE;$bundling_values=0}}elsif ($try eq 'gnu_compat'){$gnu_compat=$action;$bundling=0;$bundling_values=1}elsif ($try =~ /^(auto_?)?version$/){$auto_version=$action}elsif ($try =~ /^(auto_?)?help$/){$auto_help=$action}elsif ($try eq 'ignorecase' or $try eq 'ignore_case'){$ignorecase=$action}elsif ($try eq 'ignorecase_always' or $try eq 'ignore_case_always'){$ignorecase=$action ? 2 : 0}elsif ($try eq 'bundling'){$bundling=$action;$bundling_values=0 if$action}elsif ($try eq 'bundling_override'){$bundling=$action ? 2 : 0;$bundling_values=0 if$action}elsif ($try eq 'bundling_values'){$bundling_values=$action;$bundling=0 if$action}elsif ($try eq 'require_order'){$order=$action ? $REQUIRE_ORDER : $PERMUTE}elsif ($try eq 'permute'){$order=$action ? $PERMUTE : $REQUIRE_ORDER}elsif ($try eq 'pass_through' or $try eq 'passthrough'){$passthrough=$action}elsif ($try =~ /^prefix=(.+)$/ && $action){$genprefix=$1;$genprefix="(" .quotemeta($genprefix).")";eval {'' =~ /$genprefix/};die("Getopt::Long: invalid pattern \"$genprefix\"\n")if $@}elsif ($try =~ /^prefix_pattern=(.+)$/ && $action){$genprefix=$1;$genprefix="(" .$genprefix .")" unless$genprefix =~ /^\(.*\)$/;eval {'' =~ m"$genprefix"};die("Getopt::Long: invalid pattern \"$genprefix\"\n")if $@}elsif ($try =~ /^long_prefix_pattern=(.+)$/ && $action){$longprefix=$1;$longprefix="(" .$longprefix .")" unless$longprefix =~ /^\(.*\)$/;eval {'' =~ m"$longprefix"};die("Getopt::Long: invalid long prefix pattern \"$longprefix\"\n")if $@}elsif ($try eq 'debug'){$debug=$action}else {die("Getopt::Long: unknown or erroneous config parameter \"$opt\"\n")}}$prevconfig}sub config (@) {Configure (@_)}sub VersionMessage(@) {my$pa=setup_pa_args("version",@_);my$v=$main::VERSION;my$fh=$pa->{-output}|| (($pa->{-exitval}eq "NOEXIT" || $pa->{-exitval}< 2)? \*STDOUT : \*STDERR);print$fh (defined($pa->{-message})? $pa->{-message}: (),$0,defined$v ? " version $v" : (),"\n","(",__PACKAGE__,"::","GetOptions"," version ",defined($Getopt::Long::VERSION_STRING)? $Getopt::Long::VERSION_STRING : $VERSION,";"," Perl version ",$] >= 5.006 ? sprintf("%vd",$^V): $],")\n");exit($pa->{-exitval})unless$pa->{-exitval}eq "NOEXIT"}sub HelpMessage(@) {eval {require Pod::Usage;import Pod::Usage;1}|| die("Cannot provide help: cannot load Pod::Usage\n");pod2usage(setup_pa_args("help",@_))}sub setup_pa_args($@) {my$tag=shift;@_=()if @_==2 && $_[0]eq $tag;my$pa;if (@_ > 1){$pa={@_ }}else {$pa=shift || {}}if (UNIVERSAL::isa($pa,'HASH')){$pa->{-message}=$pa->{-msg};delete($pa->{-msg})}elsif ($pa =~ /^-?\d+$/){$pa={-exitval=>$pa }}else {$pa={-message=>$pa }}$pa->{-verbose}=0 unless exists($pa->{-verbose});$pa->{-exitval}=0 unless exists($pa->{-exitval});$pa}sub VERSION {$requested_version=$_[1]if @_ > 1;shift->SUPER::VERSION(@_)}package Getopt::Long::CallBack;sub new {my ($pkg,%atts)=@_;bless {%atts },$pkg}sub name {my$self=shift;''.$self->{name}}sub given {my$self=shift;$self->{given}}use overload '""'=>\&name,fallback=>1;1;
GETOPT_LONG

$fatpacked{"GitHub/Release.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GITHUB_RELEASE';
  package GitHub::Release;use strict;use warnings;our$VERSION='0.001';{package _HTTP;use parent 'HTTP::Tinyish::Curl';sub new {my ($class,%argv)=@_;$class->configure;$class->supports("https")or die "missing curl";$class->SUPER::new(verify_SSL=>1,agent=>"Mozilla/5.0",%argv)}sub build_options {my ($self,$url,$opts)=@_;my@option=$self->SUPER::build_options($url,$opts);if (exists$self->{max_redirect}&&!$self->{max_redirect}){my@new=("--no-location");while (my$option=shift@option){if ($option eq "--location"){next}if ($option eq "--max-redirs"){shift@option;push@new,"--max-redirs",0;next}push@new,$option}@option=@new}@option}}sub new {my$class=shift;bless {http=>_HTTP->new,http_no_redirect=>_HTTP->new(max_redirect=>0),},$class}sub get_latest_tag {my ($self,$url)=@_;$url="$url/releases/latest";my$res=$self->{http_no_redirect}->get($url);if ($res->{status}!~ /^3/){die "$res->{status}, $url\n"}my$loc=$res->{headers}{location};(split /\//,$loc)[-1]}sub get_latest_assets {my ($self,$url)=@_;$url="$url/releases/latest";my$res=$self->{http}->get($url);if (!$res->{success}){die "$res->{status}, $url\n"}my@href=$res->{content}=~ m{ href="(.+?)" }xgi;map {m{^https} ? $_ : "https://github.com$_"}grep {m{/releases/download/}}@href}1;
GITHUB_RELEASE

$fatpacked{"HTTP/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINY';
  package HTTP::Tiny;use strict;use warnings;our$VERSION='0.080';sub _croak {require Carp;Carp::croak(@_)}my@attributes;BEGIN {@attributes=qw(cookie_jar default_headers http_proxy https_proxy keep_alive local_address max_redirect max_size proxy no_proxy SSL_options verify_SSL);my%persist_ok=map {;$_=>1}qw(cookie_jar default_headers max_redirect max_size);no strict 'refs';no warnings 'uninitialized';for my$accessor (@attributes){*{$accessor}=sub {@_ > 1 ? do {delete $_[0]->{handle}if!$persist_ok{$accessor}&& $_[1]ne $_[0]->{$accessor};$_[0]->{$accessor}=$_[1]}: $_[0]->{$accessor}}}}sub agent {my($self,$agent)=@_;if(@_ > 1){$self->{agent}=(defined$agent && $agent =~ / $/)? $agent .$self->_agent : $agent}return$self->{agent}}sub timeout {my ($self,$timeout)=@_;if (@_ > 1){$self->{timeout}=$timeout;if ($self->{handle}){$self->{handle}->timeout($timeout)}}return$self->{timeout}}sub new {my($class,%args)=@_;my$self={max_redirect=>5,timeout=>defined$args{timeout}? $args{timeout}: 60,keep_alive=>1,verify_SSL=>$args{verify_SSL}|| $args{verify_ssl}|| 0,no_proxy=>$ENV{no_proxy},};bless$self,$class;$class->_validate_cookie_jar($args{cookie_jar})if$args{cookie_jar};for my$key (@attributes){$self->{$key}=$args{$key}if exists$args{$key}}$self->agent(exists$args{agent}? $args{agent}: $class->_agent);$self->_set_proxies;return$self}sub _set_proxies {my ($self)=@_;if (!exists$self->{proxy}){$self->{proxy}=$ENV{all_proxy}|| $ENV{ALL_PROXY}}if (defined$self->{proxy}){$self->_split_proxy('generic proxy'=>$self->{proxy})}else {delete$self->{proxy}}if (!exists$self->{http_proxy}){local$ENV{HTTP_PROXY}=($ENV{CGI_HTTP_PROXY}|| "")if$ENV{REQUEST_METHOD};$self->{http_proxy}=$ENV{http_proxy}|| $ENV{HTTP_PROXY}|| $self->{proxy}}if (defined$self->{http_proxy}){$self->_split_proxy(http_proxy=>$self->{http_proxy});$self->{_has_proxy}{http}=1}else {delete$self->{http_proxy}}if (!exists$self->{https_proxy}){$self->{https_proxy}=$ENV{https_proxy}|| $ENV{HTTPS_PROXY}|| $self->{proxy}}if ($self->{https_proxy}){$self->_split_proxy(https_proxy=>$self->{https_proxy});$self->{_has_proxy}{https}=1}else {delete$self->{https_proxy}}unless (ref$self->{no_proxy}eq 'ARRAY'){$self->{no_proxy}=(defined$self->{no_proxy})? [split /\s*,\s*/,$self->{no_proxy}]: []}return}for my$sub_name (qw/get head put post patch delete/){my$req_method=uc$sub_name;no strict 'refs';eval <<"HERE"}sub post_form {my ($self,$url,$data,$args)=@_;(@_==3 || @_==4 && ref$args eq 'HASH')or _croak(q/Usage: $http->post_form(URL, DATAREF, [HASHREF])/ ."\n");my$headers={};while (my ($key,$value)=each %{$args->{headers}|| {}}){$headers->{lc$key}=$value}delete$args->{headers};return$self->request('POST',$url,{%$args,content=>$self->www_form_urlencode($data),headers=>{%$headers,'content-type'=>'application/x-www-form-urlencoded' },})}sub mirror {my ($self,$url,$file,$args)=@_;@_==3 || (@_==4 && ref$args eq 'HASH')or _croak(q/Usage: $http->mirror(URL, FILE, [HASHREF])/ ."\n");if (exists$args->{headers}){my$headers={};while (my ($key,$value)=each %{$args->{headers}|| {}}){$headers->{lc$key}=$value}$args->{headers}=$headers}if (-e $file and my$mtime=(stat($file))[9]){$args->{headers}{'if-modified-since'}||= $self->_http_date($mtime)}my$tempfile=$file .int(rand(2**31));require Fcntl;sysopen my$fh,$tempfile,Fcntl::O_CREAT()|Fcntl::O_EXCL()|Fcntl::O_WRONLY()or _croak(qq/Error: Could not create temporary file $tempfile for downloading: $!\n/);binmode$fh;$args->{data_callback}=sub {print {$fh}$_[0]};my$response=$self->request('GET',$url,$args);close$fh or _croak(qq/Error: Caught error closing temporary file $tempfile: $!\n/);if ($response->{success}){rename$tempfile,$file or _croak(qq/Error replacing $file with $tempfile: $!\n/);my$lm=$response->{headers}{'last-modified'};if ($lm and my$mtime=$self->_parse_http_date($lm)){utime$mtime,$mtime,$file}}$response->{success}||= $response->{status}eq '304';unlink$tempfile;return$response}my%idempotent=map {$_=>1}qw/GET HEAD PUT DELETE OPTIONS TRACE/;sub request {my ($self,$method,$url,$args)=@_;@_==3 || (@_==4 && ref$args eq 'HASH')or _croak(q/Usage: $http->request(METHOD, URL, [HASHREF])/ ."\n");$args ||= {};my$response;for (0 .. 1){$response=eval {$self->_request($method,$url,$args)};last unless $@ && $idempotent{$method}&& $@ =~ m{^(?:Socket closed|Unexpected end|SSL read error)}}if (my$e=$@){if (ref$e eq 'HASH' && exists$e->{status}){$e->{redirects}=delete$args->{_redirects}if @{$args->{_redirects}|| []};return$e}$e="$e";$response={url=>$url,success=>q{},status=>599,reason=>'Internal Exception',content=>$e,headers=>{'content-type'=>'text/plain','content-length'=>length$e,},(@{$args->{_redirects}|| []}? (redirects=>delete$args->{_redirects}): ()),}}return$response}sub www_form_urlencode {my ($self,$data)=@_;(@_==2 && ref$data)or _croak(q/Usage: $http->www_form_urlencode(DATAREF)/ ."\n");(ref$data eq 'HASH' || ref$data eq 'ARRAY')or _croak("form data must be a hash or array reference\n");my@params=ref$data eq 'HASH' ? %$data : @$data;@params % 2==0 or _croak("form data reference must have an even number of terms\n");my@terms;while(@params){my ($key,$value)=splice(@params,0,2);_croak("form data keys must not be undef")if!defined($key);if (ref$value eq 'ARRAY'){unshift@params,map {$key=>$_}@$value}else {push@terms,join("=",map {$self->_uri_escape($_)}$key,$value)}}return join("&",(ref$data eq 'ARRAY')? (@terms): (sort@terms))}sub can_ssl {my ($self)=@_;my($ok,$reason)=(1,'');local@INC=@INC;pop@INC if$INC[-1]eq '.';unless (eval {require IO::Socket::SSL;IO::Socket::SSL->VERSION(1.42)}){$ok=0;$reason .= qq/IO::Socket::SSL 1.42 must be installed for https support\n/}unless (eval {require Net::SSLeay;Net::SSLeay->VERSION(1.49)}){$ok=0;$reason .= qq/Net::SSLeay 1.49 must be installed for https support\n/}if (ref($self)&& ($self->{verify_SSL}|| $self->{SSL_options}{SSL_verify_mode})){my$handle=HTTP::Tiny::Handle->new(SSL_options=>$self->{SSL_options},verify_SSL=>$self->{verify_SSL},);unless (eval {$handle->_find_CA_file;1}){$ok=0;$reason .= "$@"}}wantarray ? ($ok,$reason): $ok}sub connected {my ($self)=@_;if ($self->{handle}){return$self->{handle}->connected}return}my%DefaultPort=(http=>80,https=>443,);sub _agent {my$class=ref($_[0])|| $_[0];(my$default_agent=$class)=~ s{::}{-}g;my$version=$class->VERSION;$default_agent .= "/$version" if defined$version;return$default_agent}sub _request {my ($self,$method,$url,$args)=@_;my ($scheme,$host,$port,$path_query,$auth)=$self->_split_url($url);if ($scheme ne 'http' && $scheme ne 'https'){die(qq/Unsupported URL scheme '$scheme'\n/)}my$request={method=>$method,scheme=>$scheme,host=>$host,port=>$port,host_port=>($port==$DefaultPort{$scheme}? $host : "$host:$port"),uri=>$path_query,headers=>{},};my$peer=$args->{peer}|| $host;if ('CODE' eq ref$peer){$peer=$peer->($host)}my$handle=delete$self->{handle};if ($handle){unless ($handle->can_reuse($scheme,$host,$port,$peer)){$handle->close;undef$handle}}$handle ||= $self->_open_handle($request,$scheme,$host,$port,$peer);$self->_prepare_headers_and_cb($request,$args,$url,$auth);$handle->write_request($request);my$response;do {$response=$handle->read_response_header}until (substr($response->{status},0,1)ne '1');$self->_update_cookie_jar($url,$response)if$self->{cookie_jar};my@redir_args=$self->_maybe_redirect($request,$response,$args);my$known_message_length;if ($method eq 'HEAD' || $response->{status}=~ /^[23]04/){$known_message_length=1}else {my$cb_args=@redir_args ? +{}: $args;my$data_cb=$self->_prepare_data_cb($response,$cb_args);$known_message_length=$handle->read_body($data_cb,$response)}if ($self->{keep_alive}&& $handle->connected && $known_message_length && $response->{protocol}eq 'HTTP/1.1' && ($response->{headers}{connection}|| '')ne 'close'){$self->{handle}=$handle}else {$handle->close}$response->{success}=substr($response->{status},0,1)eq '2';$response->{url}=$url;if (@redir_args){push @{$args->{_redirects}},$response;return$self->_request(@redir_args,$args)}$response->{redirects}=delete$args->{_redirects}if @{$args->{_redirects}};return$response}sub _open_handle {my ($self,$request,$scheme,$host,$port,$peer)=@_;my$handle=HTTP::Tiny::Handle->new(timeout=>$self->{timeout},SSL_options=>$self->{SSL_options},verify_SSL=>$self->{verify_SSL},local_address=>$self->{local_address},keep_alive=>$self->{keep_alive});if ($self->{_has_proxy}{$scheme}&&!grep {$host =~ /\Q$_\E$/}@{$self->{no_proxy}}){return$self->_proxy_connect($request,$handle)}else {return$handle->connect($scheme,$host,$port,$peer)}}sub _proxy_connect {my ($self,$request,$handle)=@_;my@proxy_vars;if ($request->{scheme}eq 'https'){_croak(qq{No https_proxy defined})unless$self->{https_proxy};@proxy_vars=$self->_split_proxy(https_proxy=>$self->{https_proxy});if ($proxy_vars[0]eq 'https'){_croak(qq{Can't proxy https over https: $request->{uri} via $self->{https_proxy}})}}else {_croak(qq{No http_proxy defined})unless$self->{http_proxy};@proxy_vars=$self->_split_proxy(http_proxy=>$self->{http_proxy})}my ($p_scheme,$p_host,$p_port,$p_auth)=@proxy_vars;if (length$p_auth &&!defined$request->{headers}{'proxy-authorization'}){$self->_add_basic_auth_header($request,'proxy-authorization'=>$p_auth)}$handle->connect($p_scheme,$p_host,$p_port,$p_host);if ($request->{scheme}eq 'https'){$self->_create_proxy_tunnel($request,$handle)}else {$request->{uri}="$request->{scheme}://$request->{host_port}$request->{uri}"}return$handle}sub _split_proxy {my ($self,$type,$proxy)=@_;my ($scheme,$host,$port,$path_query,$auth)=eval {$self->_split_url($proxy)};unless(defined($scheme)&& length($scheme)&& length($host)&& length($port)&& $path_query eq '/'){_croak(qq{$type URL must be in format http[s]://[auth@]<host>:<port>/\n})}return ($scheme,$host,$port,$auth)}sub _create_proxy_tunnel {my ($self,$request,$handle)=@_;$handle->_assert_ssl;my$agent=exists($request->{headers}{'user-agent'})? $request->{headers}{'user-agent'}: $self->{agent};my$connect_request={method=>'CONNECT',uri=>"$request->{host}:$request->{port}",headers=>{host=>"$request->{host}:$request->{port}",'user-agent'=>$agent,}};if ($request->{headers}{'proxy-authorization'}){$connect_request->{headers}{'proxy-authorization'}=delete$request->{headers}{'proxy-authorization'}}$handle->write_request($connect_request);my$response;do {$response=$handle->read_response_header}until (substr($response->{status},0,1)ne '1');unless (substr($response->{status},0,1)eq '2'){die$response}$handle->start_ssl($request->{host});return}sub _prepare_headers_and_cb {my ($self,$request,$args,$url,$auth)=@_;for ($self->{default_headers},$args->{headers}){next unless defined;while (my ($k,$v)=each %$_){$request->{headers}{lc$k}=$v;$request->{header_case}{lc$k}=$k}}if (exists$request->{headers}{'host'}){die(qq/The 'Host' header must not be provided as header option\n/)}$request->{headers}{'host'}=$request->{host_port};$request->{headers}{'user-agent'}||= $self->{agent};$request->{headers}{'connection'}="close" unless$self->{keep_alive};if ($request->{method}eq 'PUT' || $request->{method}eq 'POST'){if (!defined($args->{content})||!length($args->{content})){$request->{headers}{'content-length'}=0}}if (defined$args->{content}){if (ref$args->{content}eq 'CODE'){if (exists$request->{'content-length'}&& $request->{'content-length'}==0){$request->{cb}=sub {""}}else {$request->{headers}{'content-type'}||= "application/octet-stream";$request->{headers}{'transfer-encoding'}='chunked' unless exists$request->{headers}{'content-length'}|| $request->{headers}{'transfer-encoding'};$request->{cb}=$args->{content}}}elsif (length$args->{content}){my$content=$args->{content};if ($] ge '5.008'){utf8::downgrade($content,1)or die(qq/Wide character in request message body\n/)}$request->{headers}{'content-type'}||= "application/octet-stream";$request->{headers}{'content-length'}=length$content unless$request->{headers}{'content-length'}|| $request->{headers}{'transfer-encoding'};$request->{cb}=sub {substr$content,0,length$content,''}}$request->{trailer_cb}=$args->{trailer_callback}if ref$args->{trailer_callback}eq 'CODE'}if ($self->{cookie_jar}){my$cookies=$self->cookie_jar->cookie_header($url);$request->{headers}{cookie}=$cookies if length$cookies}if (length$auth &&!defined$request->{headers}{authorization}){$self->_add_basic_auth_header($request,'authorization'=>$auth)}return}sub _add_basic_auth_header {my ($self,$request,$header,$auth)=@_;require MIME::Base64;$request->{headers}{$header}="Basic " .MIME::Base64::encode_base64($auth,"");return}sub _prepare_data_cb {my ($self,$response,$args)=@_;my$data_cb=$args->{data_callback};$response->{content}='';if (!$data_cb || $response->{status}!~ /^2/){if (defined$self->{max_size}){$data_cb=sub {$_[1]->{content}.= $_[0];die(qq/Size of response body exceeds the maximum allowed of $self->{max_size}\n/)if length $_[1]->{content}> $self->{max_size}}}else {$data_cb=sub {$_[1]->{content}.= $_[0]}}}return$data_cb}sub _update_cookie_jar {my ($self,$url,$response)=@_;my$cookies=$response->{headers}->{'set-cookie'};return unless defined$cookies;my@cookies=ref$cookies ? @$cookies : $cookies;$self->cookie_jar->add($url,$_)for@cookies;return}sub _validate_cookie_jar {my ($class,$jar)=@_;for my$method (qw/add cookie_header/){_croak(qq/Cookie jar must provide the '$method' method\n/)unless ref($jar)&& ref($jar)->can($method)}return}sub _maybe_redirect {my ($self,$request,$response,$args)=@_;my$headers=$response->{headers};my ($status,$method)=($response->{status},$request->{method});$args->{_redirects}||= [];if (($status eq '303' or ($status =~ /^30[1278]/ && $method =~ /^GET|HEAD$/))and $headers->{location}and @{$args->{_redirects}}< $self->{max_redirect}){my$location=($headers->{location}=~ /^\//)? "$request->{scheme}://$request->{host_port}$headers->{location}" : $headers->{location};return (($status eq '303' ? 'GET' : $method),$location)}return}sub _split_url {my$url=pop;my ($scheme,$host,$path_query)=$url =~ m<\A([^:/?#]+)://([^/?#]*)([^#]*)> or die(qq/Cannot parse URL: '$url'\n/);$scheme=lc$scheme;$path_query="/$path_query" unless$path_query =~ m<\A/>;my$auth='';if ((my$i=index$host,'@')!=-1){$auth=substr$host,0,$i,'';substr$host,0,1,'';$auth =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg}my$port=$host =~ s/:(\d*)\z// && length $1 ? $1 : $scheme eq 'http' ? 80 : $scheme eq 'https' ? 443 : undef;return ($scheme,(length$host ? lc$host : "localhost"),$port,$path_query,$auth)}my$DoW="Sun|Mon|Tue|Wed|Thu|Fri|Sat";my$MoY="Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec";sub _http_date {my ($sec,$min,$hour,$mday,$mon,$year,$wday)=gmtime($_[1]);return sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",substr($DoW,$wday*4,3),$mday,substr($MoY,$mon*4,3),$year+1900,$hour,$min,$sec)}sub _parse_http_date {my ($self,$str)=@_;require Time::Local;my@tl_parts;if ($str =~ /^[SMTWF][a-z]+, +(\d{1,2}) ($MoY) +(\d\d\d\d) +(\d\d):(\d\d):(\d\d) +GMT$/){@tl_parts=($6,$5,$4,$1,(index($MoY,$2)/4),$3)}elsif ($str =~ /^[SMTWF][a-z]+, +(\d\d)-($MoY)-(\d{2,4}) +(\d\d):(\d\d):(\d\d) +GMT$/){@tl_parts=($6,$5,$4,$1,(index($MoY,$2)/4),$3)}elsif ($str =~ /^[SMTWF][a-z]+ +($MoY) +(\d{1,2}) +(\d\d):(\d\d):(\d\d) +(?:[^0-9]+ +)?(\d\d\d\d)$/){@tl_parts=($5,$4,$3,$2,(index($MoY,$1)/4),$6)}return eval {my$t=@tl_parts ? Time::Local::timegm(@tl_parts): -1;$t < 0 ? undef : $t}}my%escapes=map {chr($_)=>sprintf("%%%02X",$_)}0..255;$escapes{' '}="+";my$unsafe_char=qr/[^A-Za-z0-9\-\._~]/;sub _uri_escape {my ($self,$str)=@_;return "" if!defined$str;if ($] ge '5.008'){utf8::encode($str)}else {$str=pack("U*",unpack("C*",$str))if (length$str==do {use bytes;length$str});$str=pack("C*",unpack("C*",$str))}$str =~ s/($unsafe_char)/$escapes{$1}/g;return$str}package HTTP::Tiny::Handle;use strict;use warnings;use Errno qw[EINTR EPIPE];use IO::Socket qw[SOCK_STREAM];use Socket qw[SOL_SOCKET SO_KEEPALIVE];my$SOCKET_CLASS=$ENV{PERL_HTTP_TINY_IPV4_ONLY}? 'IO::Socket::INET' : eval {require IO::Socket::IP;IO::Socket::IP->VERSION(0.32)}? 'IO::Socket::IP' : 'IO::Socket::INET';sub BUFSIZE () {32768}my$Printable=sub {local $_=shift;s/\r/\\r/g;s/\n/\\n/g;s/\t/\\t/g;s/([^\x20-\x7E])/sprintf('\\x%.2X', ord($1))/ge;$_};my$Token=qr/[\x21\x23-\x27\x2A\x2B\x2D\x2E\x30-\x39\x41-\x5A\x5E-\x7A\x7C\x7E]/;my$Field_Content=qr/[[:print:]]+ (?: [\x20\x09]+ [[:print:]]+ )*/x;sub new {my ($class,%args)=@_;return bless {rbuf=>'',timeout=>60,max_line_size=>16384,max_header_lines=>64,verify_SSL=>0,SSL_options=>{},%args },$class}sub timeout {my ($self,$timeout)=@_;if (@_ > 1){$self->{timeout}=$timeout;if ($self->{fh}&& $self->{fh}->can('timeout')){$self->{fh}->timeout($timeout)}}return$self->{timeout}}sub connect {@_==5 || die(q/Usage: $handle->connect(scheme, host, port, peer)/ ."\n");my ($self,$scheme,$host,$port,$peer)=@_;if ($scheme eq 'https'){$self->_assert_ssl}$self->{fh}=$SOCKET_CLASS->new(PeerHost=>$peer,PeerPort=>$port,$self->{local_address}? (LocalAddr=>$self->{local_address}): (),Proto=>'tcp',Type=>SOCK_STREAM,Timeout=>$self->{timeout},)or die(qq/Could not connect to '$host:$port': $@\n/);binmode($self->{fh})or die(qq/Could not binmode() socket: '$!'\n/);if ($self->{keep_alive}){unless (defined($self->{fh}->setsockopt(SOL_SOCKET,SO_KEEPALIVE,1))){CORE::close($self->{fh});die(qq/Could not set SO_KEEPALIVE on socket: '$!'\n/)}}$self->start_ssl($host)if$scheme eq 'https';$self->{scheme}=$scheme;$self->{host}=$host;$self->{peer}=$peer;$self->{port}=$port;$self->{pid}=$$;$self->{tid}=_get_tid();return$self}sub connected {my ($self)=@_;if ($self->{fh}&& $self->{fh}->connected){return wantarray ? ($self->{fh}->peerhost,$self->{fh}->peerport): join(':',$self->{fh}->peerhost,$self->{fh}->peerport)}return}sub start_ssl {my ($self,$host)=@_;if (ref($self->{fh})eq 'IO::Socket::SSL'){unless ($self->{fh}->stop_SSL){my$ssl_err=IO::Socket::SSL->errstr;die(qq/Error halting prior SSL connection: $ssl_err/)}}my$ssl_args=$self->_ssl_args($host);IO::Socket::SSL->start_SSL($self->{fh},%$ssl_args,SSL_create_ctx_callback=>sub {my$ctx=shift;Net::SSLeay::CTX_set_mode($ctx,Net::SSLeay::MODE_AUTO_RETRY())},);unless (ref($self->{fh})eq 'IO::Socket::SSL'){my$ssl_err=IO::Socket::SSL->errstr;die(qq/SSL connection failed for $host: $ssl_err\n/)}}sub close {@_==1 || die(q/Usage: $handle->close()/ ."\n");my ($self)=@_;CORE::close($self->{fh})or die(qq/Could not close socket: '$!'\n/)}sub write {@_==2 || die(q/Usage: $handle->write(buf)/ ."\n");my ($self,$buf)=@_;if ($] ge '5.008'){utf8::downgrade($buf,1)or die(qq/Wide character in write()\n/)}my$len=length$buf;my$off=0;local$SIG{PIPE}='IGNORE';while (){$self->can_write or die(qq/Timed out while waiting for socket to become ready for writing\n/);my$r=syswrite($self->{fh},$buf,$len,$off);if (defined$r){$len -= $r;$off += $r;last unless$len > 0}elsif ($!==EPIPE){die(qq/Socket closed by remote server: $!\n/)}elsif ($!!=EINTR){if ($self->{fh}->can('errstr')){my$err=$self->{fh}->errstr();die (qq/Could not write to SSL socket: '$err'\n /)}else {die(qq/Could not write to socket: '$!'\n/)}}}return$off}sub read {@_==2 || @_==3 || die(q/Usage: $handle->read(len [, allow_partial])/ ."\n");my ($self,$len,$allow_partial)=@_;my$buf='';my$got=length$self->{rbuf};if ($got){my$take=($got < $len)? $got : $len;$buf=substr($self->{rbuf},0,$take,'');$len -= $take}local$SIG{PIPE}='IGNORE';while ($len > 0){$self->can_read or die(q/Timed out while waiting for socket to become ready for reading/ ."\n");my$r=sysread($self->{fh},$buf,$len,length$buf);if (defined$r){last unless$r;$len -= $r}elsif ($!!=EINTR){if ($self->{fh}->can('errstr')){my$err=$self->{fh}->errstr();die (qq/Could not read from SSL socket: '$err'\n /)}else {die(qq/Could not read from socket: '$!'\n/)}}}if ($len &&!$allow_partial){die(qq/Unexpected end of stream\n/)}return$buf}sub readline {@_==1 || die(q/Usage: $handle->readline()/ ."\n");my ($self)=@_;while (){if ($self->{rbuf}=~ s/\A ([^\x0D\x0A]* \x0D?\x0A)//x){return $1}if (length$self->{rbuf}>= $self->{max_line_size}){die(qq/Line size exceeds the maximum allowed size of $self->{max_line_size}\n/)}$self->can_read or die(qq/Timed out while waiting for socket to become ready for reading\n/);my$r=sysread($self->{fh},$self->{rbuf},BUFSIZE,length$self->{rbuf});if (defined$r){last unless$r}elsif ($!!=EINTR){if ($self->{fh}->can('errstr')){my$err=$self->{fh}->errstr();die (qq/Could not read from SSL socket: '$err'\n /)}else {die(qq/Could not read from socket: '$!'\n/)}}}die(qq/Unexpected end of stream while looking for line\n/)}sub read_header_lines {@_==1 || @_==2 || die(q/Usage: $handle->read_header_lines([headers])/ ."\n");my ($self,$headers)=@_;$headers ||= {};my$lines=0;my$val;while (){my$line=$self->readline;if (++$lines >= $self->{max_header_lines}){die(qq/Header lines exceeds maximum number allowed of $self->{max_header_lines}\n/)}elsif ($line =~ /\A ([^\x00-\x1F\x7F:]+) : [\x09\x20]* ([^\x0D\x0A]*)/x){my ($field_name)=lc $1;if (exists$headers->{$field_name}){for ($headers->{$field_name}){$_=[$_]unless ref $_ eq "ARRAY";push @$_,$2;$val=\$_->[-1]}}else {$val=\($headers->{$field_name}=$2)}}elsif ($line =~ /\A [\x09\x20]+ ([^\x0D\x0A]*)/x){$val or die(qq/Unexpected header continuation line\n/);next unless length $1;$$val .= ' ' if length $$val;$$val .= $1}elsif ($line =~ /\A \x0D?\x0A \z/x){last}else {die(q/Malformed header line: / .$Printable->($line)."\n")}}return$headers}sub write_request {@_==2 || die(q/Usage: $handle->write_request(request)/ ."\n");my($self,$request)=@_;$self->write_request_header(@{$request}{qw/method uri headers header_case/});$self->write_body($request)if$request->{cb};return}my@rfc_request_headers=qw(Accept Accept-Charset Accept-Encoding Accept-Language Authorization Cache-Control Connection Content-Length Expect From Host If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since Max-Forwards Pragma Proxy-Authorization Range Referer TE Trailer Transfer-Encoding Upgrade User-Agent Via);my@other_request_headers=qw(Content-Encoding Content-MD5 Content-Type Cookie DNT Date Origin X-XSS-Protection);my%HeaderCase=map {lc($_)=>$_}@rfc_request_headers,@other_request_headers;sub write_header_lines {(@_ >= 2 && @_ <= 4 && ref $_[1]eq 'HASH')|| die(q/Usage: $handle->write_header_lines(headers, [header_case, prefix])/ ."\n");my($self,$headers,$header_case,$prefix_data)=@_;$header_case ||= {};my$buf=(defined$prefix_data ? $prefix_data : '');my%seen;for my$k (qw/host cache-control expect max-forwards pragma range te/){next unless exists$headers->{$k};$seen{$k}++;my$field_name=$HeaderCase{$k};my$v=$headers->{$k};for (ref$v eq 'ARRAY' ? @$v : $v){$_='' unless defined $_;$buf .= "$field_name: $_\x0D\x0A"}}while (my ($k,$v)=each %$headers){my$field_name=lc$k;next if$seen{$field_name};if (exists$HeaderCase{$field_name}){$field_name=$HeaderCase{$field_name}}else {if (exists$header_case->{$field_name}){$field_name=$header_case->{$field_name}}else {$field_name =~ s/\b(\w)/\u$1/g}$field_name =~ /\A $Token+ \z/xo or die(q/Invalid HTTP header field name: / .$Printable->($field_name)."\n");$HeaderCase{lc$field_name}=$field_name}for (ref$v eq 'ARRAY' ? @$v : $v){s/\x0D?\x0A\s+/ /g;die(qq/Invalid HTTP header field value ($field_name): / .$Printable->($_)."\n")unless $_ eq '' || /\A $Field_Content \z/xo;$_='' unless defined $_;$buf .= "$field_name: $_\x0D\x0A"}}$buf .= "\x0D\x0A";return$self->write($buf)}sub read_body {@_==3 || die(q/Usage: $handle->read_body(callback, response)/ ."\n");my ($self,$cb,$response)=@_;my$te=$response->{headers}{'transfer-encoding'}|| '';my$chunked=grep {/chunked/i}(ref$te eq 'ARRAY' ? @$te : $te);return$chunked ? $self->read_chunked_body($cb,$response): $self->read_content_body($cb,$response)}sub write_body {@_==2 || die(q/Usage: $handle->write_body(request)/ ."\n");my ($self,$request)=@_;if (exists$request->{headers}{'content-length'}){return unless$request->{headers}{'content-length'};return$self->write_content_body($request)}else {return$self->write_chunked_body($request)}}sub read_content_body {@_==3 || @_==4 || die(q/Usage: $handle->read_content_body(callback, response, [read_length])/ ."\n");my ($self,$cb,$response,$content_length)=@_;$content_length ||= $response->{headers}{'content-length'};if (defined$content_length){my$len=$content_length;while ($len > 0){my$read=($len > BUFSIZE)? BUFSIZE : $len;$cb->($self->read($read,0),$response);$len -= $read}return length($self->{rbuf})==0}my$chunk;$cb->($chunk,$response)while length($chunk=$self->read(BUFSIZE,1));return}sub write_content_body {@_==2 || die(q/Usage: $handle->write_content_body(request)/ ."\n");my ($self,$request)=@_;my ($len,$content_length)=(0,$request->{headers}{'content-length'});while (){my$data=$request->{cb}->();defined$data && length$data or last;if ($] ge '5.008'){utf8::downgrade($data,1)or die(qq/Wide character in write_content()\n/)}$len += $self->write($data)}$len==$content_length or die(qq/Content-Length mismatch (got: $len expected: $content_length)\n/);return$len}sub read_chunked_body {@_==3 || die(q/Usage: $handle->read_chunked_body(callback, $response)/ ."\n");my ($self,$cb,$response)=@_;while (){my$head=$self->readline;$head =~ /\A ([A-Fa-f0-9]+)/x or die(q/Malformed chunk head: / .$Printable->($head)."\n");my$len=hex($1)or last;$self->read_content_body($cb,$response,$len);$self->read(2)eq "\x0D\x0A" or die(qq/Malformed chunk: missing CRLF after chunk data\n/)}$self->read_header_lines($response->{headers});return 1}sub write_chunked_body {@_==2 || die(q/Usage: $handle->write_chunked_body(request)/ ."\n");my ($self,$request)=@_;my$len=0;while (){my$data=$request->{cb}->();defined$data && length$data or last;if ($] ge '5.008'){utf8::downgrade($data,1)or die(qq/Wide character in write_chunked_body()\n/)}$len += length$data;my$chunk=sprintf '%X',length$data;$chunk .= "\x0D\x0A";$chunk .= $data;$chunk .= "\x0D\x0A";$self->write($chunk)}$self->write("0\x0D\x0A");if (ref$request->{trailer_cb}eq 'CODE'){$self->write_header_lines($request->{trailer_cb}->())}else {$self->write("\x0D\x0A")}return$len}sub read_response_header {@_==1 || die(q/Usage: $handle->read_response_header()/ ."\n");my ($self)=@_;my$line=$self->readline;$line =~ /\A (HTTP\/(0*\d+\.0*\d+)) [\x09\x20]+ ([0-9]{3}) (?: [\x09\x20]+ ([^\x0D\x0A]*) )? \x0D?\x0A/x or die(q/Malformed Status-Line: / .$Printable->($line)."\n");my ($protocol,$version,$status,$reason)=($1,$2,$3,$4);$reason="" unless defined$reason;die (qq/Unsupported HTTP protocol: $protocol\n/)unless$version =~ /0*1\.0*[01]/;return {status=>$status,reason=>$reason,headers=>$self->read_header_lines,protocol=>$protocol,}}sub write_request_header {@_==5 || die(q/Usage: $handle->write_request_header(method, request_uri, headers, header_case)/ ."\n");my ($self,$method,$request_uri,$headers,$header_case)=@_;return$self->write_header_lines($headers,$header_case,"$method $request_uri HTTP/1.1\x0D\x0A")}sub _do_timeout {my ($self,$type,$timeout)=@_;$timeout=$self->{timeout}unless defined$timeout && $timeout >= 0;my$fd=fileno$self->{fh};defined$fd && $fd >= 0 or die(qq/select(2): 'Bad file descriptor'\n/);my$initial=time;my$pending=$timeout;my$nfound;vec(my$fdset='',$fd,1)=1;while (){$nfound=($type eq 'read')? select($fdset,undef,undef,$pending): select(undef,$fdset,undef,$pending);if ($nfound==-1){$!==EINTR or die(qq/select(2): '$!'\n/);redo if!$timeout || ($pending=$timeout - (time - $initial))> 0;$nfound=0}last}$!=0;return$nfound}sub can_read {@_==1 || @_==2 || die(q/Usage: $handle->can_read([timeout])/ ."\n");my$self=shift;if (ref($self->{fh})eq 'IO::Socket::SSL'){return 1 if$self->{fh}->pending}return$self->_do_timeout('read',@_)}sub can_write {@_==1 || @_==2 || die(q/Usage: $handle->can_write([timeout])/ ."\n");my$self=shift;return$self->_do_timeout('write',@_)}sub _assert_ssl {my($ok,$reason)=HTTP::Tiny->can_ssl();die$reason unless$ok}sub can_reuse {my ($self,$scheme,$host,$port,$peer)=@_;return 0 if $self->{pid}!=$$ || $self->{tid}!=_get_tid()|| length($self->{rbuf})|| $scheme ne $self->{scheme}|| $host ne $self->{host}|| $port ne $self->{port}|| $peer ne $self->{peer}|| eval {$self->can_read(0)}|| $@ ;return 1}sub _find_CA_file {my$self=shift();my$ca_file=defined($self->{SSL_options}->{SSL_ca_file})? $self->{SSL_options}->{SSL_ca_file}: $ENV{SSL_CERT_FILE};if (defined$ca_file){unless (-r $ca_file){die qq/SSL_ca_file '$ca_file' not found or not readable\n/}return$ca_file}local@INC=@INC;pop@INC if$INC[-1]eq '.';return Mozilla::CA::SSL_ca_file()if eval {require Mozilla::CA;1};for my$ca_bundle ("/etc/ssl/certs/ca-certificates.crt","/etc/pki/tls/certs/ca-bundle.crt","/etc/ssl/ca-bundle.pem","/etc/openssl/certs/ca-certificates.crt","/etc/ssl/cert.pem","/usr/local/share/certs/ca-root-nss.crt","/etc/pki/tls/cacert.pem","/etc/certs/ca-certificates.crt",){return$ca_bundle if -e $ca_bundle}die qq/Couldn't find a CA bundle with which to verify the SSL certificate.\n/ .qq/Try installing Mozilla::CA from CPAN\n/}sub _get_tid {no warnings 'reserved';return threads->can("tid")? threads->tid : 0}sub _ssl_args {my ($self,$host)=@_;my%ssl_args;if (Net::SSLeay::OPENSSL_VERSION_NUMBER()>= 0x01000000){$ssl_args{SSL_hostname}=$host,}if ($self->{verify_SSL}){$ssl_args{SSL_verifycn_scheme}='http';$ssl_args{SSL_verifycn_name}=$host;$ssl_args{SSL_verify_mode}=0x01;$ssl_args{SSL_ca_file}=$self->_find_CA_file}else {$ssl_args{SSL_verifycn_scheme}='none';$ssl_args{SSL_verify_mode}=0x00}for my$k (keys %{$self->{SSL_options}}){$ssl_args{$k}=$self->{SSL_options}{$k}if$k =~ m/^SSL_/}return \%ssl_args}1;
      sub $sub_name {
          my (\$self, \$url, \$args) = \@_;
          \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
          or _croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
          return \$self->request('$req_method', \$url, \$args || {});
      }
  HERE
HTTP_TINY

$fatpacked{"HTTP/Tinyish.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH';
  package HTTP::Tinyish;use strict;use warnings;use Carp ();our$VERSION='0.17';our$PreferredBackend;our@Backends=map "HTTP::Tinyish::$_",qw(LWP HTTPTiny Curl Wget);my%configured;sub new {my($class,%attr)=@_;bless \%attr,$class}for my$method (qw/get head put post delete mirror patch/){no strict 'refs';eval <<"HERE"}sub request {my$self=shift;$self->_backend_for($_[1])->request(@_)}sub _backend_for {my($self,$url)=@_;my($scheme)=$url =~ m!^(https?):!;Carp::croak "URL Scheme '$url' not supported." unless$scheme;for my$backend ($self->backends){$self->configure_backend($backend)or next;if ($backend->supports($scheme)){return$backend->new(%$self)}}Carp::croak "No backend configured for scheme $scheme"}sub backends {$PreferredBackend ? ($PreferredBackend): @Backends}sub configure_backend {my($self,$backend)=@_;unless (exists$configured{$backend}){$configured{$backend}=eval {require_module($backend);$backend->configure}}$configured{$backend}}sub require_module {local $_=shift;s!::!/!g;require "$_.pm"}1;
      sub $method {
          my \$self = shift;
          \$self->_backend_for(\$_[0])->$method(\@_);
      }
  HERE
HTTP_TINYISH

$fatpacked{"HTTP/Tinyish/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_BASE';
  package HTTP::Tinyish::Base;use strict;use warnings;for my$sub_name (qw/get head put post delete patch/){my$req_method=uc$sub_name;eval <<"HERE"}sub parse_http_header {my($self,$header,$res)=@_;$header =~ s/.*^(HTTP\/\d(?:\.\d)?)/$1/ms;if ($header =~ /^(.*?\x0d?\x0a\x0d?\x0a)/){$header=$1}my@header=split /\x0d?\x0a/,$header;my$status_line=shift@header;my@out;for (@header){if(/^[ \t]+/){return -1 unless@out;$out[-1].= $_}else {push@out,$_}}my($proto,$status,$reason)=split / /,$status_line,3;return unless$proto and $proto =~ /^HTTP\/(\d+)(\.(\d+))?$/i;$res->{status}=$status;$res->{reason}=$reason;$res->{success}=$status =~ /^(?:2|304)/;$res->{protocol}=$proto;my$token=qr/[^][\x00-\x1f\x7f()<>@,;:\\"\/?={} \t]+/;my$k;for my$header (@out){if ($header =~ s/^($token): ?//){$k=lc $1}elsif ($header =~ /^\s+/){}else {return -1}if (exists$res->{headers}{$k}){$res->{headers}{$k}=[$res->{headers}{$k}]unless ref$res->{headers}{$k};push @{$res->{headers}{$k}},$header}else {$res->{headers}{$k}=$header}}}sub internal_error {my($self,$url,$message)=@_;return {content=>$message,headers=>{"content-length"=>length($message),"content-type"=>"text/plain" },reason=>"Internal Exception",status=>599,success=>"",url=>$url,}}1;
      sub $sub_name {
          my (\$self, \$url, \$args) = \@_;
          \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
          or Carp::croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
          return \$self->request('$req_method', \$url, \$args || {});
      }
  
  HERE
HTTP_TINYISH_BASE

$fatpacked{"HTTP/Tinyish/Curl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_CURL';
  package HTTP::Tinyish::Curl;use strict;use warnings;use parent qw(HTTP::Tinyish::Base);use IPC::Run3 qw(run3);use File::Which qw(which);use File::Temp ();my%supports;my$curl;sub _slurp {open my$fh,"<",shift or die $!;local $/;<$fh>}sub configure {my$class=shift;my%meta;$curl=which('curl');eval {run3([$curl,'--version'],\undef,\my$version,\my$error);if ($version =~ /^Protocols: (.*)/m){my%protocols=map {$_=>1}split /\s/,$1;$supports{http}=1 if$protocols{http};$supports{https}=1 if$protocols{https}}$meta{$curl}=$version};\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attr)=@_;bless \%attr,$class}sub request {my($self,$method,$url,$opts)=@_;$opts ||= {};my(undef,$temp)=File::Temp::tempfile(UNLINK=>1);my($output,$error);eval {run3 [$curl,'-X',$method,($method eq 'HEAD' ? ('--head'): ()),$self->build_options($url,$opts),'--dump-header',$temp,$url,],\undef,\$output,\$error};if ($@ or $?){return$self->internal_error($url,$@ || $error)}my$res={url=>$url,content=>$output };$self->parse_http_header(_slurp($temp),$res);$res}sub mirror {my($self,$url,$file,$opts)=@_;$opts ||= {};my(undef,$temp)=File::Temp::tempfile(UNLINK=>1);my($output,$error);eval {run3 [$curl,$self->build_options($url,$opts),'-z',$file,'-o',$file,'--dump-header',$temp,'--remote-time',$url,],\undef,\$output,\$error};if ($@ or $?){return$self->internal_error($url,$@ || $error)}my$res={url=>$url,content=>$output };$self->parse_http_header(_slurp($temp),$res);$res}sub build_options {my($self,$url,$opts)=@_;my@options=('--location','--silent','--show-error','--max-time',($self->{timeout}|| 60),'--max-redirs',($self->{max_redirect}|| 5),'--user-agent',($self->{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION"),);my%headers;if ($self->{default_headers}){%headers=%{$self->{default_headers}}}if ($opts->{headers}){%headers=(%headers,%{$opts->{headers}})}$self->_translate_headers(\%headers,\@options);unless ($self->{verify_SSL}){push@options,'--insecure'}if ($opts->{content}){my$content;if (ref$opts->{content}eq 'CODE'){while (my$chunk=$opts->{content}->()){$content .= $chunk}}else {$content=$opts->{content}}push@options,'--data',$content}@options}sub _translate_headers {my($self,$headers,$options)=@_;for my$field (keys %$headers){my$value=$headers->{$field};if (ref$value eq 'ARRAY'){push @$options,map {('-H',"$field:$_")}@$value}else {push @$options,'-H',"$field:$value"}}}1;
HTTP_TINYISH_CURL

$fatpacked{"HTTP/Tinyish/HTTPTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_HTTPTINY';
  package HTTP::Tinyish::HTTPTiny;use strict;use parent qw(HTTP::Tinyish::Base);use HTTP::Tiny;my%supports=(http=>1);sub configure {my%meta=("HTTP::Tiny"=>$HTTP::Tiny::VERSION);$supports{https}=HTTP::Tiny->can_ssl;\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attrs)=@_;bless {tiny=>HTTP::Tiny->new(%attrs),},$class}sub request {my$self=shift;$self->{tiny}->request(@_)}sub mirror {my$self=shift;$self->{tiny}->mirror(@_)}1;
HTTP_TINYISH_HTTPTINY

$fatpacked{"HTTP/Tinyish/LWP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_LWP';
  package HTTP::Tinyish::LWP;use strict;use parent qw(HTTP::Tinyish::Base);use LWP 5.802;use LWP::UserAgent;my%supports=(http=>1);sub configure {my%meta=(LWP=>$LWP::VERSION,);if (eval {require LWP::Protocol::https;require Mozilla::CA;1}){$supports{https}=1;$meta{"LWP::Protocol::https"}=$LWP::Protocol::https::VERSION}\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attr)=@_;my$ua=LWP::UserAgent->new;bless {ua=>$class->translate_lwp($ua,%attr),},$class}sub _headers_to_hashref {my($self,$hdrs)=@_;my%headers;for my$field ($hdrs->header_field_names){$headers{lc$field}=$hdrs->header($field)}\%headers}sub request {my($self,$method,$url,$opts)=@_;$opts ||= {};my$req=HTTP::Request->new($method=>$url);if ($opts->{headers}){$req->header(%{$opts->{headers}})}if ($opts->{content}){$req->content($opts->{content})}my$res=$self->{ua}->request($req);if ($self->is_internal_response($res)){return$self->internal_error($url,$res->content)}return {url=>$url,content=>$res->decoded_content(charset=>'none'),success=>$res->is_success,status=>$res->code,reason=>$res->message,headers=>$self->_headers_to_hashref($res->headers),protocol=>$res->protocol,}}sub mirror {my($self,$url,$file)=@_;my$res=$self->{ua}->mirror($url,$file);if ($self->is_internal_response($res)){return$self->internal_error($url,$res->content)}return {url=>$url,content=>$res->decoded_content,success=>$res->is_success || $res->code==304,status=>$res->code,reason=>$res->message,headers=>$self->_headers_to_hashref($res->headers),protocol=>$res->protocol,}}sub translate_lwp {my($class,$agent,%attr)=@_;$agent->parse_head(0);$agent->env_proxy;$agent->timeout(delete$attr{timeout}|| 60);$agent->max_redirect(delete$attr{max_redirect}|| 5);$agent->agent(delete$attr{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION");unless ($attr{verify_SSL}){if ($agent->can("ssl_opts")){$agent->ssl_opts(verify_hostname=>0)}}if ($attr{default_headers}){$agent->default_headers(HTTP::Headers->new(%{$attr{default_headers}}))}$agent}sub is_internal_response {my($self,$res)=@_;$res->code==500 && ($res->header('Client-Warning')|| '')eq 'Internal response'}1;
HTTP_TINYISH_LWP

$fatpacked{"HTTP/Tinyish/Wget.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_WGET';
  package HTTP::Tinyish::Wget;use strict;use warnings;use parent qw(HTTP::Tinyish::Base);use IPC::Run3 qw(run3);use File::Which qw(which);my%supports;my$wget;my$method_supported;sub _run_wget {run3([$wget,@_],\undef,\my$out,\my$err);wantarray ? ($out,$err): $out}sub configure {my$class=shift;my%meta;$wget=which('wget');eval {local$ENV{LC_ALL}='en_US';$meta{$wget}=_run_wget('--version');unless ($meta{$wget}=~ /GNU Wget 1\.(\d+)/ and $1 >= 12){die "Wget version is too old. $meta{$wget}"}my$config=$class->new(agent=>__PACKAGE__);my@options=grep {$_ ne '--quiet'}$config->build_options("GET");my(undef,$err)=_run_wget(@options,'https://');if ($err && $err =~ /HTTPS support not compiled/){$supports{http}=1}elsif ($err && $err =~ /Invalid host/){$supports{http}=$supports{https}=1}(undef,$err)=_run_wget('--method','GET','http://');if ($err && $err =~ /Invalid host/){$method_supported=$meta{method_supported}=1}};\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attr)=@_;bless \%attr,$class}sub request {my($self,$method,$url,$opts)=@_;$opts ||= {};my($stdout,$stderr);eval {run3 [$wget,$self->build_options($method,$url,$opts),$url,'-O','-',],\undef,\$stdout,\$stderr};if ($@ or $? && ($? >> 8)<= 5){return$self->internal_error($url,$@ || $stderr)}my$header='';$stderr =~ s{^  (\S.*)$}{ $header .= $1."\n" }gem;my$res={url=>$url,content=>$stdout };$self->parse_http_header($header,$res);$res}sub mirror {my($self,$url,$file,$opts)=@_;$opts ||= {};my($stdout,$stderr);eval {run3 [$wget,$self->build_options("GET",$url,$opts),$url,'-O',$file],\undef,\$stdout,\$stderr};if ($@ or $?){return$self->internal_error($url,$@ || $stderr)}$stderr =~ s/^  //gm;my$res={url=>$url,content=>$stdout };$self->parse_http_header($stderr,$res);$res}sub build_options {my($self,$method,$url,$opts)=@_;my@options=('--retry-connrefused','--server-response','--timeout',($self->{timeout}|| 60),'--tries',1,'--max-redirect',($self->{max_redirect}|| 5),'--user-agent',($self->{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION"),);if ($method_supported){push@options,"--method",$method}else {if ($method eq 'GET' or $method eq 'POST'){}elsif ($method eq 'HEAD'){push@options,'--spider'}else {die "This version of wget doesn't support specifying HTTP method '$method'"}}if ($self->{agent}){push@options,'--user-agent',$self->{agent}}my%headers;if ($self->{default_headers}){%headers=%{$self->{default_headers}}}if ($opts->{headers}){%headers=(%headers,%{$opts->{headers}})}$self->_translate_headers(\%headers,\@options);if ($supports{https}&&!$self->{verify_SSL}){push@options,'--no-check-certificate'}if ($opts->{content}){my$content;if (ref$opts->{content}eq 'CODE'){while (my$chunk=$opts->{content}->()){$content .= $chunk}}else {$content=$opts->{content}}if ($method_supported){push@options,'--body-data',$content}else {push@options,'--post-data',$content}}@options}sub _translate_headers {my($self,$headers,$options)=@_;for my$field (keys %$headers){my$value=$headers->{$field};if (ref$value eq 'ARRAY'){push @$options,'--header',"$field:" .join(",",@$value)}else {push @$options,'--header',"$field:$value"}}}1;
HTTP_TINYISH_WGET

$fatpacked{"IPC/Run3.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3';
  package IPC::Run3;BEGIN {require 5.006_000}use strict;our$VERSION='0.048';use Exporter;our@ISA=qw(Exporter);our@EXPORT=qw(run3);our%EXPORT_TAGS=(all=>\@EXPORT);use constant debugging=>$ENV{IPCRUN3DEBUG}|| $ENV{IPCRUNDEBUG}|| 0;use constant profiling=>$ENV{IPCRUN3PROFILE}|| $ENV{IPCRUNPROFILE}|| 0;use constant is_win32=>0 <= index $^O,"Win32";BEGIN {if (is_win32){eval "use Win32 qw( GetOSName ); use Win32::ShellQuote qw(quote_native); 1" or die $@}}use Carp qw(croak);use File::Temp qw(tempfile);use POSIX qw(dup dup2);my%fh_cache;my$fh_cache_pid=$$;my$profiler;sub _profiler {$profiler}BEGIN {if (profiling){eval "use Time::HiRes qw( gettimeofday ); 1" or die $@;if ($ENV{IPCRUN3PROFILE}=~ /\A\d+\z/){require IPC::Run3::ProfPP;IPC::Run3::ProfPP->import;$profiler=IPC::Run3::ProfPP->new(Level=>$ENV{IPCRUN3PROFILE})}else {my ($dest,undef,$class)=reverse split /(=)/,$ENV{IPCRUN3PROFILE},2;$class="IPC::Run3::ProfLogger" unless defined$class && length$class;if (not eval "require $class"){my$e=$@;$class="IPC::Run3::$class";eval "require IPC::Run3::$class" or die$e}$profiler=$class->new(Destination=>$dest)}$profiler->app_call([$0,@ARGV ],scalar gettimeofday())}}END {$profiler->app_exit(scalar gettimeofday())if profiling}sub _binmode {my ($fh,$mode,$what)=@_;my$layer=!$mode ? (is_win32 ? ":crlf" : ":raw"): ($mode =~ /^:/ ? $mode : ":raw");warn "binmode $what, $layer\n" if debugging >= 2;binmode$fh,":raw" unless$layer eq ":raw";binmode$fh,$layer or croak "binmode $layer failed: $!"}sub _spool_data_to_child {my ($type,$source,$binmode_it)=@_;return undef unless defined$source;my$fh;if (!$type){open$fh,"<",$source or croak "$!: $source";_binmode($fh,$binmode_it,"STDIN");warn "run3(): feeding file '$source' to child STDIN\n" if debugging >= 2}elsif ($type eq "FH"){$fh=$source;warn "run3(): feeding filehandle '$source' to child STDIN\n" if debugging >= 2}else {$fh=$fh_cache{in}||= tempfile;truncate$fh,0;seek$fh,0,0;_binmode($fh,$binmode_it,"STDIN");my$seekit;if ($type eq "SCALAR"){return$fh unless defined $$source;warn "run3(): feeding SCALAR to child STDIN",debugging >= 3 ? (": '",$$source,"' (",length $$source," chars)"): (),"\n" if debugging >= 2;$seekit=length $$source;print$fh $$source or die "$! writing to temp file"}elsif ($type eq "ARRAY"){warn "run3(): feeding ARRAY to child STDIN",debugging >= 3 ? (": '",@$source,"'"): (),"\n" if debugging >= 2;print$fh @$source or die "$! writing to temp file";$seekit=grep length,@$source}elsif ($type eq "CODE"){warn "run3(): feeding output of CODE ref '$source' to child STDIN\n" if debugging >= 2;my$parms=[];while (1){my$data=$source->(@$parms);last unless defined$data;print$fh $data or die "$! writing to temp file";$seekit=length$data}}seek$fh,0,0 or croak "$! seeking on temp file for child's stdin" if$seekit}croak "run3() can't redirect $type to child stdin" unless defined$fh;return$fh}sub _fh_for_child_output {my ($what,$type,$dest,$options)=@_;my$fh;if ($type eq "SCALAR" && $dest==\undef){warn "run3(): redirecting child $what to oblivion\n" if debugging >= 2;$fh=$fh_cache{nul}||= do {open$fh,">",File::Spec->devnull;$fh}}elsif ($type eq "FH"){$fh=$dest;warn "run3(): redirecting $what to filehandle '$dest'\n" if debugging >= 3}elsif (!$type){warn "run3(): feeding child $what to file '$dest'\n" if debugging >= 2;open$fh,$options->{"append_$what"}? ">>" : ">",$dest or croak "$!: $dest"}else {warn "run3(): capturing child $what\n" if debugging >= 2;$fh=$fh_cache{$what}||= tempfile;seek$fh,0,0;truncate$fh,0}my$binmode_it=$options->{"binmode_$what"};_binmode($fh,$binmode_it,uc$what);return$fh}sub _read_child_output_fh {my ($what,$type,$dest,$fh,$options)=@_;return if$type eq "SCALAR" && $dest==\undef;seek$fh,0,0 or croak "$! seeking on temp file for child $what";if ($type eq "SCALAR"){warn "run3(): reading child $what to SCALAR\n" if debugging >= 3;my$count=read$fh,$$dest,10_000,$options->{"append_$what"}? length $$dest : 0;while (1){croak "$! reading child $what from temp file" unless defined$count;last unless$count;warn "run3(): read $count bytes from child $what",debugging >= 3 ? (": '",substr($$dest,-$count),"'"): (),"\n" if debugging >= 2;$count=read$fh,$$dest,10_000,length $$dest}}elsif ($type eq "ARRAY"){if ($options->{"append_$what"}){push @$dest,<$fh>}else {@$dest=<$fh>}if (debugging >= 2){my$count=0;$count += length for @$dest;warn "run3(): read ",scalar @$dest," records, $count bytes from child $what",debugging >= 3 ? (": '",@$dest,"'"): (),"\n"}}elsif ($type eq "CODE"){warn "run3(): capturing child $what to CODE ref\n" if debugging >= 3;local $_;while (<$fh>){warn "run3(): read ",length," bytes from child $what",debugging >= 3 ? (": '",$_,"'"): (),"\n" if debugging >= 2;$dest->($_)}}else {croak "run3() can't redirect child $what to a $type"}}sub _type {my ($redir)=@_;return "FH" if eval {local$SIG{'__DIE__'};$redir->isa("IO::Handle")};my$type=ref$redir;return$type eq "GLOB" ? "FH" : $type}sub _max_fd {my$fd=dup(0);POSIX::close$fd;return$fd}my$run_call_time;my$sys_call_time;my$sys_exit_time;sub run3 {$run_call_time=gettimeofday()if profiling;my$options=@_ && ref $_[-1]eq "HASH" ? pop : {};my ($cmd,$stdin,$stdout,$stderr)=@_;print STDERR "run3(): running ",join(" ",map "'$_'",ref$cmd ? @$cmd : $cmd),"\n" if debugging;if (ref$cmd){croak "run3(): empty command" unless @$cmd;croak "run3(): undefined command" unless defined$cmd->[0];croak "run3(): command name ('')" unless length$cmd->[0]}else {croak "run3(): missing command" unless @_;croak "run3(): undefined command" unless defined$cmd;croak "run3(): command ('')" unless length$cmd}for (qw/binmode_stdin binmode_stdout binmode_stderr/){if (my$mode=$options->{$_}){croak qq[option $_ must be a number or a proper layer string: "$mode"] unless$mode =~ /^(:|\d+$)/}}my$in_type=_type$stdin;my$out_type=_type$stdout;my$err_type=_type$stderr;if ($fh_cache_pid!=$$){close $_ foreach values%fh_cache;%fh_cache=();$fh_cache_pid=$$}my$in_fh=_spool_data_to_child$in_type,$stdin,$options->{binmode_stdin}if defined$stdin;my$out_fh=_fh_for_child_output "stdout",$out_type,$stdout,$options if defined$stdout;my$tie_err_to_out=defined$stderr && defined$stdout && $stderr eq $stdout;my$err_fh=$tie_err_to_out ? $out_fh : _fh_for_child_output "stderr",$err_type,$stderr,$options if defined$stderr;local*STDOUT_SAVE;local*STDERR_SAVE;my$saved_fd0=dup(0)if defined$in_fh;open STDOUT_SAVE,">&STDOUT" or croak "run3(): $! saving STDOUT" if defined$out_fh;open STDERR_SAVE,">&STDERR" or croak "run3(): $! saving STDERR" if defined$err_fh;my$errno;my$ok=eval {dup2(fileno$in_fh,0)or croak "run3(): $! redirecting STDIN" if defined$in_fh;open STDOUT,">&" .fileno$out_fh or croak "run3(): $! redirecting STDOUT" if defined$out_fh;open STDERR,">&" .fileno$err_fh or croak "run3(): $! redirecting STDERR" if defined$err_fh;$sys_call_time=gettimeofday()if profiling;my$r=ref$cmd ? system {$cmd->[0]}is_win32 ? quote_native(@$cmd): @$cmd : system$cmd;$errno=$!;$sys_exit_time=gettimeofday()if profiling;if (debugging){my$err_fh=defined$err_fh ? \*STDERR_SAVE : \*STDERR;if (defined$r && $r!=-1){print$err_fh "run3(): \$? is $?\n"}else {print$err_fh "run3(): \$? is $?, \$! is $errno\n"}}if (defined$r && ($r==-1 || (is_win32 && $r==0xFF00))&&!$options->{return_if_system_error}){croak($errno)}1};my$x=$@;my@errs;if (defined$saved_fd0){dup2($saved_fd0,0);POSIX::close($saved_fd0)}open STDOUT,">&STDOUT_SAVE" or push@errs,"run3(): $! restoring STDOUT" if defined$out_fh;open STDERR,">&STDERR_SAVE" or push@errs,"run3(): $! restoring STDERR" if defined$err_fh;croak join ", ",@errs if@errs;die$x unless$ok;_read_child_output_fh "stdout",$out_type,$stdout,$out_fh,$options if defined$out_fh && $out_type && $out_type ne "FH";_read_child_output_fh "stderr",$err_type,$stderr,$err_fh,$options if defined$err_fh && $err_type && $err_type ne "FH" &&!$tie_err_to_out;$profiler->run_exit($cmd,$run_call_time,$sys_call_time,$sys_exit_time,scalar gettimeofday())if profiling;$!=$errno;return 1}1;
IPC_RUN3

$fatpacked{"IPC/Run3/ProfArrayBuffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFARRAYBUFFER';
  package IPC::Run3::ProfArrayBuffer;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Events}=[];return$self}for my$subname (qw(app_call app_exit run_exit)){no strict 'refs';*{$subname}=sub {push @{shift->{Events}},[$subname=>@_ ]}}sub get_events {my$self=shift;@{$self->{Events}}}1;
IPC_RUN3_PROFARRAYBUFFER

$fatpacked{"IPC/Run3/ProfLogReader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFLOGREADER';
  package IPC::Run3::ProfLogReader;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Source}="run3.out" unless defined$self->{Source}&& length$self->{Source};my$source=$self->{Source};if (ref$source eq "GLOB" || UNIVERSAL::isa($source,"IO::Handle")){$self->{FH}=$source}elsif ($source eq "-"){$self->{FH}=\*STDIN}else {open PROFILE,"<$self->{Source}" or die "$!: $self->{Source}\n";$self->{FH}=*PROFILE{IO}}return$self}sub set_handler {$_[0]->{Handler}=$_[1]}sub get_handler {$_[0]->{Handler}}sub read {my$self=shift;my$fh=$self->{FH};my@ln=split / /,<$fh>;return 0 unless@ln;return 1 unless$self->{Handler};chomp$ln[-1];return 1 if@ln==1 &&!length$ln[0]|| 0==index$ln[0],"#";if ($ln[0]eq "\\app_call"){shift@ln;my@times=split /,/,pop@ln;$self->{Handler}->app_call([map {s/\\\\/\\/g;s/\\_/ /g;$_}@ln ],@times)}elsif ($ln[0]eq "\\app_exit"){shift@ln;$self->{Handler}->app_exit(pop@ln,@ln)}else {my@times=split /,/,pop@ln;$self->{Handler}->run_exit([map {s/\\\\/\\/g;s/\\_/ /g;$_}@ln ],@times)}return 1}sub read_all {my$self=shift;1 while$self->read;return 1}1;
IPC_RUN3_PROFLOGREADER

$fatpacked{"IPC/Run3/ProfLogger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFLOGGER';
  package IPC::Run3::ProfLogger;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Destination}="run3.out" unless defined$self->{Destination}&& length$self->{Destination};open PROFILE,">$self->{Destination}" or die "$!: $self->{Destination}\n";binmode PROFILE;$self->{FH}=*PROFILE{IO};$self->{times}=[];return$self}sub run_exit {my$self=shift;my$fh=$self->{FH};print($fh join(" ",(map {my$s=$_;$s =~ s/\\/\\\\/g;$s =~ s/ /_/g;$s}@{shift()}),join(",",@{$self->{times}},@_,),),"\n")}sub app_exit {my$self=shift;my$fh=$self->{FH};print$fh "\\app_exit ",shift,"\n"}sub app_call {my$self=shift;my$fh=$self->{FH};my$t=shift;print($fh join(" ","\\app_call",(map {my$s=$_;$s =~ s/\\\\/\\/g;$s =~ s/ /\\_/g;$s}@_),$t,),"\n")}1;
IPC_RUN3_PROFLOGGER

$fatpacked{"IPC/Run3/ProfPP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFPP';
  package IPC::Run3::ProfPP;$VERSION=0.048;require IPC::Run3::ProfReporter;@ISA=qw(IPC::Run3::ProfReporter);use strict;use POSIX qw(floor);sub _emit {shift;warn @_}sub _t {sprintf "%10.6f secs",@_}sub _r {my ($num,$denom)=@_;return ()unless$denom;sprintf "%10.6f",$num / $denom}sub _pct {my ($num,$denom)=@_;return ()unless$denom;sprintf " (%3d%%)",floor(100 * $num / $denom + 0.5)}sub handle_app_call {my$self=shift;$self->_emit("IPC::Run3 parent: ",join(" ",@{$self->get_app_cmd}),"\n",);$self->{NeedNL}=1}sub handle_app_exit {my$self=shift;$self->_emit("\n")if$self->{NeedNL}&& $self->{NeedNL}!=1;$self->_emit("IPC::Run3 total elapsed:             ",_t($self->get_app_cumulative_time),"\n");$self->_emit("IPC::Run3 calls to run3():    ",sprintf("%10d",$self->get_run_count),"\n");$self->_emit("IPC::Run3 total spent in run3():     ",_t($self->get_run_cumulative_time),_pct($self->get_run_cumulative_time,$self->get_app_cumulative_time),", ",_r($self->get_run_cumulative_time,$self->get_run_count)," per call","\n");my$exclusive=$self->get_app_cumulative_time - $self->get_run_cumulative_time;$self->_emit("IPC::Run3 total spent not in run3(): ",_t($exclusive),_pct($exclusive,$self->get_app_cumulative_time),"\n");$self->_emit("IPC::Run3 total spent in children:   ",_t($self->get_sys_cumulative_time),_pct($self->get_sys_cumulative_time,$self->get_app_cumulative_time),", ",_r($self->get_sys_cumulative_time,$self->get_run_count)," per call","\n");my$overhead=$self->get_run_cumulative_time - $self->get_sys_cumulative_time;$self->_emit("IPC::Run3 total overhead:            ",_t($overhead),_pct($overhead,$self->get_sys_cumulative_time),", ",_r($overhead,$self->get_run_count)," per call","\n")}sub handle_run_exit {my$self=shift;my$overhead=$self->get_run_time - $self->get_sys_time;$self->_emit("\n")if$self->{NeedNL}&& $self->{NeedNL}!=2;$self->{NeedNL}=3;$self->_emit("IPC::Run3 child: ",join(" ",@{$self->get_run_cmd}),"\n");$self->_emit("IPC::Run3 run3()  : ",_t($self->get_run_time),"\n","IPC::Run3 child   : ",_t($self->get_sys_time),"\n","IPC::Run3 overhead: ",_t($overhead),_pct($overhead,$self->get_sys_time),"\n")}1;
IPC_RUN3_PROFPP

$fatpacked{"IPC/Run3/ProfReporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFREPORTER';
  package IPC::Run3::ProfReporter;$VERSION=0.048;use strict;my$loaded_by;sub import {$loaded_by=shift}END {my@caller;for (my$i=0;;++$i ){my@c=caller$i;last unless@c;@caller=@c}if ($caller[0]eq "main" && $caller[1]eq "-e"){require IPC::Run3::ProfLogReader;require Getopt::Long;my ($app,$run);Getopt::Long::GetOptions("app"=>\$app,"run"=>\$run,);$app=1,$run=1 unless$app || $run;for (@ARGV ? @ARGV : ""){my$r=IPC::Run3::ProfLogReader->new(Source=>$_,Handler=>$loaded_by->new(Source=>$_,app_report=>$app,run_report=>$run,),);$r->read_all}}}sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{app_report}=1,$self->{run_report}=1 unless$self->{app_report}|| $self->{run_report};return$self}sub handle_app_call {}sub handle_app_exit {}sub handle_run_exit {}sub app_call {my$self=shift;($self->{app_cmd},$self->{app_call_time})=@_;$self->handle_app_call if$self->{app_report}}sub app_exit {my$self=shift;$self->{app_exit_time}=shift;$self->handle_app_exit if$self->{app_report}}sub run_exit {my$self=shift;@{$self}{qw(run_cmd run_call_time sys_call_time sys_exit_time run_exit_time)}=@_;++$self->{run_count};$self->{run_cumulative_time}+= $self->get_run_time;$self->{sys_cumulative_time}+= $self->get_sys_time;$self->handle_run_exit if$self->{run_report}}sub get_run_count {shift->{run_count}}sub get_app_call_time {shift->{app_call_time}}sub get_app_exit_time {shift->{app_exit_time}}sub get_app_cmd {shift->{app_cmd}}sub get_app_time {my$self=shift;$self->get_app_exit_time - $self->get_app_call_time}sub get_app_cumulative_time {my$self=shift;$self->get_app_exit_time - $self->get_app_call_time}sub get_run_call_time {shift->{run_call_time}}sub get_run_exit_time {shift->{run_exit_time}}sub get_run_time {my$self=shift;$self->get_run_exit_time - $self->get_run_call_time}sub get_run_cumulative_time {shift->{run_cumulative_time}}sub get_sys_call_time {shift->{sys_call_time}}sub get_sys_exit_time {shift->{sys_exit_time}}sub get_sys_time {my$self=shift;$self->get_sys_exit_time - $self->get_sys_call_time}sub get_sys_cumulative_time {shift->{sys_cumulative_time}}sub get_run_cmd {shift->{run_cmd}}1;
IPC_RUN3_PROFREPORTER

$fatpacked{"Module/Load.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_LOAD';
  package Module::Load;use strict;use warnings;use File::Spec ();our$VERSION='0.36';sub import {my$who=_who();my$h;shift;{no strict 'refs';@_ or (*{"${who}::load"}=\&load,*{"${who}::autoload"}=\&autoload,return);map {$h->{$_}=()if defined $_}@_;(exists$h->{none}or exists$h->{''})and shift,last;((exists$h->{autoload}and shift,1)or (exists$h->{all}and shift))and *{"${who}::autoload"}=\&autoload;((exists$h->{load}and shift,1)or exists$h->{all})and *{"${who}::load"}=\&load;((exists$h->{load_remote}and shift,1)or exists$h->{all})and *{"${who}::load_remote"}=\&load_remote;((exists$h->{autoload_remote}and shift,1)or exists$h->{all})and *{"${who}::autoload_remote"}=\&autoload_remote}}sub load(*;@){goto&_load}sub autoload(*;@){unshift @_,'autoimport';goto&_load}sub load_remote($$;@){my ($dst,$src,@exp)=@_;eval "package $dst;Module::Load::load('$src', qw/@exp/);";$@ && die "$@"}sub autoload_remote($$;@){my ($dst,$src,@exp)=@_;eval "package $dst;Module::Load::autoload('$src', qw/@exp/);";$@ && die "$@"}sub _load{my$autoimport=$_[0]eq 'autoimport' and shift;my$mod=shift or return;my$who=_who();if(_is_file($mod)){require$mod}else {LOAD: {my$err;for my$flag (qw[1 0]){my$file=_to_file($mod,$flag);eval {require$file};$@ ? $err .= $@ : last LOAD}die$err if$err}}{no strict 'refs';my$import;((@_ or $autoimport)and ($import=$mod->can('import'))and (unshift(@_,$mod),goto &$import))}}sub _to_file{local $_=shift;my$pm=shift || '';my@parts=split /::|'/,$_,-1;shift@parts if@parts &&!$parts[0];my$file=$^O eq 'MSWin32' ? join "/",@parts : File::Spec->catfile(@parts);$file .= '.pm' if$pm;$file=VMS::Filespec::unixify($file)if $^O eq 'VMS';return$file}sub _who {(caller(1))[0]}sub _is_file {local $_=shift;return /^\./ ? 1 : /[^\w:']/ ? 1 : undef}1;
MODULE_LOAD

$fatpacked{"YAML/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP';
  use strict;use warnings;package YAML::PP;our$VERSION='0.030';use YAML::PP::Schema;use YAML::PP::Schema::JSON;use YAML::PP::Loader;use YAML::PP::Dumper;use Scalar::Util qw/blessed/;use Carp qw/croak/;use base 'Exporter';our@EXPORT_OK=qw/Load LoadFile Dump DumpFile/;my%YAML_VERSIONS=('1.1'=>1,'1.2'=>1);sub new {my ($class,%args)=@_;my$bool=delete$args{boolean};$bool='perl' unless defined$bool;my$schemas=delete$args{schema}|| ['+'];my$cyclic_refs=delete$args{cyclic_refs}|| 'allow';my$indent=delete$args{indent};my$width=delete$args{width};my$writer=delete$args{writer};my$header=delete$args{header};my$footer=delete$args{footer};my$duplicate_keys=delete$args{duplicate_keys};my$yaml_version=$class->_arg_yaml_version(delete$args{yaml_version});my$default_yaml_version=$yaml_version->[0];my$version_directive=delete$args{version_directive};my$preserve=delete$args{preserve};my$parser=delete$args{parser};my$emitter=delete$args{emitter}|| {indent=>$indent,width=>$width,writer=>$writer,};if (keys%args){die "Unexpected arguments: " .join ', ',sort keys%args}my%schemas;for my$v (@$yaml_version){my$schema;if (blessed($schemas)and $schemas->isa('YAML::PP::Schema')){$schema=$schemas}else {$schema=YAML::PP::Schema->new(boolean=>$bool,yaml_version=>$v,);$schema->load_subschemas(@$schemas)}$schemas{$v }=$schema}my$default_schema=$schemas{$default_yaml_version };my$loader=YAML::PP::Loader->new(schemas=>\%schemas,cyclic_refs=>$cyclic_refs,parser=>$parser,default_yaml_version=>$default_yaml_version,preserve=>$preserve,duplicate_keys=>$duplicate_keys,);my$dumper=YAML::PP::Dumper->new(schema=>$default_schema,emitter=>$emitter,header=>$header,footer=>$footer,version_directive=>$version_directive,preserve=>$preserve,);my$self=bless {schema=>\%schemas,loader=>$loader,dumper=>$dumper,},$class;return$self}sub clone {my ($self)=@_;my$clone={schema=>$self->schema,loader=>$self->loader->clone,dumper=>$self->dumper->clone,};return bless$clone,ref$self}sub _arg_yaml_version {my ($class,$version)=@_;my@versions=('1.2');if (defined$version){@versions=();if (not ref$version){$version=[$version]}for my$v (@$version){unless ($YAML_VERSIONS{$v }){croak "YAML Version '$v' not supported"}push@versions,$v}}return \@versions}sub loader {if (@_ > 1){$_[0]->{loader}=$_[1]}return $_[0]->{loader}}sub dumper {if (@_ > 1){$_[0]->{dumper}=$_[1]}return $_[0]->{dumper}}sub schema {if (@_ > 1){$_[0]->{schema}->{'1.2'}=$_[1]}return $_[0]->{schema}->{'1.2'}}sub default_schema {my ($self,%args)=@_;my$schema=YAML::PP::Schema->new(boolean=>$args{boolean},);$schema->load_subschemas(qw/Core/);return$schema}sub load_string {my ($self,$yaml)=@_;return$self->loader->load_string($yaml)}sub load_file {my ($self,$file)=@_;return$self->loader->load_file($file)}sub dump {my ($self,@data)=@_;return$self->dumper->dump(@data)}sub dump_string {my ($self,@data)=@_;return$self->dumper->dump_string(@data)}sub dump_file {my ($self,$file,@data)=@_;return$self->dumper->dump_file($file,@data)}sub Load {my ($yaml)=@_;YAML::PP->new->load_string($yaml)}sub LoadFile {my ($file)=@_;YAML::PP->new->load_file($file)}sub Dump {my (@data)=@_;YAML::PP->new->dump_string(@data)}sub DumpFile {my ($file,@data)=@_;YAML::PP->new->dump_file($file,@data)}sub preserved_scalar {my ($self,$value,%args)=@_;my$scalar=YAML::PP::Preserve::Scalar->new(value=>$value,%args,);return$scalar}sub preserved_mapping {my ($self,$hash,%args)=@_;my$data={};tie %$data,'YAML::PP::Preserve::Hash';%$data=%$hash;my$t=tied %$data;$t->{style}=$args{style};$t->{alias}=$args{alias};return$data}sub preserved_sequence {my ($self,$array,%args)=@_;my$data=[];tie @$data,'YAML::PP::Preserve::Array';push @$data,@$array;my$t=tied @$data;$t->{style}=$args{style};$t->{alias}=$args{alias};return$data}package YAML::PP::Preserve::Hash;use Tie::Hash;use base qw/Tie::StdHash/;use Scalar::Util qw/reftype blessed/;sub TIEHASH {my ($class,%args)=@_;my$self=bless {keys=>[keys%args],data=>{%args },},$class}sub STORE {my ($self,$key,$val)=@_;my$keys=$self->{keys};unless (exists$self->{data}->{$key }){push @$keys,$key}if (ref$val and not blessed($val)){if (reftype($val)eq 'HASH' and not tied %$val){tie %$val,'YAML::PP::Preserve::Hash',%$val}elsif (reftype($val)eq 'ARRAY' and not tied @$val){tie @$val,'YAML::PP::Preserve::Array',@$val}}$self->{data}->{$key }=$val}sub FIRSTKEY {my ($self)=@_;return$self->{keys}->[0]}sub NEXTKEY {my ($self,$last)=@_;my$keys=$self->{keys};for my$i (0 .. $#$keys){if ("$keys->[ $i ]" eq "$last"){return$keys->[$i + 1 ]}}return}sub FETCH {my ($self,$key)=@_;my$val=$self->{data}->{$key }}sub DELETE {my ($self,$key)=@_;@{$self->{keys}}=grep {"$_" ne "$key"}@{$self->{keys}};delete$self->{data}->{$key }}sub EXISTS {my ($self,$key)=@_;return exists$self->{data}->{$key }}sub CLEAR {my ($self)=@_;$self->{keys}=[];$self->{data}={}}sub SCALAR {my ($self)=@_;return scalar %{$self->{data}}}package YAML::PP::Preserve::Array;use Tie::Array;use base qw/Tie::StdArray/;use Scalar::Util qw/reftype blessed/;sub TIEARRAY {my ($class,@items)=@_;my$self=bless {data=>[@items],},$class;return$self}sub FETCH {my ($self,$i)=@_;return$self->{data}->[$i ]}sub FETCHSIZE {my ($self)=@_;return $#{$self->{data}}+ 1}sub _preserve {my ($val)=@_;if (ref$val and not blessed($val)){if (reftype($val)eq 'HASH' and not tied %$val){tie %$val,'YAML::PP::Preserve::Hash',%$val}elsif (reftype($val)eq 'ARRAY' and not tied @$val){tie @$val,'YAML::PP::Preserve::Array',@$val}}return$val}sub STORE {my ($self,$i,$val)=@_;_preserve($val);$self->{data}->[$i ]=$val}sub PUSH {my ($self,@args)=@_;push @{$self->{data}},map {_preserve $_}@args}sub STORESIZE {my ($self,$i)=@_;$#{$self->{data}}=$i - 1}sub DELETE {my ($self,$i)=@_;delete$self->{data}->[$i ]}sub EXISTS {my ($self,$i)=@_;return exists$self->{data}->[$i ]}sub CLEAR {my ($self)=@_;$self->{data}=[]}sub SHIFT {my ($self)=@_;shift @{$self->{data}}}sub UNSHIFT {my ($self,@args)=@_;unshift @{$self->{data}},map {_preserve $_}@args}sub SPLICE {my ($self,$offset,$length,@args)=@_;splice @{$self->{data}},$offset,$length,map {_preserve $_}@args}sub EXTEND {}package YAML::PP::Preserve::Scalar;use overload fallback=>1,'+'=>\&value,'""'=>\&value,'bool'=>\&value,;sub new {my ($class,%args)=@_;my$self={%args,};bless$self,$class}sub value {$_[0]->{value}}sub tag {$_[0]->{tag}}sub style {$_[0]->{style}|| 0}sub alias {$_[0]->{alias}}1;
YAML_PP

$fatpacked{"YAML/PP/Common.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_COMMON';
  use strict;use warnings;package YAML::PP::Common;our$VERSION='0.030';use base 'Exporter';our@EXPORT_OK=qw/YAML_ANY_SCALAR_STYLE YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE YAML_DOUBLE_QUOTED_SCALAR_STYLE YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE YAML_QUOTED_SCALAR_STYLE YAML_ANY_SEQUENCE_STYLE YAML_BLOCK_SEQUENCE_STYLE YAML_FLOW_SEQUENCE_STYLE YAML_ANY_MAPPING_STYLE YAML_BLOCK_MAPPING_STYLE YAML_FLOW_MAPPING_STYLE PRESERVE_ALL PRESERVE_ORDER PRESERVE_SCALAR_STYLE PRESERVE_FLOW_STYLE PRESERVE_ALIAS/;use constant {YAML_ANY_SCALAR_STYLE=>0,YAML_PLAIN_SCALAR_STYLE=>1,YAML_SINGLE_QUOTED_SCALAR_STYLE=>2,YAML_DOUBLE_QUOTED_SCALAR_STYLE=>3,YAML_LITERAL_SCALAR_STYLE=>4,YAML_FOLDED_SCALAR_STYLE=>5,YAML_QUOTED_SCALAR_STYLE=>'Q',YAML_ANY_SEQUENCE_STYLE=>0,YAML_BLOCK_SEQUENCE_STYLE=>1,YAML_FLOW_SEQUENCE_STYLE=>2,YAML_ANY_MAPPING_STYLE=>0,YAML_BLOCK_MAPPING_STYLE=>1,YAML_FLOW_MAPPING_STYLE=>2,PRESERVE_ORDER=>2,PRESERVE_SCALAR_STYLE=>4,PRESERVE_FLOW_STYLE=>8,PRESERVE_ALIAS=>16,PRESERVE_ALL=>31,};my%scalar_style_to_string=(YAML_PLAIN_SCALAR_STYLE()=>':',YAML_SINGLE_QUOTED_SCALAR_STYLE()=>"'",YAML_DOUBLE_QUOTED_SCALAR_STYLE()=>'"',YAML_LITERAL_SCALAR_STYLE()=>'|',YAML_FOLDED_SCALAR_STYLE()=>'>',);sub event_to_test_suite {my ($event,$args)=@_;my$ev=$event->{name};my$string;my$content=$event->{value};my$properties='';$properties .= " &$event->{anchor}" if defined$event->{anchor};$properties .= " <$event->{tag}>" if defined$event->{tag};if ($ev eq 'document_start_event'){$string="+DOC";$string .= " ---" unless$event->{implicit}}elsif ($ev eq 'document_end_event'){$string="-DOC";$string .= " ..." unless$event->{implicit}}elsif ($ev eq 'stream_start_event'){$string="+STR"}elsif ($ev eq 'stream_end_event'){$string="-STR"}elsif ($ev eq 'mapping_start_event'){$string="+MAP";if ($event->{style}and $event->{style}eq YAML_FLOW_MAPPING_STYLE){$string .= ' {}' if$args->{flow}}$string .= $properties;if (0){}}elsif ($ev eq 'sequence_start_event'){$string="+SEQ";if ($event->{style}and $event->{style}eq YAML_FLOW_SEQUENCE_STYLE){$string .= ' []' if$args->{flow}}$string .= $properties;if (0){}}elsif ($ev eq 'mapping_end_event'){$string="-MAP"}elsif ($ev eq 'sequence_end_event'){$string="-SEQ"}elsif ($ev eq 'scalar_event'){$string='=VAL';$string .= $properties;$content =~ s/\\/\\\\/g;$content =~ s/\t/\\t/g;$content =~ s/\r/\\r/g;$content =~ s/\n/\\n/g;$content =~ s/[\b]/\\b/g;$string .= ' ' .$scalar_style_to_string{$event->{style}}.$content}elsif ($ev eq 'alias_event'){$string="=ALI *$content"}return$string}sub test_suite_to_event {my ($str)=@_;my$event={};if ($str =~ s/^\+STR//){$event->{name}='stream_start_event'}elsif ($str =~ s/^\-STR//){$event->{name}='stream_end_event'}elsif ($str =~ s/^\+DOC//){$event->{name}='document_start_event';if ($str =~ s/^ ---//){$event->{implicit}=0}else {$event->{implicit}=1}}elsif ($str =~ s/^\-DOC//){$event->{name}='document_end_event';if ($str =~ s/^ \.\.\.//){$event->{implicit}=0}else {$event->{implicit}=1}}elsif ($str =~ s/^\+SEQ//){$event->{name}='sequence_start_event';if ($str =~ s/^ \&(\S+)//){$event->{anchor}=$1}if ($str =~ s/^ <(\S+)>//){$event->{tag}=$1}}elsif ($str =~ s/^\-SEQ//){$event->{name}='sequence_end_event'}elsif ($str =~ s/^\+MAP//){$event->{name}='mapping_start_event';if ($str =~ s/^ \&(\S+)//){$event->{anchor}=$1}if ($str =~ s/^ <(\S+)>//){$event->{tag}=$1}}elsif ($str =~ s/^\-MAP//){$event->{name}='mapping_end_event'}elsif ($str =~ s/^=VAL//){$event->{name}='scalar_event';if ($str =~ s/^ <(\S+)>//){$event->{tag}=$1}if ($str =~ s/^ [:'">|]//){$event->{style}=$1}if ($str =~ s/^(.*)//){$event->{value}=$1}}elsif ($str =~ s/^=ALI//){$event->{name}='alias_event';if ($str =~ s/^ \*(.*)//){$event->{value}=$1}}else {die "Could not parse event '$str'"}return$event}1;
YAML_PP_COMMON

$fatpacked{"YAML/PP/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_CONSTRUCTOR';
  use strict;use warnings;package YAML::PP::Constructor;our$VERSION='0.030';use YAML::PP;use YAML::PP::Common qw/PRESERVE_ORDER PRESERVE_SCALAR_STYLE PRESERVE_FLOW_STYLE PRESERVE_ALIAS/;use Scalar::Util qw/reftype/;use Carp qw/croak/;use constant DEBUG=>($ENV{YAML_PP_LOAD_DEBUG}or $ENV{YAML_PP_LOAD_TRACE})? 1 : 0;use constant TRACE=>$ENV{YAML_PP_LOAD_TRACE}? 1 : 0;my%cyclic_refs=qw/allow 1 ignore 1 warn 1 fatal 1/;sub new {my ($class,%args)=@_;my$default_yaml_version=delete$args{default_yaml_version};my$duplicate_keys=delete$args{duplicate_keys};unless (defined$duplicate_keys){$duplicate_keys=0}my$preserve=delete$args{preserve}|| 0;if ($preserve==1){$preserve=PRESERVE_ORDER | PRESERVE_SCALAR_STYLE | PRESERVE_FLOW_STYLE | PRESERVE_ALIAS}my$cyclic_refs=delete$args{cyclic_refs}|| 'allow';die "Invalid value for cyclic_refs: $cyclic_refs" unless$cyclic_refs{$cyclic_refs };my$schemas=delete$args{schemas};if (keys%args){die "Unexpected arguments: " .join ', ',sort keys%args}my$self=bless {default_yaml_version=>$default_yaml_version,schemas=>$schemas,cyclic_refs=>$cyclic_refs,preserve=>$preserve,duplicate_keys=>$duplicate_keys,},$class;$self->init;return$self}sub clone {my ($self)=@_;my$clone={schemas=>$self->{schemas},schema=>$self->{schema},default_yaml_version=>$self->{default_yaml_version},cyclic_refs=>$self->cyclic_refs,preserve=>$self->{preserve},};return bless$clone,ref$self}sub init {my ($self)=@_;$self->set_docs([]);$self->set_stack([]);$self->set_anchors({});$self->set_yaml_version($self->default_yaml_version);$self->set_schema($self->schemas->{$self->yaml_version })}sub docs {return $_[0]->{docs}}sub stack {return $_[0]->{stack}}sub anchors {return $_[0]->{anchors}}sub set_docs {$_[0]->{docs}=$_[1]}sub set_stack {$_[0]->{stack}=$_[1]}sub set_anchors {$_[0]->{anchors}=$_[1]}sub schemas {return $_[0]->{schemas}}sub schema {return $_[0]->{schema}}sub set_schema {$_[0]->{schema}=$_[1]}sub cyclic_refs {return $_[0]->{cyclic_refs}}sub set_cyclic_refs {$_[0]->{cyclic_refs}=$_[1]}sub yaml_version {return $_[0]->{yaml_version}}sub set_yaml_version {$_[0]->{yaml_version}=$_[1]}sub default_yaml_version {return $_[0]->{default_yaml_version}}sub preserve_order {return $_[0]->{preserve}& PRESERVE_ORDER}sub preserve_scalar_style {return $_[0]->{preserve}& PRESERVE_SCALAR_STYLE}sub preserve_flow_style {return $_[0]->{preserve}& PRESERVE_FLOW_STYLE}sub preserve_alias {return $_[0]->{preserve}& PRESERVE_ALIAS}sub duplicate_keys {return $_[0]->{duplicate_keys}}sub document_start_event {my ($self,$event)=@_;my$stack=$self->stack;if ($event->{version_directive}){my$version=$event->{version_directive};$version="$version->{major}.$version->{minor}";if ($self->{schemas}->{$version }){$self->set_yaml_version($version);$self->set_schema($self->schemas->{$version })}else {$self->set_yaml_version($self->default_yaml_version);$self->set_schema($self->schemas->{$self->default_yaml_version })}}my$ref=[];push @$stack,{type=>'document',ref=>$ref,data=>$ref,event=>$event }}sub document_end_event {my ($self,$event)=@_;my$stack=$self->stack;my$last=pop @$stack;$last->{type}eq 'document' or die "Expected mapping, but got $last->{type}";if (@$stack){die "Got unexpected end of document"}my$docs=$self->docs;push @$docs,$last->{ref}->[0];$self->set_anchors({});$self->set_stack([])}sub mapping_start_event {my ($self,$event)=@_;my ($data,$on_data)=$self->schema->create_mapping($self,$event);my$ref={type=>'mapping',ref=>[],data=>\$data,event=>$event,on_data=>$on_data,};my$stack=$self->stack;my$preserve_order=$self->preserve_order;my$preserve_style=$self->preserve_flow_style;my$preserve_alias=$self->preserve_alias;if (($preserve_order or $preserve_style or $preserve_alias)and not tied(%$data)){tie %$data,'YAML::PP::Preserve::Hash'}if ($preserve_style){my$t=tied %$data;$t->{style}=$event->{style}}push @$stack,$ref;if (defined(my$anchor=$event->{anchor})){if ($preserve_alias){my$t=tied %$data;unless (exists$self->anchors->{$anchor }){$t->{alias}=$anchor}}$self->anchors->{$anchor }={data=>$ref->{data}}}}sub mapping_end_event {my ($self,$event)=@_;my$stack=$self->stack;my$last=pop @$stack;my ($ref,$data)=@{$last}{qw/ref data/};$last->{type}eq 'mapping' or die "Expected mapping, but got $last->{type}";my@merge_keys;my@ref;for (my$i=0;$i < @$ref;$i += 2){my$key=$ref->[$i ];if (ref$key eq 'YAML::PP::Type::MergeKey'){my$merge=$ref->[$i + 1 ];if ((reftype($merge)|| '')eq 'HASH'){push@merge_keys,$merge}elsif ((reftype($merge)|| '')eq 'ARRAY'){for my$item (@$merge){if ((reftype($item)|| '')eq 'HASH'){push@merge_keys,$item}else {die "Expected hash for merge key"}}}else {die "Expected hash or array for merge key"}}else {push@ref,$key,$ref->[$i + 1 ]}}for my$merge (@merge_keys){for my$key (keys %$merge){unless (exists $$data->{$key }){$$data->{$key }=$merge->{$key }}}}my$on_data=$last->{on_data}|| sub {my ($self,$hash,$items)=@_;my%seen;for (my$i=0;$i < @$items;$i += 2){my ($key,$value)=@$items[$i,$i + 1 ];$key='' unless defined$key;if (ref$key){$key=$self->stringify_complex($key)}if ($seen{$key }++ and not $self->duplicate_keys){croak "Duplicate key '$key'"}$$hash->{$key }=$value}};$on_data->($self,$data,\@ref);push @{$stack->[-1]->{ref}},$$data;if (defined(my$anchor=$last->{event}->{anchor})){$self->anchors->{$anchor }->{finished}=1}return}sub sequence_start_event {my ($self,$event)=@_;my ($data,$on_data)=$self->schema->create_sequence($self,$event);my$ref={type=>'sequence',ref=>[],data=>\$data,event=>$event,on_data=>$on_data,};my$stack=$self->stack;my$preserve_style=$self->preserve_flow_style;my$preserve_alias=$self->preserve_alias;if ($preserve_style or $preserve_alias and not tied(@$data)){tie @$data,'YAML::PP::Preserve::Array',@$data;my$t=tied @$data;$t->{style}=$event->{style}}push @$stack,$ref;if (defined(my$anchor=$event->{anchor})){if ($preserve_alias){my$t=tied @$data;unless (exists$self->anchors->{$anchor }){$t->{alias}=$anchor}}$self->anchors->{$anchor }={data=>$ref->{data}}}}sub sequence_end_event {my ($self,$event)=@_;my$stack=$self->stack;my$last=pop @$stack;$last->{type}eq 'sequence' or die "Expected mapping, but got $last->{type}";my ($ref,$data)=@{$last}{qw/ref data/};my$on_data=$last->{on_data}|| sub {my ($self,$array,$items)=@_;push @$$array,@$items};$on_data->($self,$data,$ref);push @{$stack->[-1]->{ref}},$$data;if (defined(my$anchor=$last->{event}->{anchor})){my$test=$self->anchors->{$anchor };$self->anchors->{$anchor }->{finished}=1}return}sub stream_start_event {}sub stream_end_event {}sub scalar_event {my ($self,$event)=@_;DEBUG and warn "CONTENT $event->{value} ($event->{style})\n";my$value=$self->schema->load_scalar($self,$event);my$last=$self->stack->[-1];my$preserve_alias=$self->preserve_alias;my$preserve_style=$self->preserve_scalar_style;if (($preserve_style or $preserve_alias)and not ref$value){my%args=(value=>$value,tag=>$event->{tag},);if ($preserve_style){$args{style}=$event->{style}}if ($preserve_alias and defined$event->{anchor}){my$anchor=$event->{anchor};unless (exists$self->anchors->{$anchor }){$args{alias}=$event->{anchor}}}$value=YAML::PP::Preserve::Scalar->new(%args)}if (defined (my$name=$event->{anchor})){$self->anchors->{$name }={data=>\$value,finished=>1 }}push @{$last->{ref}},$value}sub alias_event {my ($self,$event)=@_;my$value;my$name=$event->{value};if (my$anchor=$self->anchors->{$name }){unless ($anchor->{finished}){my$cyclic_refs=$self->cyclic_refs;if ($cyclic_refs ne 'allow'){if ($cyclic_refs eq 'fatal'){die "Found cyclic ref for alias '$name'"}if ($cyclic_refs eq 'warn'){$anchor={data=>\undef };warn "Found cyclic ref for alias '$name'"}elsif ($cyclic_refs eq 'ignore'){$anchor={data=>\undef }}}}$value=$anchor->{data}}else {croak "No anchor defined for alias '$name'"}my$last=$self->stack->[-1];push @{$last->{ref}},$$value}sub stringify_complex {my ($self,$data)=@_;return$data if (ref$data eq 'YAML::PP::Preserve::Scalar' and ($self->preserve_scalar_style or $self->preserve_alias));require Data::Dumper;local$Data::Dumper::Quotekeys=0;local$Data::Dumper::Terse=1;local$Data::Dumper::Indent=0;local$Data::Dumper::Useqq=0;local$Data::Dumper::Sortkeys=1;my$string=Data::Dumper->Dump([$data],['data']);$string =~ s/^\$data = //;return$string}1;
YAML_PP_CONSTRUCTOR

$fatpacked{"YAML/PP/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_DUMPER';
  use strict;use warnings;package YAML::PP::Dumper;our$VERSION='0.030';use Scalar::Util qw/blessed refaddr reftype/;use YAML::PP;use YAML::PP::Emitter;use YAML::PP::Representer;use YAML::PP::Writer;use YAML::PP::Writer::File;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE YAML_DOUBLE_QUOTED_SCALAR_STYLE YAML_ANY_SCALAR_STYLE YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE YAML_FLOW_SEQUENCE_STYLE YAML_FLOW_MAPPING_STYLE YAML_BLOCK_MAPPING_STYLE YAML_BLOCK_SEQUENCE_STYLE/;sub new {my ($class,%args)=@_;my$header=delete$args{header};$header=1 unless defined$header;my$footer=delete$args{footer};$footer=0 unless defined$footer;my$version_directive=delete$args{version_directive};my$preserve=delete$args{preserve};my$schema=delete$args{schema}|| YAML::PP->default_schema(boolean=>'perl',);my$emitter=delete$args{emitter}|| YAML::PP::Emitter->new;unless (blessed($emitter)){$emitter=YAML::PP::Emitter->new(%$emitter)}if (keys%args){die "Unexpected arguments: " .join ', ',sort keys%args}my$self=bless {representer=>YAML::PP::Representer->new(schema=>$schema,preserve=>$preserve,),version_directive=>$version_directive,emitter=>$emitter,seen=>{},anchors=>{},anchor_num=>0,header=>$header,footer=>$footer,},$class;return$self}sub clone {my ($self)=@_;my$clone={representer=>$self->representer->clone,emitter=>$self->emitter->clone,version_directive=>$self->version_directive,seen=>{},anchors=>{},anchor_num=>0,header=>$self->header,footer=>$self->footer,};return bless$clone,ref$self}sub init {my ($self)=@_;$self->{seen}={};$self->{anchors}={};$self->{anchor_num}=0}sub emitter {return $_[0]->{emitter}}sub representer {return $_[0]->{representer}}sub set_representer {$_[0]->{representer}=$_[1]}sub header {return $_[0]->{header}}sub footer {return $_[0]->{footer}}sub version_directive {return $_[0]->{version_directive}}sub dump {my ($self,@docs)=@_;$self->emitter->init;$self->emitter->stream_start_event({});for my$i (0 .. $#docs){my$header_implicit=($i==0 and not $self->header);my%args=(implicit=>$header_implicit,);if ($self->version_directive){my ($major,$minor)=split m/\./,$self->representer->schema->yaml_version;$args{version_directive}={major=>$major,minor=>$minor }}$self->emitter->document_start_event(\%args);$self->init;$self->check_references($docs[$i ]);$self->dump_node($docs[$i ]);my$footer_implicit=(not $self->footer);$self->emitter->document_end_event({implicit=>$footer_implicit })}$self->emitter->stream_end_event({});my$output=$self->emitter->writer->output;$self->emitter->finish;return$output}sub dump_node {my ($self,$value)=@_;my$node={value=>$value,};if (ref$value){my$seen=$self->{seen};my$refaddr=refaddr$value;if ($seen->{$refaddr }and $seen->{$refaddr }> 1){my$anchor=$self->{anchors}->{$refaddr };unless (defined$anchor){if ($self->representer->preserve_alias){if (ref$node->{value}eq 'YAML::PP::Preserve::Scalar'){if (defined$node->{value}->alias){$node->{anchor}=$node->{value}->alias;$self->{anchors}->{$refaddr }=$node->{value}->alias}}elsif (reftype$node->{value}eq 'HASH'){if (my$tied=tied %{$node->{value}}){if (defined$tied->{alias}){$node->{anchor}=$tied->{alias};$self->{anchors}->{$refaddr }=$node->{anchor}}}}elsif (reftype$node->{value}eq 'ARRAY'){if (my$tied=tied @{$node->{value}}){if (defined$tied->{alias}){$node->{anchor}=$tied->{alias};$self->{anchors}->{$refaddr }=$node->{anchor}}}}}unless (defined$node->{anchor}){my$num=++$self->{anchor_num};$self->{anchors}->{$refaddr }=$num;$node->{anchor}=$num}}else {$node->{value}=$anchor;$self->emit_node([alias=>$node ]);return}}}$node=$self->representer->represent_node($node);$self->emit_node($node)}sub emit_node {my ($self,$item)=@_;my ($type,$node,%args)=@$item;if ($type eq 'alias'){$self->emitter->alias_event({value=>$node->{value}});return}if ($type eq 'mapping'){my$style=$args{style}|| YAML_BLOCK_MAPPING_STYLE;if ($node->{items}and @{$node->{items}}==0){}$self->emitter->mapping_start_event({anchor=>$node->{anchor},style=>$style,tag=>$node->{tag},});for (@{$node->{items}}){$self->dump_node($_)}$self->emitter->mapping_end_event;return}if ($type eq 'sequence'){my$style=$args{style}|| YAML_BLOCK_SEQUENCE_STYLE;if (@{$node->{items}}==0){}$self->emitter->sequence_start_event({anchor=>$node->{anchor},style=>$style,tag=>$node->{tag},});for (@{$node->{items}}){$self->dump_node($_)}$self->emitter->sequence_end_event;return}$self->emitter->scalar_event({value=>$node->{items}->[0],style=>$node->{style},anchor=>$node->{anchor},tag=>$node->{tag},})}sub dump_string {my ($self,@docs)=@_;my$writer=YAML::PP::Writer->new;$self->emitter->set_writer($writer);my$output=$self->dump(@docs);return$output}sub dump_file {my ($self,$file,@docs)=@_;my$writer=YAML::PP::Writer::File->new(output=>$file);$self->emitter->set_writer($writer);my$output=$self->dump(@docs);return$output}my%_reftypes=(HASH=>1,ARRAY=>1,Regexp=>1,REGEXP=>1,CODE=>1,SCALAR=>1,REF=>1,GLOB=>1,);sub check_references {my ($self,$doc)=@_;my$reftype=reftype$doc or return;my$seen=$self->{seen};if ($reftype eq 'SCALAR' and ref$doc eq $self->representer->schema->bool_class){if (ref$doc eq 'boolean' or ref$doc eq 'JSON::PP::Boolean'){return}}if (++$seen->{refaddr$doc }> 1){return}unless ($_reftypes{$reftype }){die sprintf "Reference %s not implemented",$reftype}if ($reftype eq 'HASH'){$self->check_references($doc->{$_ })for keys %$doc}elsif ($reftype eq 'ARRAY'){$self->check_references($_)for @$doc}elsif ($reftype eq 'REF'){$self->check_references($$doc)}}1;
YAML_PP_DUMPER

$fatpacked{"YAML/PP/Emitter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_EMITTER';
  use strict;use warnings;package YAML::PP::Emitter;our$VERSION='0.030';use Data::Dumper;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE YAML_DOUBLE_QUOTED_SCALAR_STYLE YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE YAML_FLOW_SEQUENCE_STYLE YAML_FLOW_MAPPING_STYLE/;use constant DEBUG=>$ENV{YAML_PP_EMIT_DEBUG}? 1 : 0;use constant DEFAULT_WIDTH=>80;sub new {my ($class,%args)=@_;my$self=bless {indent=>$args{indent}|| 2,writer=>$args{writer},width=>$args{width}|| DEFAULT_WIDTH,},$class;$self->init;return$self}sub clone {my ($self)=@_;my$clone={indent=>$self->indent,};return bless$clone,ref$self}sub event_stack {return $_[0]->{event_stack}}sub set_event_stack {$_[0]->{event_stack}=$_[1]}sub indent {return $_[0]->{indent}}sub width {return $_[0]->{width}}sub line {return $_[0]->{line}}sub column {return $_[0]->{column}}sub set_indent {$_[0]->{indent}=$_[1]}sub writer {$_[0]->{writer}}sub set_writer {$_[0]->{writer}=$_[1]}sub tagmap {return $_[0]->{tagmap}}sub set_tagmap {$_[0]->{tagmap}=$_[1]}sub init {my ($self)=@_;unless ($self->writer){$self->set_writer(YAML::PP::Writer->new)}$self->set_tagmap({'tag:yaml.org,2002:'=>'!!',});$self->{open_ended}=0;$self->{line}=0;$self->{column}=0;$self->writer->init}sub mapping_start_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ mapping_start_event\n";my ($self,$info)=@_;my$stack=$self->event_stack;my$last=$stack->[-1];my$indent=$last->{indent};my$new_indent=$indent;my$yaml='';my$props='';my$anchor=$info->{anchor};my$tag=$info->{tag};if (defined$anchor){$anchor="&$anchor"}if (defined$tag){$tag=$self->emit_tag('map',$tag)}$props=join ' ',grep defined,($anchor,$tag);my$flow=$last->{flow}|| 0;$flow++ if ($info->{style}|| 0)eq YAML_FLOW_MAPPING_STYLE;my$newline=0;if ($flow > 1){if ($last->{type}eq 'SEQ'){if ($last->{newline}){$yaml .= ' '}if ($last->{index}==0){$yaml .= "["}else {$yaml .= ","}}elsif ($last->{type}eq 'MAP'){if ($last->{newline}){$yaml .= ' '}if ($last->{index}==0){$yaml .= "{"}else {$yaml .= ","}}elsif ($last->{type}eq 'MAPVALUE'){if ($last->{index}==0){die "Should not happen (index 0 in MAPVALUE)"}$yaml .= ": "}if ($props){$yaml .= " $props "}$new_indent .= ' ' x $self->indent}else {if ($last->{type}eq 'DOC'){$newline=$last->{newline}}else {if ($last->{newline}){$yaml .= "\n";$last->{column}=0}if ($last->{type}eq 'MAPVALUE'){$new_indent .= ' ' x $self->indent;$newline=1}else {$new_indent=$indent;if (not $props and $self->indent==1){$new_indent .= ' ' x 2}else {$new_indent .= ' ' x $self->indent}if ($last->{column}){my$space=$self->indent > 1 ? ' ' x ($self->indent - 1): ' ';$yaml .= $space}else {$yaml .= $indent}if ($last->{type}eq 'SEQ'){$yaml .= '-'}elsif ($last->{type}eq 'MAP'){$yaml .= "?";$last->{type}='COMPLEX'}elsif ($last->{type}eq 'COMPLEXVALUE'){$yaml .= ":"}else {die "Should not happen ($last->{type} in mapping_start)"}$last->{column}=1}$last->{newline}=0}if ($props){$yaml .= $last->{column}? ' ' : $indent;$yaml .= $props;$newline=1}}$self->_write($yaml);my$new_info={index=>0,indent=>$new_indent,info=>$info,newline=>$newline,column=>$self->column,flow=>$flow,};$new_info->{type}='MAP';push @{$stack},$new_info;$last->{index}++;$self->{open_ended}=0}sub mapping_end_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ mapping_end_event\n";my ($self,$info)=@_;my$stack=$self->event_stack;my$last=pop @{$stack};if ($last->{index}==0){my$indent=$last->{indent};my$zero_indent=$last->{zero_indent};if ($last->{zero_indent}){$indent .= ' ' x $self->indent}if ($self->column){$self->_write(" {}\n")}else {$self->_write("$indent\{}\n")}}elsif ($last->{flow}){my$yaml="}";if ($last->{flow}==1){$yaml .= "\n"}$self->_write("$yaml")}$last=$stack->[-1];$last->{column}=$self->column;if ($last->{type}eq 'SEQ'){}elsif ($last->{type}eq 'MAP'){$last->{type}='MAPVALUE'}elsif ($last->{type}eq 'MAPVALUE'){$last->{type}='MAP'}elsif ($last->{type}eq 'COMPLEX'){$last->{type}='COMPLEXVALUE'}elsif ($last->{type}eq 'COMPLEXVALUE'){$last->{type}='MAP'}}sub sequence_start_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ sequence_start_event\n";my ($self,$info)=@_;my$stack=$self->event_stack;my$last=$stack->[-1];my$indent=$last->{indent};my$new_indent=$indent;my$yaml='';my$props='';my$anchor=$info->{anchor};my$tag=$info->{tag};if (defined$anchor){$anchor="&$anchor"}if (defined$tag){$tag=$self->emit_tag('seq',$tag)}$props=join ' ',grep defined,($anchor,$tag);my$flow=$last->{flow}|| 0;$flow++ if$flow or ($info->{style}|| 0)eq YAML_FLOW_SEQUENCE_STYLE;my$newline=0;my$zero_indent=0;if ($flow > 1){if ($last->{type}eq 'SEQ'){if ($last->{newline}){$yaml .= ' '}if ($last->{index}==0){$yaml .= "["}else {$yaml .= ","}}elsif ($last->{type}eq 'MAP'){if ($last->{newline}){$yaml .= ' '}if ($last->{index}==0){$yaml .= "{"}else {$yaml .= ","}}elsif ($last->{type}eq 'MAPVALUE'){if ($last->{index}==0){die "Should not happen (index 0 in MAPVALUE)"}$yaml .= ": "}if ($props){$yaml .= " $props "}$new_indent .= ' ' x $self->indent}else {if ($last->{type}eq 'DOC'){$newline=$last->{newline}}else {if ($last->{newline}){$yaml .= "\n";$last->{column}=0}if ($last->{type}eq 'MAPVALUE'){$zero_indent=1;$newline=1}else {if (not $props and $self->indent==1){$new_indent .= ' ' x 2}else {$new_indent .= ' ' x $self->indent}if ($last->{column}){my$space=$self->indent > 1 ? ' ' x ($self->indent - 1): ' ';$yaml .= $space}else {$yaml .= $indent}if ($last->{type}eq 'SEQ'){$yaml .= "-"}elsif ($last->{type}eq 'MAP'){$last->{type}='COMPLEX';$zero_indent=1;$yaml .= "?"}elsif ($last->{type}eq 'COMPLEXVALUE'){$yaml .= ":";$zero_indent=1}else {die "Should not happen ($last->{type} in sequence_start)"}$last->{column}=1}$last->{newline}=0}if ($props){$yaml .= $last->{column}? ' ' : $indent;$yaml .= $props;$newline=1}}$self->_write($yaml);$last->{index}++;my$new_info={index=>0,indent=>$new_indent,info=>$info,zero_indent=>$zero_indent,newline=>$newline,column=>$self->column,flow=>$flow,};$new_info->{type}='SEQ';push @{$stack},$new_info;$self->{open_ended}=0}sub sequence_end_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ sequence_end_event\n";my ($self,$info)=@_;my$stack=$self->event_stack;my$last=pop @{$stack};if ($last->{index}==0){my$indent=$last->{indent};my$zero_indent=$last->{zero_indent};if ($last->{zero_indent}){$indent .= ' ' x $self->indent}my$yaml .= $self->column ? ' ' : $indent;$yaml .= "[]";if ($last->{flow}< 2){$yaml .= "\n"}$self->_write($yaml)}elsif ($last->{flow}){my$yaml="]";if ($last->{flow}==1){$yaml .= "\n"}$self->_write($yaml)}$last=$stack->[-1];$last->{column}=$self->column;if ($last->{type}eq 'SEQ'){}elsif ($last->{type}eq 'MAP'){$last->{type}='MAPVALUE'}elsif ($last->{type}eq 'MAPVALUE'){$last->{type}='MAP'}elsif ($last->{type}eq 'COMPLEX'){$last->{type}='COMPLEXVALUE'}elsif ($last->{type}eq 'COMPLEXVALUE'){$last->{type}='MAP'}}my%forbidden_first=(qw/! 1 & 1 * 1 { 1 } 1 [ 1 ] 1 | 1 > 1 @ 1 ` 1 " 1 ' 1/,'#'=>1,'%'=>1,','=>1," "=>1);my%forbidden_first_plus_space=(qw/? 1 - 1 : 1/);my%control=("\x00"=>'\0',"\x01"=>'\x01',"\x02"=>'\x02',"\x03"=>'\x03',"\x04"=>'\x04',"\x05"=>'\x05',"\x06"=>'\x06',"\x07"=>'\a',"\x08"=>'\b',"\x0b"=>'\v',"\x0c"=>'\f',"\x0e"=>'\x0e',"\x0f"=>'\x0f',"\x10"=>'\x10',"\x11"=>'\x11',"\x12"=>'\x12',"\x13"=>'\x13',"\x14"=>'\x14',"\x15"=>'\x15',"\x16"=>'\x16',"\x17"=>'\x17',"\x18"=>'\x18',"\x19"=>'\x19',"\x1a"=>'\x1a',"\x1b"=>'\e',"\x1c"=>'\x1c',"\x1d"=>'\x1d',"\x1e"=>'\x1e',"\x1f"=>'\x1f',"\x7f"=>'\x7f',"\x80"=>'\x80',"\x81"=>'\x81',"\x82"=>'\x82',"\x83"=>'\x83',"\x84"=>'\x84',"\x86"=>'\x86',"\x87"=>'\x87',"\x88"=>'\x88',"\x89"=>'\x89',"\x8a"=>'\x8a',"\x8b"=>'\x8b',"\x8c"=>'\x8c',"\x8d"=>'\x8d',"\x8e"=>'\x8e',"\x8f"=>'\x8f',"\x90"=>'\x90',"\x91"=>'\x91',"\x92"=>'\x92',"\x93"=>'\x93',"\x94"=>'\x94',"\x95"=>'\x95',"\x96"=>'\x96',"\x97"=>'\x97',"\x98"=>'\x98',"\x99"=>'\x99',"\x9a"=>'\x9a',"\x9b"=>'\x9b',"\x9c"=>'\x9c',"\x9d"=>'\x9d',"\x9e"=>'\x9e',"\x9f"=>'\x9f',"\x{2029}"=>'\P',"\x{2028}"=>'\L',"\x85"=>'\N',"\xa0"=>'\_',);my$control_re='\x00-\x08\x0b\x0c\x0e-\x1f\x7f-\x84\x86-\x9f\x{d800}-\x{dfff}\x{fffe}\x{ffff}\x{2028}\x{2029}\x85\xa0';my%to_escape=("\n"=>'\n',"\t"=>'\t',"\r"=>'\r','\\'=>'\\\\','"'=>'\\"',%control,);my$escape_re=$control_re .'\n\t\r';my$escape_re_without_lb=$control_re .'\t\r';sub scalar_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ scalar_event\n";my ($self,$info)=@_;my$stack=$self->event_stack;my$last=$stack->[-1];my$indent=$last->{indent};my$value=$info->{value};my$flow=$last->{flow};my$props='';my$anchor=$info->{anchor};my$tag=$info->{tag};if (defined$anchor){$anchor="&$anchor"}if (defined$tag){$tag=$self->emit_tag('scalar',$tag)}$props=join ' ',grep defined,($anchor,$tag);my$style=$info->{style};DEBUG and local$Data::Dumper::Useqq=1;$value='' unless defined$value;my$first=substr($value,0,1);if ($value eq ''){if ($flow and $last->{type}ne 'MAPVALUE' and $last->{type}ne 'MAP'){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif (not $style){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}}elsif ($value =~ m/[$control_re]/){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}$style ||= YAML_PLAIN_SCALAR_STYLE;if ($style==YAML_SINGLE_QUOTED_SCALAR_STYLE){if ($value =~ m/ \n/ or $value =~ m/\n / or $value =~ m/^\n/ or $value =~ m/\n$/){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}elsif ($value eq "\n"){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}}elsif ($style==YAML_LITERAL_SCALAR_STYLE or $style==YAML_FOLDED_SCALAR_STYLE){if ($value eq ''){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}elsif ($flow){if ($value =~ tr/\n//){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}else {$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}}}elsif ($style==YAML_PLAIN_SCALAR_STYLE){if (not length$value){}elsif ($value =~ m/[$escape_re_without_lb]/){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}elsif ($value eq "\n"){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}elsif ($value !~ tr/ //c){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($value !~ tr/ \n//c){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}elsif ($value =~ tr/\n//){$style=$flow ? YAML_DOUBLE_QUOTED_SCALAR_STYLE : YAML_LITERAL_SCALAR_STYLE}elsif ($forbidden_first{$first }){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($flow and $value =~ tr/,[]{}//){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif (substr($value,0,3)=~ m/^(?:---|\.\.\.)/){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($value =~ m/: /){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($value =~ m/ #/){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($value =~ m/[: \t]\z/){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($value =~ m/[^\x20-\x3A\x3B-\x7E\x85\xA0-\x{D7FF}\x{E000}-\x{FEFE}\x{FF00}-\x{FFFD}\x{10000}-\x{10FFFF}]/){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($forbidden_first_plus_space{$first }){if (length ($value)==1 or substr($value,1,1)=~ m/^\s/){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}}}if ($style==YAML_SINGLE_QUOTED_SCALAR_STYLE and not $info->{style}){if ($value =~ tr/'// and $value !~ tr/"//){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}}my$open_ended=0;if ($style==YAML_PLAIN_SCALAR_STYLE){$value =~ s/\n/\n\n/g}elsif ($style==YAML_SINGLE_QUOTED_SCALAR_STYLE){my$new_indent=$last->{indent}.(' ' x $self->indent);$value =~ s/(\n+)/"\n" x (1 + (length $1))/eg;my@lines=split m/\n/,$value,-1;if (@lines > 1){for my$line (@lines[1 .. $#lines]){$line=$new_indent .$line if length$line}}$value=join "\n",@lines;$value =~ s/'/''/g;$value="'" .$value ."'"}elsif ($style==YAML_LITERAL_SCALAR_STYLE){DEBUG and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$value],['value']);my$indicators='';if ($value =~ m/\A\n* +/){$indicators .= $self->indent}my$indent=$indent .' ' x $self->indent;if ($value !~ m/\n\z/){$indicators .= '-';$value .= "\n"}elsif ($value =~ m/(\n|\A)\n\z/){$indicators .= '+';$open_ended=1}$value =~ s/^(?=.)/$indent/gm;$value="|$indicators\n$value"}elsif ($style==YAML_FOLDED_SCALAR_STYLE){DEBUG and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$value],['value']);my@lines=split /\n/,$value,-1;DEBUG and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\@lines],['lines']);my$eol=0;my$indicators='';if ($value =~ m/\A\n* +/){$indicators .= $self->indent}my$indent=$indent .' ' x $self->indent;if ($lines[-1]eq ''){pop@lines;$eol=1}else {$indicators .= '-'}$value=">$indicators\n";for my$i (0 .. $#lines){my$line=$lines[$i ];if (length$line){$value .= "$indent$line\n"}if ($i!=$#lines){$value .= "\n"}}}else {$value =~ s/([$escape_re"\\])/$to_escape{ $1 } || sprintf '\\u%04x', ord($1)/eg;$value='"' .$value .'"'}DEBUG and warn __PACKAGE__.':'.__LINE__.": (@$stack)\n";my$yaml='';my$pvalue=$props;if ($props and length$value){$pvalue .= " $value"}elsif (length$value){$pvalue .= $value}my$multiline=($style==YAML_LITERAL_SCALAR_STYLE or $style==YAML_FOLDED_SCALAR_STYLE);my$newline=0;if ($flow){$indent=0;if ($props and not length$value){$pvalue .= ' '}if ($last->{type}eq 'SEQ'){if ($last->{index}==0){if ($self->column){$yaml .= ' '}$yaml .= "["}else {$yaml .= ", "}}elsif ($last->{type}eq 'MAP'){if ($last->{index}==0){if ($self->column){$yaml .= ' '}$yaml .= "{"}else {$yaml .= ", "}$last->{type}='MAPVALUE'}elsif ($last->{type}eq 'MAPVALUE'){if ($last->{index}==0){die "Should not happen (index 0 in MAPVALUE)"}$yaml .= ": ";$last->{type}='MAP'}if ($self->column + length$pvalue > $self->width){$yaml .= "\n";$yaml .= $last->{indent};$yaml .= ' ' x $self->indent}$yaml .= $pvalue}else {if ($last->{type}eq 'MAP' or $last->{type}eq 'SEQ'){if ($last->{index}==0 and $last->{newline}){$yaml .= "\n";$last->{column}=0;$last->{newline}=0}}my$space=' ';if ($last->{type}eq 'MAP'){if ($last->{column}){my$space=$self->indent > 1 ? ' ' x ($self->indent - 1): ' ';$yaml .= $space}else {$yaml .= $indent}if ($props and not length$value){$pvalue .= ' '}my$new_event='MAPVALUE';$last->{type}=$new_event;if ($multiline){$yaml .= "? ";$new_event='COMPLEXVALUE';$last->{type}=$new_event}if (not $multiline){$pvalue .= ":"}}else {if ($last->{type}eq 'MAPVALUE'){$last->{type}='MAP'}elsif ($last->{type}eq 'DOC'){}else {if ($last->{column}){my$space=$self->indent > 1 ? ' ' x ($self->indent - 1): ' ';$yaml .= $space}else {$yaml .= $indent}if ($last->{type}eq 'COMPLEXVALUE'){$last->{type}='MAP';$yaml .= ":"}elsif ($last->{type}eq 'SEQ'){$yaml .= "-"}else {die "Should not happen ($last->{type} in scalar_event)"}$last->{column}=1}if (length$pvalue){if ($last->{column}){$pvalue="$space$pvalue"}}if (not $multiline){$pvalue .= "\n"}}$yaml .= $pvalue}$last->{index}++;$last->{newline}=$newline;$self->_write($yaml);$last->{column}=$self->column;$self->{open_ended}=$open_ended}sub alias_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ alias_event\n";my ($self,$info)=@_;my$stack=$self->event_stack;my$last=$stack->[-1];my$indent=$last->{indent};my$flow=$last->{flow};my$alias='*' .$info->{value};my$yaml='';if ($last->{type}eq 'MAP' or $last->{type}eq 'SEQ'){if ($last->{index}==0 and $last->{newline}){$yaml .= "\n";$last->{column}=0;$last->{newline}=0}}$yaml .= $last->{column}? ' ' : $indent;if ($flow){my$space='';if ($last->{type}eq 'SEQ'){if ($last->{index}==0){if ($flow==1){$yaml .= ' '}$yaml .= "["}else {$yaml .= ", "}}elsif ($last->{type}eq 'MAP'){if ($last->{index}==0){if ($flow==1){$yaml .= ' '}$yaml .= "{"}else {$yaml .= ", "}$last->{type}='MAPVALUE';$space=' '}elsif ($last->{type}eq 'MAPVALUE'){if ($last->{index}==0){die 23;if ($flow==1){$yaml .= ' '}$yaml .= "{"}else {$yaml .= ": "}$last->{type}='MAP'}$yaml .= "$alias$space"}else {if ($last->{type}eq 'MAP'){$yaml .= "$alias :";$last->{type}='MAPVALUE'}else {if ($last->{type}eq 'MAPVALUE'){$last->{type}='MAP'}elsif ($last->{type}eq 'DOC'){}else {if ($last->{type}eq 'COMPLEXVALUE'){$last->{type}='MAP';$yaml .= ": "}elsif ($last->{type}eq 'COMPLEX'){$yaml .= ": "}elsif ($last->{type}eq 'SEQ'){$yaml .= "- "}else {die "Unexpected"}}$yaml .= "$alias\n"}}$self->_write("$yaml");$last->{index}++;$last->{column}=$self->column;$self->{open_ended}=0}sub document_start_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ document_start_event\n";my ($self,$info)=@_;my$newline=0;my$implicit=$info->{implicit};if ($info->{version_directive}){if ($self->{open_ended}){$self->_write("...\n")}$self->_write("%YAML $info->{version_directive}->{major}.$info->{version_directive}->{minor}\n");$self->{open_ended}=0;$implicit=0}unless ($implicit){$newline=1;$self->_write("---")}$self->set_event_stack([{type=>'DOC',index=>0,indent=>'',info=>$info,newline=>$newline,column=>$self->column,}])}sub document_end_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ document_end_event\n";my ($self,$info)=@_;$self->set_event_stack([]);if ($self->{open_ended}or not $info->{implicit}){$self->_write("...\n");$self->{open_ended}=0}else {$self->{open_ended}=1}}sub stream_start_event {}sub stream_end_event {}sub emit_tag {my ($self,$type,$tag)=@_;my$map=$self->tagmap;for my$key (sort keys %$map){if ($tag =~ m/^\Q$key\E(.*)/){$tag=$map->{$key }.$1;return$tag}}if ($tag =~ m/^(!.*)/){$tag="$1"}else {$tag="!<$tag>"}return$tag}sub finish {my ($self)=@_;$self->writer->finish}sub _write {my ($self,$yaml)=@_;return unless length$yaml;my@lines=split m/\n/,$yaml,-1;my$newlines=@lines - 1;$self->{line}+= $newlines;if (length$lines[-1]){if ($newlines){$self->{column}=length$lines[-1]}else {$self->{column}+= length$lines[-1]}}else {$self->{column}=0}$self->writer->write($yaml)}1;
YAML_PP_EMITTER

$fatpacked{"YAML/PP/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_EXCEPTION';
  use strict;use warnings;package YAML::PP::Exception;our$VERSION='0.030';use overload '""'=>\&to_string;sub new {my ($class,%args)=@_;my$self=bless {line=>$args{line},msg=>$args{msg},next=>$args{next},where=>$args{where},yaml=>$args{yaml},got=>$args{got},expected=>$args{expected},column=>$args{column},},$class;return$self}sub to_string {my ($self)=@_;my$next=$self->{next};my$line=$self->{line};my$column=$self->{column};my$yaml='';for my$token (@$next){last if$token->{name}eq 'EOL';$yaml .= $token->{value}}$column='???' unless defined$column;my$remaining_yaml=$self->{yaml};$remaining_yaml='' unless defined$remaining_yaml;$yaml .= $remaining_yaml;{local $@;require Data::Dumper;local$Data::Dumper::Useqq=1;local$Data::Dumper::Terse=1;$yaml=Data::Dumper->Dump([$yaml],['yaml']);chomp$yaml}my$lines=5;my@fields;if ($self->{got}and $self->{expected}){$lines=6;$line=$self->{got}->{line};$column=$self->{got}->{column}+ 1;@fields=("Line"=>$line,"Column"=>$column,"Expected",join(" ",@{$self->{expected}}),"Got",$self->{got}->{name},"Where",$self->{where},"YAML",$yaml,)}else {@fields=("Line"=>$line,"Column"=>$column,"Message",$self->{msg},"Where",$self->{where},"YAML",$yaml,)}my$fmt=join "\n",("%-10s: %s")x $lines;my$string=sprintf$fmt,@fields;return$string}1;
YAML_PP_EXCEPTION

$fatpacked{"YAML/PP/Grammar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_GRAMMAR';
  use strict;use warnings;package YAML::PP::Grammar;our$VERSION='0.030';use base 'Exporter';our@EXPORT_OK=qw/$GRAMMAR/;our$GRAMMAR={};$GRAMMAR={'DIRECTIVE'=>{'DOC_START'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_doc_start_explicit' },'EOL'=>{'new'=>'DIRECTIVE' },'RESERVED_DIRECTIVE'=>{'EOL'=>{'new'=>'DIRECTIVE' },'WS'=>{'new'=>'DIRECTIVE' },'match'=>'cb_reserved_directive' },'TAG_DIRECTIVE'=>{'EOL'=>{'new'=>'DIRECTIVE' },'WS'=>{'new'=>'DIRECTIVE' },'match'=>'cb_tag_directive' },'YAML_DIRECTIVE'=>{'EOL'=>{'new'=>'DIRECTIVE' },'WS'=>{'new'=>'DIRECTIVE' },'match'=>'cb_set_yaml_version_directive' }},'DOCUMENT_END'=>{'DOC_END'=>{'EOL'=>{},'match'=>'cb_end_document' },'DOC_START'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_end_doc_start_document' },'EOL'=>{'new'=>'DOCUMENT_END' }},'END_FLOW'=>{'EOL'=>{'match'=>'cb_end_outer_flow','return'=>1 }},'FLOWMAP'=>{'ANCHOR'=>{'DEFAULT'=>{'new'=>'NEWFLOWMAP_ANCHOR' },'EOL'=>{'new'=>'NEWFLOWMAP_ANCHOR_SPC' },'WS'=>{'new'=>'NEWFLOWMAP_ANCHOR_SPC' },'match'=>'cb_anchor' },'COLON'=>{'EOL'=>{'match'=>'cb_empty_flow_mapkey','new'=>'RULE_FULLFLOWSCALAR' },'WS'=>{'match'=>'cb_empty_flow_mapkey','new'=>'RULE_FULLFLOWSCALAR' }},'DEFAULT'=>{'new'=>'FLOWMAP_CONTENT' },'EOL'=>{'new'=>'FLOWMAP' },'FLOWMAP_END'=>{'match'=>'cb_end_flowmap','return'=>1 },'TAG'=>{'DEFAULT'=>{'new'=>'NEWFLOWMAP_TAG' },'EOL'=>{'new'=>'NEWFLOWMAP_TAG_SPC' },'WS'=>{'new'=>'NEWFLOWMAP_TAG_SPC' },'match'=>'cb_tag' },'WS'=>{'new'=>'FLOWMAP' }},'FLOWMAP_CONTENT'=>{'ALIAS'=>{'match'=>'cb_send_alias','return'=>1 },'COLON'=>{'EOL'=>{'match'=>'cb_empty_flow_mapkey','new'=>'RULE_FULLFLOWSCALAR' },'WS'=>{'match'=>'cb_empty_flow_mapkey','new'=>'RULE_FULLFLOWSCALAR' }},'FLOWMAP_START'=>{'match'=>'cb_start_flowmap','new'=>'NEWFLOWMAP' },'FLOWSEQ_START'=>{'match'=>'cb_start_flowseq','new'=>'NEWFLOWSEQ' },'PLAIN'=>{'match'=>'cb_flowkey_plain','return'=>1 },'PLAIN_MULTI'=>{'match'=>'cb_send_plain_multi','return'=>1 },'QUOTED'=>{'match'=>'cb_flowkey_quoted','return'=>1 },'QUOTED_MULTILINE'=>{'match'=>'cb_quoted_multiline','return'=>1 }},'FLOWMAP_EMPTYKEY'=>{'FLOWMAP_END'=>{'match'=>'cb_end_empty_flowmap_key_value','return'=>1 },'FLOW_COMMA'=>{'match'=>'cb_empty_flowmap_key_value','return'=>1 }},'FLOWMAP_EXPLICIT_KEY'=>{'DEFAULT'=>{'new'=>'FLOWMAP' },'EOL'=>{'new'=>'FLOWMAP_EXPLICIT_KEY' },'FLOWMAP_END'=>{'match'=>'cb_end_empty_flowmap_key_value','return'=>1 },'FLOW_COMMA'=>{'match'=>'cb_empty_flowmap_key_value','return'=>1 },'WS'=>{'new'=>'FLOWMAP_EXPLICIT_KEY' }},'FLOWMAP_PROPS'=>{'COLON'=>{'EOL'=>{'match'=>'cb_empty_flow_mapkey','new'=>'RULE_FULLFLOWSCALAR' },'WS'=>{'match'=>'cb_empty_flow_mapkey','new'=>'RULE_FULLFLOWSCALAR' }},'FLOWMAP_END'=>{'match'=>'cb_end_empty_flowmap_key_value','return'=>1 },'FLOWMAP_START'=>{'match'=>'cb_start_flowmap','new'=>'NEWFLOWMAP' },'FLOWSEQ_START'=>{'match'=>'cb_start_flowseq','new'=>'NEWFLOWSEQ' },'FLOW_COMMA'=>{'match'=>'cb_empty_flowmap_key_value','return'=>1 },'PLAIN'=>{'match'=>'cb_flowkey_plain','return'=>1 },'PLAIN_MULTI'=>{'match'=>'cb_send_plain_multi','return'=>1 },'QUOTED'=>{'match'=>'cb_flowkey_quoted','return'=>1 },'QUOTED_MULTILINE'=>{'match'=>'cb_quoted_multiline','return'=>1 }},'FLOWSEQ'=>{'ALIAS'=>{'match'=>'cb_send_flow_alias','new'=>'FLOWSEQ_NEXT' },'COLON'=>{'EOL'=>{'match'=>'cb_insert_empty_implicit_flowseq_map','new'=>'RULE_FULLFLOWSCALAR' },'WS'=>{'match'=>'cb_insert_empty_implicit_flowseq_map','new'=>'RULE_FULLFLOWSCALAR' }},'FLOWMAP_START'=>{'match'=>'cb_start_flowmap','new'=>'NEWFLOWMAP' },'FLOWSEQ_START'=>{'match'=>'cb_start_flowseq','new'=>'NEWFLOWSEQ' },'PLAIN'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_MAYBE_KEY' },'EOL'=>{'match'=>'cb_send_scalar','new'=>'FLOWSEQ_NEXT' },'match'=>'cb_start_plain' },'PLAIN_MULTI'=>{'match'=>'cb_send_plain_multi','new'=>'FLOWSEQ_NEXT' },'QUOTED'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_MAYBE_KEY' },'EOL'=>{'match'=>'cb_send_scalar','new'=>'FLOWSEQ_NEXT' },'match'=>'cb_take_quoted' },'QUOTED_MULTILINE'=>{'match'=>'cb_quoted_multiline','new'=>'FLOWSEQ_NEXT' }},'FLOWSEQ_EMPTY'=>{'FLOWSEQ_END'=>{'match'=>'cb_empty_flowseq_end','return'=>1 },'FLOW_COMMA'=>{'match'=>'cb_empty_flowseq_comma','return'=>1 }},'FLOWSEQ_MAYBE_KEY'=>{'COLON'=>{'DEFAULT'=>{'match'=>'cb_insert_implicit_flowseq_map','new'=>'RULE_FULLFLOWSCALAR' },'EOL'=>{'match'=>'cb_insert_implicit_flowseq_map','new'=>'RULE_FULLFLOWSCALAR' },'WS'=>{'match'=>'cb_insert_implicit_flowseq_map','new'=>'RULE_FULLFLOWSCALAR' }},'DEFAULT'=>{'new'=>'FLOWSEQ_NEXT' },'WS'=>{'new'=>'FLOWSEQ_MAYBE_KEY' }},'FLOWSEQ_NEXT'=>{'EOL'=>{'new'=>'FLOWSEQ_NEXT' },'FLOWSEQ_END'=>{'match'=>'cb_end_flowseq','return'=>1 },'FLOW_COMMA'=>{'match'=>'cb_flow_comma','return'=>1 },'WS'=>{'new'=>'FLOWSEQ_NEXT' }},'FLOWSEQ_PROPS'=>{'COLON'=>{'EOL'=>{'match'=>'cb_insert_empty_implicit_flowseq_map','new'=>'RULE_FULLFLOWSCALAR' },'WS'=>{'match'=>'cb_insert_empty_implicit_flowseq_map','new'=>'RULE_FULLFLOWSCALAR' }},'FLOWMAP_START'=>{'match'=>'cb_start_flowmap','new'=>'NEWFLOWMAP' },'FLOWSEQ_END'=>{'match'=>'cb_empty_flowseq_end','return'=>1 },'FLOWSEQ_START'=>{'match'=>'cb_start_flowseq','new'=>'NEWFLOWSEQ' },'FLOW_COMMA'=>{'match'=>'cb_empty_flowseq_comma','return'=>1 },'PLAIN'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_MAYBE_KEY' },'EOL'=>{'match'=>'cb_send_scalar','new'=>'FLOWSEQ_NEXT' },'match'=>'cb_start_plain' },'PLAIN_MULTI'=>{'match'=>'cb_send_plain_multi','new'=>'FLOWSEQ_NEXT' },'QUOTED'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_MAYBE_KEY' },'EOL'=>{'match'=>'cb_send_scalar','new'=>'FLOWSEQ_NEXT' },'match'=>'cb_take_quoted' },'QUOTED_MULTILINE'=>{'match'=>'cb_quoted_multiline','new'=>'FLOWSEQ_NEXT' }},'FULLMAPVALUE_INLINE'=>{'ANCHOR'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_ANCHOR' },'WS'=>{'DEFAULT'=>{'new'=>'NODETYPE_MAPVALUE_INLINE' },'TAG'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG_ANCHOR' },'WS'=>{'new'=>'NODETYPE_MAPVALUE_INLINE' },'match'=>'cb_tag' }},'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_MAPVALUE_INLINE' },'TAG'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG' },'WS'=>{'ANCHOR'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG_ANCHOR' },'WS'=>{'new'=>'NODETYPE_MAPVALUE_INLINE' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_MAPVALUE_INLINE' }},'match'=>'cb_tag' }},'FULLNODE'=>{'ANCHOR'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_ANCHOR' },'WS'=>{'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'TAG'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG_ANCHOR' },'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_tag' }},'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_NODE' },'EOL'=>{'new'=>'FULLNODE' },'TAG'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG' },'WS'=>{'ANCHOR'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG_ANCHOR' },'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' }},'match'=>'cb_tag' }},'FULLNODE_ANCHOR'=>{'ANCHOR'=>{'WS'=>{'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'TAG'=>{'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_tag' }},'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_NODE' },'EOL'=>{'new'=>'FULLNODE_ANCHOR' },'TAG'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG_ANCHOR' },'WS'=>{'ANCHOR'=>{'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' }},'match'=>'cb_tag' }},'FULLNODE_TAG'=>{'ANCHOR'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG_ANCHOR' },'WS'=>{'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'TAG'=>{'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_tag' }},'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_NODE' },'EOL'=>{'new'=>'FULLNODE_TAG' },'TAG'=>{'WS'=>{'ANCHOR'=>{'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' }},'match'=>'cb_tag' }},'FULLNODE_TAG_ANCHOR'=>{'ANCHOR'=>{'WS'=>{'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'TAG'=>{'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_tag' }},'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_NODE' },'EOL'=>{'new'=>'FULLNODE_TAG_ANCHOR' },'TAG'=>{'WS'=>{'ANCHOR'=>{'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' }},'match'=>'cb_tag' }},'NEWFLOWMAP'=>{'DEFAULT'=>{'new'=>'FLOWMAP' },'EOL'=>{'new'=>'NEWFLOWMAP' },'QUESTION'=>{'match'=>'cb_flow_question','new'=>'FLOWMAP_EXPLICIT_KEY' },'WS'=>{'new'=>'NEWFLOWMAP' }},'NEWFLOWMAP_ANCHOR'=>{'DEFAULT'=>{'new'=>'FLOWMAP_EMPTYKEY' }},'NEWFLOWMAP_ANCHOR_SPC'=>{'DEFAULT'=>{'new'=>'FLOWMAP_PROPS' },'EOL'=>{'new'=>'NEWFLOWMAP_ANCHOR_SPC' },'TAG'=>{'DEFAULT'=>{'new'=>'FLOWMAP_EMPTYKEY' },'EOL'=>{'new'=>'FLOWMAP_PROPS' },'WS'=>{'new'=>'FLOWMAP_PROPS' },'match'=>'cb_tag' },'WS'=>{'new'=>'NEWFLOWMAP_ANCHOR_SPC' }},'NEWFLOWMAP_TAG'=>{'DEFAULT'=>{'new'=>'FLOWMAP_EMPTYKEY' }},'NEWFLOWMAP_TAG_SPC'=>{'ANCHOR'=>{'DEFAULT'=>{'new'=>'FLOWMAP_EMPTYKEY' },'EOL'=>{'new'=>'FLOWMAP_PROPS' },'WS'=>{'new'=>'FLOWMAP_PROPS' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'FLOWMAP_PROPS' },'EOL'=>{'new'=>'NEWFLOWMAP_TAG_SPC' },'WS'=>{'new'=>'NEWFLOWMAP_TAG_SPC' }},'NEWFLOWSEQ'=>{'ANCHOR'=>{'DEFAULT'=>{'new'=>'NEWFLOWSEQ_ANCHOR' },'EOL'=>{'new'=>'NEWFLOWSEQ_ANCHOR_SPC' },'WS'=>{'new'=>'NEWFLOWSEQ_ANCHOR_SPC' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'FLOWSEQ' },'EOL'=>{'new'=>'NEWFLOWSEQ' },'FLOWSEQ_END'=>{'match'=>'cb_end_flowseq','return'=>1 },'TAG'=>{'DEFAULT'=>{'new'=>'NEWFLOWSEQ_TAG' },'EOL'=>{'new'=>'NEWFLOWSEQ_TAG_SPC' },'WS'=>{'new'=>'NEWFLOWSEQ_TAG_SPC' },'match'=>'cb_tag' },'WS'=>{'new'=>'NEWFLOWSEQ' }},'NEWFLOWSEQ_ANCHOR'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_EMPTY' }},'NEWFLOWSEQ_ANCHOR_SPC'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_PROPS' },'EOL'=>{'new'=>'NEWFLOWSEQ_ANCHOR_SPC' },'TAG'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_EMPTY' },'EOL'=>{'new'=>'FLOWSEQ_PROPS' },'WS'=>{'new'=>'FLOWSEQ_PROPS' },'match'=>'cb_tag' },'WS'=>{'new'=>'NEWFLOWSEQ_ANCHOR_SPC' }},'NEWFLOWSEQ_TAG'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_EMPTY' }},'NEWFLOWSEQ_TAG_SPC'=>{'ANCHOR'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_EMPTY' },'EOL'=>{'new'=>'FLOWSEQ_PROPS' },'WS'=>{'new'=>'FLOWSEQ_PROPS' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'FLOWSEQ_PROPS' },'EOL'=>{'new'=>'NEWFLOWSEQ_TAG_SPC' },'WS'=>{'new'=>'NEWFLOWSEQ_TAG_SPC' }},'NODETYPE_COMPLEX'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_complexcolon' },'DEFAULT'=>{'match'=>'cb_empty_complexvalue','new'=>'NODETYPE_MAP' },'EOL'=>{'new'=>'NODETYPE_COMPLEX' }},'NODETYPE_FLOWMAP'=>{'DEFAULT'=>{'new'=>'NEWFLOWMAP' },'EOL'=>{'new'=>'NODETYPE_FLOWMAP' },'FLOWMAP_END'=>{'match'=>'cb_end_flowmap','return'=>1 },'FLOW_COMMA'=>{'match'=>'cb_flow_comma','new'=>'NEWFLOWMAP' },'WS'=>{'new'=>'NODETYPE_FLOWMAP' }},'NODETYPE_FLOWMAPVALUE'=>{'COLON'=>{'DEFAULT'=>{'new'=>'RULE_FULLFLOWSCALAR' },'EOL'=>{'new'=>'RULE_FULLFLOWSCALAR' },'WS'=>{'new'=>'RULE_FULLFLOWSCALAR' },'match'=>'cb_flow_colon' },'EOL'=>{'new'=>'NODETYPE_FLOWMAPVALUE' },'FLOWMAP_END'=>{'match'=>'cb_end_flowmap_empty','return'=>1 },'FLOW_COMMA'=>{'match'=>'cb_empty_flowmap_value','return'=>1 },'WS'=>{'new'=>'NODETYPE_FLOWMAPVALUE' }},'NODETYPE_FLOWSEQ'=>{'DEFAULT'=>{'new'=>'NEWFLOWSEQ' },'EOL'=>{'new'=>'NODETYPE_FLOWSEQ' },'FLOWSEQ_END'=>{'match'=>'cb_end_flowseq','return'=>1 },'WS'=>{'new'=>'NODETYPE_FLOWSEQ' }},'NODETYPE_MAP'=>{'ANCHOR'=>{'WS'=>{'DEFAULT'=>{'new'=>'RULE_MAPKEY' },'TAG'=>{'WS'=>{'new'=>'RULE_MAPKEY' },'match'=>'cb_tag' }},'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'RULE_MAPKEY' },'TAG'=>{'WS'=>{'ANCHOR'=>{'WS'=>{'new'=>'RULE_MAPKEY' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'RULE_MAPKEY' }},'match'=>'cb_tag' }},'NODETYPE_MAPVALUE_INLINE'=>{'ALIAS'=>{'EOL'=>{},'match'=>'cb_send_alias' },'BLOCK_SCALAR'=>{'EOL'=>{},'match'=>'cb_send_block_scalar' },'DOC_END'=>{'EOL'=>{},'match'=>'cb_end_document' },'FLOWMAP_START'=>{'match'=>'cb_start_flowmap','new'=>'NEWFLOWMAP' },'FLOWSEQ_START'=>{'match'=>'cb_start_flowseq','new'=>'NEWFLOWSEQ' },'PLAIN'=>{'EOL'=>{'match'=>'cb_send_scalar' },'match'=>'cb_start_plain' },'PLAIN_MULTI'=>{'EOL'=>{},'match'=>'cb_send_plain_multi' },'QUOTED'=>{'EOL'=>{'match'=>'cb_send_scalar' },'match'=>'cb_take_quoted' },'QUOTED_MULTILINE'=>{'EOL'=>{},'match'=>'cb_quoted_multiline' }},'NODETYPE_NODE'=>{'DASH'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_seqstart' },'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' }},'NODETYPE_SCALAR_OR_MAP'=>{'ALIAS'=>{'EOL'=>{'match'=>'cb_send_alias_from_stack' },'WS'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_insert_map_alias' }},'match'=>'cb_alias' },'BLOCK_SCALAR'=>{'EOL'=>{},'match'=>'cb_send_block_scalar' },'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_insert_empty_map' },'DOC_END'=>{'EOL'=>{},'match'=>'cb_end_document' },'DOC_START'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_end_doc_start_document' },'EOL'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'FLOWMAP_START'=>{'match'=>'cb_start_flowmap','new'=>'NEWFLOWMAP' },'FLOWSEQ_START'=>{'match'=>'cb_start_flowseq','new'=>'NEWFLOWSEQ' },'PLAIN'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_insert_map' },'EOL'=>{'match'=>'cb_send_scalar' },'WS'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_insert_map' }},'match'=>'cb_start_plain' },'PLAIN_MULTI'=>{'EOL'=>{},'match'=>'cb_send_plain_multi' },'QUESTION'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_questionstart' },'QUOTED'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_insert_map' },'EOL'=>{'match'=>'cb_send_scalar' },'WS'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_insert_map' }},'match'=>'cb_take_quoted' },'QUOTED_MULTILINE'=>{'EOL'=>{},'match'=>'cb_quoted_multiline' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' }},'NODETYPE_SEQ'=>{'DASH'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_seqitem' },'DOC_END'=>{'EOL'=>{},'match'=>'cb_end_document' },'DOC_START'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_end_doc_start_document' },'EOL'=>{'new'=>'NODETYPE_SEQ' }},'RULE_FLOWSCALAR'=>{'ALIAS'=>{'match'=>'cb_send_alias','return'=>1 },'FLOWMAP_END'=>{'match'=>'cb_end_flowmap_empty','return'=>1 },'FLOWMAP_START'=>{'match'=>'cb_start_flowmap','new'=>'NEWFLOWMAP' },'FLOWSEQ_START'=>{'match'=>'cb_start_flowseq','new'=>'NEWFLOWSEQ' },'FLOW_COMMA'=>{'match'=>'cb_empty_flow_mapkey','return'=>1 },'PLAIN'=>{'DEFAULT'=>{'match'=>'cb_send_scalar','return'=>1 },'EOL'=>{'match'=>'cb_send_scalar' },'match'=>'cb_start_plain' },'PLAIN_MULTI'=>{'match'=>'cb_send_plain_multi','return'=>1 },'QUOTED'=>{'DEFAULT'=>{'match'=>'cb_send_scalar','return'=>1 },'EOL'=>{'match'=>'cb_send_scalar' },'WS'=>{'match'=>'cb_send_scalar','return'=>1 },'match'=>'cb_take_quoted' },'QUOTED_MULTILINE'=>{'match'=>'cb_quoted_multiline','return'=>1 }},'RULE_FULLFLOWSCALAR'=>{'ANCHOR'=>{'DEFAULT'=>{'new'=>'RULE_FULLFLOWSCALAR_ANCHOR' },'EOL'=>{'new'=>'RULE_FULLFLOWSCALAR_ANCHOR' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'RULE_FLOWSCALAR' },'TAG'=>{'DEFAULT'=>{'new'=>'RULE_FULLFLOWSCALAR_TAG' },'EOL'=>{'new'=>'RULE_FULLFLOWSCALAR_TAG' },'match'=>'cb_tag' }},'RULE_FULLFLOWSCALAR_ANCHOR'=>{'DEFAULT'=>{'new'=>'RULE_FLOWSCALAR' },'TAG'=>{'EOL'=>{'new'=>'RULE_FLOWSCALAR' },'WS'=>{'new'=>'RULE_FLOWSCALAR' },'match'=>'cb_tag' },'WS'=>{'new'=>'RULE_FULLFLOWSCALAR_ANCHOR' }},'RULE_FULLFLOWSCALAR_TAG'=>{'ANCHOR'=>{'EOL'=>{'new'=>'RULE_FLOWSCALAR' },'WS'=>{'new'=>'RULE_FLOWSCALAR' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'RULE_FLOWSCALAR' },'WS'=>{'new'=>'RULE_FULLFLOWSCALAR_TAG' }},'RULE_MAPKEY'=>{'ALIAS'=>{'WS'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' }}},'match'=>'cb_send_alias' },'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_empty_mapkey' },'DOC_END'=>{'EOL'=>{},'match'=>'cb_end_document' },'DOC_START'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_end_doc_start_document' },'EOL'=>{'new'=>'RULE_MAPKEY' },'PLAIN'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_send_mapkey' },'WS'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_send_mapkey' }},'match'=>'cb_mapkey' },'QUESTION'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_question' },'QUOTED'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' }},'WS'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' }}},'match'=>'cb_take_quoted_key' }},'STREAM'=>{'DEFAULT'=>{'match'=>'cb_doc_start_implicit','new'=>'FULLNODE' },'DOC_END'=>{'EOL'=>{},'match'=>'cb_end_document_empty' },'DOC_START'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_doc_start_explicit' },'EOL'=>{'new'=>'STREAM' },'RESERVED_DIRECTIVE'=>{'EOL'=>{'new'=>'DIRECTIVE' },'WS'=>{'new'=>'DIRECTIVE' },'match'=>'cb_reserved_directive' },'TAG_DIRECTIVE'=>{'EOL'=>{'new'=>'DIRECTIVE' },'WS'=>{'new'=>'DIRECTIVE' },'match'=>'cb_tag_directive' },'YAML_DIRECTIVE'=>{'EOL'=>{'new'=>'DIRECTIVE' },'WS'=>{'new'=>'DIRECTIVE' },'match'=>'cb_set_yaml_version_directive' }}};1;
YAML_PP_GRAMMAR

$fatpacked{"YAML/PP/Highlight.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_HIGHLIGHT';
  use strict;use warnings;package YAML::PP::Highlight;our$VERSION='0.030';our@EXPORT_OK=qw/Dump/;use base 'Exporter';use YAML::PP;use YAML::PP::Parser;use Encode;sub Dump {my (@docs)=@_;require YAML::PP::Schema::Perl;my$yp=YAML::PP->new(schema=>[qw/+ Perl/]);my$yaml=$yp->dump_string(@docs);my ($error,$tokens)=YAML::PP::Parser->yaml_to_tokens(string=>$yaml);my$highlighted=YAML::PP::Highlight->ansicolored($tokens);encode_utf8$highlighted}my%ansicolors=(ANCHOR=>[qw/green/],ALIAS=>[qw/bold green/],TAG=>[qw/bold blue/],INDENT=>[qw/white on_grey3/],COMMENT=>[qw/grey12/],COLON=>[qw/bold magenta/],DASH=>[qw/bold magenta/],QUESTION=>[qw/bold magenta/],YAML_DIRECTIVE=>[qw/cyan/],TAG_DIRECTIVE=>[qw/bold cyan/],SINGLEQUOTE=>[qw/bold green/],SINGLEQUOTED=>[qw/green/],SINGLEQUOTED_LINE=>[qw/green/],DOUBLEQUOTE=>[qw/bold green/],DOUBLEQUOTED=>[qw/green/],DOUBLEQUOTED_LINE=>[qw/green/],LITERAL=>[qw/bold yellow/],FOLDED=>[qw/bold yellow/],DOC_START=>[qw/bold/],DOC_END=>[qw/bold/],BLOCK_SCALAR_CONTENT=>[qw/yellow/],TAB=>[qw/on_blue/],ERROR=>[qw/bold red/],EOL=>[qw/grey12/],TRAILING_SPACE=>[qw/on_grey6/],FLOWSEQ_START=>[qw/bold magenta/],FLOWSEQ_END=>[qw/bold magenta/],FLOWMAP_START=>[qw/bold magenta/],FLOWMAP_END=>[qw/bold magenta/],FLOW_COMMA=>[qw/bold magenta/],PLAINKEY=>[qw/bright_blue/],);sub ansicolored {my ($class,$tokens,%args)=@_;my$expand_tabs=$args{expand_tabs};$expand_tabs=1 unless defined$expand_tabs;require Term::ANSIColor;local$Term::ANSIColor::EACHLINE="\n";my$ansi='';my$highlighted='';my@list=$class->transform($tokens);for my$token (@list){my$name=$token->{name};my$str=$token->{value};my$color=$ansicolors{$name };if ($color){$str=Term::ANSIColor::colored($color,$str)}$highlighted .= $str}if ($expand_tabs){$highlighted =~ s/\t/' ' x 8/eg}$ansi .= $highlighted;return$ansi}my%htmlcolors=(ANCHOR=>'anchor',ALIAS=>'alias',SINGLEQUOTE=>'singlequote',DOUBLEQUOTE=>'doublequote',SINGLEQUOTED=>'singlequoted',DOUBLEQUOTED=>'doublequoted',SINGLEQUOTED_LINE=>'singlequoted',DOUBLEQUOTED_LINE=>'doublequoted',INDENT=>'indent',DASH=>'dash',COLON=>'colon',QUESTION=>'question',YAML_DIRECTIVE=>'yaml_directive',TAG_DIRECTIVE=>'tag_directive',TAG=>'tag',COMMENT=>'comment',LITERAL=>'literal',FOLDED=>'folded',DOC_START=>'doc_start',DOC_END=>'doc_end',BLOCK_SCALAR_CONTENT=>'block_scalar_content',TAB=>'tab',ERROR=>'error',EOL=>'eol',TRAILING_SPACE=>'trailing_space',FLOWSEQ_START=>'flowseq_start',FLOWSEQ_END=>'flowseq_end',FLOWMAP_START=>'flowmap_start',FLOWMAP_END=>'flowmap_end',FLOW_COMMA=>'flow_comma',PLAINKEY=>'plainkey',);sub htmlcolored {require HTML::Entities;my ($class,$tokens)=@_;my$html='';my@list=$class->transform($tokens);for my$token (@list){my$name=$token->{name};my$str=$token->{value};my$colorclass=$htmlcolors{$name }|| 'default';$str=HTML::Entities::encode_entities($str);$html .= qq{<span class="$colorclass">$str</span>}}return$html}sub transform {my ($class,$tokens)=@_;my@list;for my$token (@$tokens){my@values;my$value=$token->{value};my$subtokens=$token->{subtokens};if ($subtokens){@values=@$subtokens}else {@values=$token}for my$token (@values){my$value=defined$token->{orig}? $token->{orig}: $token->{value};push@list,map {$_ =~ tr/\t/\t/ ? {name=>'TAB',value=>$_ }: {name=>$token->{name},value=>$_ }}split m/(\t+)/,$value}}for my$i (0 .. $#list){my$token=$list[$i ];my$name=$token->{name};my$str=$token->{value};my$trailing_space=0;if ($token->{name}eq 'EOL'){if ($str =~ m/ +([\r\n]|\z)/){$token->{name}="TRAILING_SPACE"}}elsif ($i < $#list){if ($name eq 'PLAIN'){for my$n ($i+1 .. $#list){my$next=$list[$n ];last if$next->{name}eq 'EOL';next if$next->{name}=~ m/^(WS|SPACE)$/;if ($next->{name}eq 'COLON'){$token->{name}='PLAINKEY'}}}my$next=$list[$i + 1];if ($next->{name}eq 'EOL'){if ($str =~ m/ \z/ and $name =~ m/^(BLOCK_SCALAR_CONTENT|WS)$/){$token->{name}="TRAILING_SPACE"}}}}return@list}1;
YAML_PP_HIGHLIGHT

$fatpacked{"YAML/PP/Lexer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_LEXER';
  use strict;use warnings;package YAML::PP::Lexer;our$VERSION='0.030';use constant TRACE=>$ENV{YAML_PP_TRACE}? 1 : 0;use constant DEBUG=>($ENV{YAML_PP_DEBUG}|| $ENV{YAML_PP_TRACE})? 1 : 0;use YAML::PP::Grammar qw/$GRAMMAR/;use Carp qw/croak/;sub new {my ($class,%args)=@_;my$self=bless {reader=>$args{reader},},$class;$self->init;return$self}sub init {my ($self)=@_;$self->{next_tokens}=[];$self->{next_line}=undef;$self->{line}=0;$self->{offset}=0;$self->{flowcontext}=0}sub next_line {return $_[0]->{next_line}}sub set_next_line {$_[0]->{next_line}=$_[1]}sub reader {return $_[0]->{reader}}sub set_reader {$_[0]->{reader}=$_[1]}sub next_tokens {return $_[0]->{next_tokens}}sub line {return $_[0]->{line}}sub set_line {$_[0]->{line}=$_[1]}sub offset {return $_[0]->{offset}}sub set_offset {$_[0]->{offset}=$_[1]}sub inc_line {return $_[0]->{line}++}sub context {return $_[0]->{context}}sub set_context {$_[0]->{context}=$_[1]}sub flowcontext {return $_[0]->{flowcontext}}sub set_flowcontext {$_[0]->{flowcontext}=$_[1]}my$RE_WS='[\t ]';my$RE_LB='[\r\n]';my$RE_DOC_END=qr/\A(\.\.\.)(?=$RE_WS|$)/m;my$RE_DOC_START=qr/\A(---)(?=$RE_WS|$)/m;my$RE_EOL=qr/\A($RE_WS+#.*|$RE_WS+)\z/;my$RE_NS_WORD_CHAR='[0-9A-Za-z-]';my$RE_URI_CHAR='(?:' .'%[0-9a-fA-F]{2}' .'|'.q{[0-9A-Za-z#;/?:@&=+$,_.!*'\(\)\[\]-]} .')';my$RE_NS_TAG_CHAR='(?:' .'%[0-9a-fA-F]{2}' .'|'.q{[0-9A-Za-z#;/?:@&=+$_.*'\(\)-]} .')';my$RE_ANCHOR_CAR='[\x21-\x2B\x2D-\x5A\x5C\x5E-\x7A\x7C\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';my$RE_PLAIN_START='[\x21\x22\x24-\x39\x3B-\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';my$RE_PLAIN_END='[\x21-\x39\x3B-\x7E\x85\xA0-\x{D7FF}\x{E000}-\x{FEFE}\x{FF00}-\x{FFFD}\x{10000}-\x{10FFFF}]';my$RE_PLAIN_FIRST='[\x24\x28-\x29\x2B\x2E-\x39\x3B-\x3D\x41-\x5A\x5C\x5E-\x5F\x61-\x7A\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';my$RE_PLAIN_START_FLOW='[\x21\x22\x24-\x2B\x2D-\x39\x3B-\x5A\x5C\x5E-\x7A\x7C\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';my$RE_PLAIN_END_FLOW='[\x21-\x2B\x2D-\x39\x3B-\x5A\x5C\x5E-\x7A\x7C\x7E\x85\xA0-\x{D7FF}\x{E000}-\x{FEFE}\x{FF00}-\x{FFFD}\x{10000}-\x{10FFFF}]';my$RE_PLAIN_FIRST_FLOW='[\x24\x28-\x29\x2B\x2E-\x39\x3B-\x3D\x41-\x5A\x5C\x5E-\x5F\x61-\x7A\x7C\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';my$RE_PLAIN_WORD="(?::+$RE_PLAIN_END|$RE_PLAIN_START)(?::+$RE_PLAIN_END|$RE_PLAIN_END)*";my$RE_PLAIN_FIRST_WORD="(?:[:?-]+$RE_PLAIN_END|$RE_PLAIN_FIRST)(?::+$RE_PLAIN_END|$RE_PLAIN_END)*";my$RE_PLAIN_WORDS="(?:$RE_PLAIN_FIRST_WORD(?:$RE_WS+$RE_PLAIN_WORD)*)";my$RE_PLAIN_WORDS2="(?:$RE_PLAIN_WORD(?:$RE_WS+$RE_PLAIN_WORD)*)";my$RE_PLAIN_WORD_FLOW="(?::+$RE_PLAIN_END_FLOW|$RE_PLAIN_START_FLOW)(?::+$RE_PLAIN_END_FLOW|$RE_PLAIN_END_FLOW)*";my$RE_PLAIN_FIRST_WORD_FLOW="(?:[:?-]+$RE_PLAIN_END_FLOW|$RE_PLAIN_FIRST_FLOW)(?::+$RE_PLAIN_END_FLOW|$RE_PLAIN_END_FLOW)*";my$RE_PLAIN_WORDS_FLOW="(?:$RE_PLAIN_FIRST_WORD_FLOW(?:$RE_WS+$RE_PLAIN_WORD_FLOW)*)";my$RE_PLAIN_WORDS_FLOW2="(?:$RE_PLAIN_WORD_FLOW(?:$RE_WS+$RE_PLAIN_WORD_FLOW)*)";my$RE_TAG="!(?:$RE_NS_WORD_CHAR*!$RE_NS_TAG_CHAR+|$RE_NS_TAG_CHAR+|<$RE_URI_CHAR+>|)";my$RE_SEQSTART=qr/\A(-)(?=$RE_WS|$)/m;my$RE_COMPLEX=qr/(\?)(?=$RE_WS|$)/m;my$RE_COMPLEXCOLON=qr/\A(:)(?=$RE_WS|$)/m;my$RE_ANCHOR="&$RE_ANCHOR_CAR+";my$RE_ALIAS="\\*$RE_ANCHOR_CAR+";my%REGEXES=(ANCHOR=>qr{($RE_ANCHOR)},TAG=>qr{($RE_TAG)},ALIAS=>qr{($RE_ALIAS)},SINGLEQUOTED=>qr{(?:''|[^'\r\n]+)*},);sub fetch_next_line {my ($self)=@_;my$next_line=$self->next_line;if (defined$next_line){return$next_line}my$line=$self->reader->readline;unless (defined$line){$self->set_next_line(undef);return}$self->inc_line;$line =~ m/\A( *)([^\r\n]*)([\r\n]|\z)/ or die "Unexpected";$next_line=[$1,$2,$3 ];$self->set_next_line($next_line);if ($line =~ tr/\x00-\x08\x0b-\x0c\x0e-\x1f//){$self->exception("Control characters are not allowed")}return$next_line}my%TOKEN_NAMES=('"'=>'DOUBLEQUOTE',"'"=>'SINGLEQUOTE','|'=>'LITERAL','>'=>'FOLDED','!'=>'TAG','*'=>'ALIAS','&'=>'ANCHOR',':'=>'COLON','-'=>'DASH','?'=>'QUESTION','['=>'FLOWSEQ_START',']'=>'FLOWSEQ_END','{'=>'FLOWMAP_START','}'=>'FLOWMAP_END',','=>'FLOW_COMMA','---'=>'DOC_START','...'=>'DOC_END',);sub fetch_next_tokens {my ($self)=@_;my$next=$self->next_tokens;return$next if @$next;my$next_line=$self->fetch_next_line;if (not $next_line){return []}my$spaces=$next_line->[0];my$yaml=\$next_line->[1];if (not length $$yaml){$self->push_tokens([EOL=>join('',@$next_line),$self->line ]);$self->set_next_line(undef);return$next}if (substr($$yaml,0,1)eq '#'){$self->push_tokens([EOL=>join('',@$next_line),$self->line ]);$self->set_next_line(undef);return$next}if (not $spaces and substr($$yaml,0,1)eq "%"){$self->_fetch_next_tokens_directive($yaml,$next_line->[2]);$self->set_context(0);$self->set_next_line(undef);return$next}if (not $spaces and $$yaml =~ s/\A(---|\.\.\.)(?=$RE_WS|\z)//){$self->push_tokens([$TOKEN_NAMES{$1 }=>$1,$self->line ])}elsif ($$yaml =~ m/\A[ \t]+(#.*)?\z/){$self->push_tokens([EOL=>join('',@$next_line),$self->line ]);$self->set_next_line(undef);return$next}else {$self->push_tokens([SPACE=>$spaces,$self->line ])}my$partial=$self->_fetch_next_tokens($next_line);unless ($partial){$self->set_next_line(undef)}return$next}my%ANCHOR_ALIAS_TAG=('&'=>1,'*'=>1,'!'=>1);my%BLOCK_SCALAR=('|'=>1,'>'=>1);my%COLON_DASH_QUESTION=(':'=>1,'-'=>1,'?'=>1);my%QUOTED=('"'=>1,"'"=>1);my%FLOW=('{'=>1,'['=>1,'}'=>1,']'=>1,','=>1);my%CONTEXT=('"'=>1,"'"=>1,'>'=>1,'|'=>1);my$RE_ESCAPES=qr{(?:
      \\([ \\\/_0abefnrtvLNP"]) | \\x([0-9a-fA-F]{2})
      | \\u([A-Fa-f0-9]{4}) | \\U([A-Fa-f0-9]{4,8})
  )}x;my%CONTROL=('\\'=>'\\','/'=>'/',n=>"\n",t=>"\t",r=>"\r",b=>"\b",'a'=>"\a",'b'=>"\b",'e'=>"\e",'f'=>"\f",'v'=>"\x0b",'P'=>"\x{2029}",L=>"\x{2028}",'N'=>"\x85",'0'=>"\0",'_'=>"\xa0",' '=>' ',q/"/=>q/"/,);sub _fetch_next_tokens {TRACE and warn __PACKAGE__.':'.__LINE__.": _fetch_next_tokens\n";my ($self,$next_line)=@_;my$yaml=\$next_line->[1];my$eol=$next_line->[2];my@tokens;while (1){unless (length $$yaml){push@tokens,(EOL=>$eol,$self->line);$self->push_tokens(\@tokens);return}my$first=substr($$yaml,0,1);my$plain=0;if ($self->context){if ($$yaml =~ s/\A($RE_WS*)://){push@tokens,(WS=>$1,$self->line)if $1;push@tokens,(COLON=>':',$self->line);$self->set_context(0);next}if ($$yaml =~ s/\A($RE_WS*(?: #.*))\z//){push@tokens,(EOL=>$1 .$eol,$self->line);$self->push_tokens(\@tokens);return}$self->set_context(0)}if ($CONTEXT{$first }){push@tokens,(CONTEXT=>$first,$self->line);$self->push_tokens(\@tokens);return 1}elsif ($COLON_DASH_QUESTION{$first }){my$token_name=$TOKEN_NAMES{$first };if ($$yaml =~ s/\A\Q$first\E(?:($RE_WS+)|\z)//){my$token_name=$TOKEN_NAMES{$first };push@tokens,($token_name=>$first,$self->line);if (not defined $1){push@tokens,(EOL=>$eol,$self->line);$self->push_tokens(\@tokens);return}my$ws=$1;if ($$yaml =~ s/\A(#.*|)\z//){push@tokens,(EOL=>$ws .$1 .$eol,$self->line);$self->push_tokens(\@tokens);return}push@tokens,(WS=>$ws,$self->line);next}elsif ($self->flowcontext and $$yaml =~ s/\A:(?=[,\{\}\[\]])//){push@tokens,($token_name=>$first,$self->line);next}$plain=1}elsif ($ANCHOR_ALIAS_TAG{$first }){my$token_name=$TOKEN_NAMES{$first };my$REGEX=$REGEXES{$token_name };if ($$yaml =~ s/\A$REGEX//){push@tokens,($token_name=>$1,$self->line)}else {push@tokens,("Invalid $token_name"=>$$yaml,$self->line);$self->push_tokens(\@tokens);return}}elsif ($first eq ' ' or $first eq "\t"){if ($$yaml =~ s/\A($RE_WS+)//){my$ws=$1;if ($$yaml =~ s/\A((?:#.*)?\z)//){push@tokens,(EOL=>$ws .$1 .$eol,$self->line);$self->push_tokens(\@tokens);return}push@tokens,(WS=>$ws,$self->line)}}elsif ($FLOW{$first }){push@tokens,($TOKEN_NAMES{$first }=>$first,$self->line);substr($$yaml,0,1,'');my$flowcontext=$self->flowcontext;if ($first eq '{' or $first eq '['){$self->set_flowcontext(++$flowcontext)}elsif ($first eq '}' or $first eq ']'){$self->set_flowcontext(--$flowcontext)}}else {$plain=1}if ($plain){push@tokens,(CONTEXT=>'',$self->line);$self->push_tokens(\@tokens);return 1}}return}sub fetch_plain {my ($self,$indent,$context)=@_;my$next_line=$self->next_line;my$yaml=\$next_line->[1];my$eol=$next_line->[2];my$REGEX=$RE_PLAIN_WORDS;if ($self->flowcontext){$REGEX=$RE_PLAIN_WORDS_FLOW}my@tokens;unless ($$yaml =~ s/\A($REGEX)//){$self->push_tokens(\@tokens);$self->exception("Invalid plain scalar")}my$plain=$1;push@tokens,(PLAIN=>$plain,$self->line);if ($$yaml =~ s/\A(?:($RE_WS+#.*)|($RE_WS*))\z//){if (defined $1){push@tokens,(EOL=>$1 .$eol,$self->line);$self->push_tokens(\@tokens);$self->set_next_line(undef);return}else {push@tokens,(EOL=>$2.$eol,$self->line);$self->set_next_line(undef)}}else {$self->push_tokens(\@tokens);my$partial=$self->_fetch_next_tokens($next_line);if (not $partial){$self->set_next_line(undef)}return}my$RE2=$RE_PLAIN_WORDS2;if ($self->flowcontext){$RE2=$RE_PLAIN_WORDS_FLOW2}my$fetch_next=0;my@lines=($plain);my@next;LOOP: while (1){$next_line=$self->fetch_next_line;if (not $next_line){last LOOP}my$spaces=$next_line->[0];my$yaml=\$next_line->[1];my$eol=$next_line->[2];if (not length $$yaml){push@tokens,(EOL=>$spaces .$eol,$self->line);$self->set_next_line(undef);push@lines,'';next LOOP}if (not $spaces and $$yaml =~ s/\A(---|\.\.\.)(?=$RE_WS|\z)//){push@next,$TOKEN_NAMES{$1 }=>$1,$self->line;$fetch_next=1;last LOOP}if ((length$spaces)< $indent){last LOOP}my$ws='';if ($$yaml =~ s/\A($RE_WS+)//){$ws=$1}if (not length $$yaml){push@tokens,(EOL=>$spaces .$ws .$eol,$self->line);$self->set_next_line(undef);push@lines,'';next LOOP}if ($$yaml =~ s/\A(#.*)\z//){push@tokens,(EOL=>$spaces .$ws .$1 .$eol,$self->line);$self->set_next_line(undef);last LOOP}if ($$yaml =~ s/\A($RE2)//){push@tokens,INDENT=>$spaces,$self->line;push@tokens,WS=>$ws,$self->line;push@tokens,PLAIN=>$1,$self->line;push@lines,$1;my$ws='';if ($$yaml =~ s/\A($RE_WS+)//){$ws=$1}if (not length $$yaml){push@tokens,EOL=>$ws .$eol,$self->line;$self->set_next_line(undef);next LOOP}if ($$yaml =~ s/\A(#.*)\z//){push@tokens,EOL=>$ws .$1 .$eol,$self->line;$self->set_next_line(undef);last LOOP}else {push@tokens,WS=>$ws,$self->line if$ws;$fetch_next=1}}else {push@tokens,SPACE=>$spaces,$self->line;push@tokens,WS=>$ws,$self->line;if ($self->flowcontext){$fetch_next=1}else {push@tokens,ERROR=>$$yaml,$self->line}}last LOOP}while (@lines > 1 and $lines[-1]eq ''){pop@lines}if (@lines > 1){my$value=YAML::PP::Render->render_multi_val(\@lines);my@eol;if ($tokens[-3]eq 'EOL'){@eol=splice@tokens,-3}$self->push_subtokens({name=>'PLAIN_MULTI',value=>$value },\@tokens);$self->push_tokens([@eol,@next ])}else {$self->push_tokens([@tokens,@next ])}@tokens=();if ($fetch_next){my$partial=$self->_fetch_next_tokens($next_line);if (not $partial){$self->set_next_line(undef)}}return}sub fetch_block {my ($self,$indent,$context)=@_;my$next_line=$self->next_line;my$yaml=\$next_line->[1];my$eol=$next_line->[2];my@tokens;my$token_name=$TOKEN_NAMES{$context };$$yaml =~ s/\A\Q$context\E// or die "Unexpected";push@tokens,($token_name=>$context,$self->line);my$current_indent=$indent;my$started=0;my$set_indent=0;my$chomp='';if ($$yaml =~ s/\A([1-9]\d*)([+-]?)//){push@tokens,(BLOCK_SCALAR_INDENT=>$1,$self->line);$set_indent=$1;$chomp=$2 if $2;push@tokens,(BLOCK_SCALAR_CHOMP=>$2,$self->line)if $2}elsif ($$yaml =~ s/\A([+-])([1-9]\d*)?//){push@tokens,(BLOCK_SCALAR_CHOMP=>$1,$self->line);$chomp=$1;push@tokens,(BLOCK_SCALAR_INDENT=>$2,$self->line)if $2;$set_indent=$2 if $2}if ($set_indent){$started=1;$indent-- if$indent > 0;$current_indent=$indent + $set_indent}if (not length $$yaml){push@tokens,(EOL=>$eol,$self->line)}elsif ($$yaml =~ s/\A($RE_WS*(?:$RE_WS#.*|))\z//){push@tokens,(EOL=>$1 .$eol,$self->line)}else {$self->push_tokens(\@tokens);$self->exception("Invalid block scalar")}my@lines;while (1){$self->set_next_line(undef);$next_line=$self->fetch_next_line;if (not $next_line){last}my$spaces=$next_line->[0];my$content=$next_line->[1];my$eol=$next_line->[2];if (not $spaces and $content =~ m/\A(---|\.\.\.)(?=$RE_WS|\z)/){last}if ((length$spaces)< $current_indent){if (length$content){last}else {push@lines,'';push@tokens,(EOL=>$spaces .$eol,$self->line);next}}if ((length$spaces)> $current_indent){if ($started){($spaces,my$more_spaces)=unpack "a${current_indent}a*",$spaces;$content=$more_spaces .$content}}unless (length$content){push@lines,'';push@tokens,(INDENT=>$spaces,$self->line,EOL=>$eol,$self->line);unless ($started){$current_indent=length$spaces}next}unless ($started){$started=1;$current_indent=length$spaces}push@lines,$content;push@tokens,(INDENT=>$spaces,$self->line,BLOCK_SCALAR_CONTENT=>$content,$self->line,EOL=>$eol,$self->line,)}my$value=YAML::PP::Render->render_block_scalar($context,$chomp,\@lines);my@eol=splice@tokens,-3;$self->push_subtokens({name=>'BLOCK_SCALAR',value=>$value },\@tokens);$self->push_tokens([@eol ]);return 0}sub fetch_quoted {my ($self,$indent,$context)=@_;my$next_line=$self->next_line;my$yaml=\$next_line->[1];my$spaces=$next_line->[0];my$token_name=$TOKEN_NAMES{$context };$$yaml =~ s/\A\Q$context// or die "Unexpected";;my@tokens=($token_name=>$context,$self->line);my$start=1;my@values;while (1){unless ($start){$next_line=$self->fetch_next_line or do {for (my$i=0;$i < @tokens;$i+= 3){my$token=$tokens[$i + 1 ];if (ref$token){$tokens[$i + 1 ]=$token->{orig}}}$self->push_tokens(\@tokens);$self->exception("Missing closing quote <$context> at EOF")};$start=0;$spaces=$next_line->[0];$yaml=\$next_line->[1];if (not length $$yaml){push@tokens,(EOL=>$spaces .$next_line->[2],$self->line);$self->set_next_line(undef);push@values,{value=>'',orig=>'' };next}elsif (not $spaces and $$yaml =~ m/\A(---|\.\.\.)(?=$RE_WS|\z)/){for (my$i=0;$i < @tokens;$i+= 3){my$token=$tokens[$i + 1 ];if (ref$token){$tokens[$i + 1 ]=$token->{orig}}}$self->push_tokens(\@tokens);$self->exception("Missing closing quote <$context> or invalid document marker")}elsif ((length$spaces)< $indent){for (my$i=0;$i < @tokens;$i+= 3){my$token=$tokens[$i + 1 ];if (ref$token){$tokens[$i + 1 ]=$token->{orig}}}$self->push_tokens(\@tokens);$self->exception("Wrong indendation or missing closing quote <$context>")}if ($$yaml =~ s/\A($RE_WS+)//){$spaces .= $1}push@tokens,(WS=>$spaces,$self->line)}my$v=$self->_read_quoted_tokens($start,$context,$yaml,\@tokens);push@values,$v;if ($tokens[-3]eq $token_name){if ($start){$self->push_subtokens({name=>'QUOTED',value=>$v->{value}},\@tokens)}else {my$value=YAML::PP::Render->render_quoted($context,\@values);$self->push_subtokens({name=>'QUOTED_MULTILINE',value=>$value },\@tokens)}$self->set_context(1)if$self->flowcontext;if (length $$yaml){my$partial=$self->_fetch_next_tokens($next_line);if (not $partial){$self->set_next_line(undef)}return 0}else {@tokens=();push@tokens,(EOL=>$next_line->[2],$self->line);$self->push_tokens(\@tokens);$self->set_next_line(undef);return}}$tokens[-2].= $next_line->[2];$self->set_next_line(undef);$start=0}}sub _read_quoted_tokens {my ($self,$start,$first,$yaml,$tokens)=@_;my$quoted='';my$decoded='';my$token_name=$TOKEN_NAMES{$first };if ($first eq "'"){my$regex=$REGEXES{SINGLEQUOTED};if ($$yaml =~ s/\A($regex)//){$quoted .= $1;$decoded .= $1;$decoded =~ s/''/'/g}}else {($quoted,$decoded)=$self->_read_doublequoted($yaml)}my$eol='';unless (length $$yaml){if ($quoted =~ s/($RE_WS+)\z//){$eol=$1;$decoded =~ s/($eol)\z//}}my$value={value=>$decoded,orig=>$quoted };if ($$yaml =~ s/\A$first//){if ($start){push @$tokens,($token_name .'D'=>$value,$self->line)}else {push @$tokens,($token_name .'D_LINE'=>$value,$self->line)}push @$tokens,($token_name=>$first,$self->line);return$value}if (length $$yaml){push @$tokens,($token_name .'D'=>$value->{orig},$self->line);$self->push_tokens($tokens);$self->exception("Invalid quoted <$first> string")}push @$tokens,($token_name .'D_LINE'=>$value,$self->line);push @$tokens,(EOL=>$eol,$self->line);return$value}sub _read_doublequoted {my ($self,$yaml)=@_;my$quoted='';my$decoded='';while (1){my$last=1;if ($$yaml =~ s/\A([^"\\]+)//){$quoted .= $1;$decoded .= $1;$last=0}if ($$yaml =~ s/\A($RE_ESCAPES)//){$quoted .= $1;my$dec=defined $2 ? $CONTROL{$2 }: defined $3 ? chr hex $3 : defined $4 ? chr hex $4 : chr hex $5;$decoded .= $dec;$last=0}if ($$yaml =~ s/\A(\\)\z//){$quoted .= $1;$decoded .= $1;last}last if$last}return ($quoted,$decoded)}sub _fetch_next_tokens_directive {my ($self,$yaml,$eol)=@_;my@tokens;if ($$yaml =~ s/\A(\s*%YAML)//){my$dir=$1;if ($$yaml =~ s/\A( )//){$dir .= $1;if ($$yaml =~ s/\A(1\.[12]$RE_WS*)//){$dir .= $1;push@tokens,(YAML_DIRECTIVE=>$dir,$self->line)}else {$$yaml =~ s/\A(.*)//;$dir .= $1;my$warn=$ENV{YAML_PP_RESERVED_DIRECTIVE}|| 'warn';if ($warn eq 'warn'){warn "Found reserved directive '$dir'"}elsif ($warn eq 'fatal'){die "Found reserved directive '$dir'"}push@tokens,(RESERVED_DIRECTIVE=>"$dir",$self->line)}}else {$$yaml =~ s/\A(.*)//;$dir .= $1;push@tokens,('Invalid directive'=>$dir,$self->line);push@tokens,(EOL=>$eol,$self->line);$self->push_tokens(\@tokens);return}}elsif ($$yaml =~ s/\A(\s*%TAG +(!$RE_NS_WORD_CHAR*!|!) +(tag:\S+|!$RE_URI_CHAR+)$RE_WS*)//){push@tokens,(TAG_DIRECTIVE=>$1,$self->line);my$tag_alias=$2;my$tag_url=$3}elsif ($$yaml =~ s/\A(\s*\A%(?:\w+).*)//){push@tokens,(RESERVED_DIRECTIVE=>$1,$self->line);my$warn=$ENV{YAML_PP_RESERVED_DIRECTIVE}|| 'warn';if ($warn eq 'warn'){warn "Found reserved directive '$1'"}elsif ($warn eq 'fatal'){die "Found reserved directive '$1'"}}else {push@tokens,('Invalid directive'=>$$yaml,$self->line);push@tokens,(EOL=>$eol,$self->line);$self->push_tokens(\@tokens);return}if (not length $$yaml){push@tokens,(EOL=>$eol,$self->line)}else {push@tokens,('Invalid directive'=>$$yaml,$self->line);push@tokens,(EOL=>$eol,$self->line)}$self->push_tokens(\@tokens);return}sub push_tokens {my ($self,$new_tokens)=@_;my$next=$self->next_tokens;my$line=$self->line;my$column=$self->offset;for (my$i=0;$i < @$new_tokens;$i += 3){my$value=$new_tokens->[$i + 1 ];my$name=$new_tokens->[$i ];my$line=$new_tokens->[$i + 2 ];my$push={name=>$name,line=>$line,column=>$column,value=>$value,};$column += length$value unless$name eq 'CONTEXT';push @$next,$push;if ($name eq 'EOL'){$column=0}}$self->set_offset($column);return$next}sub push_subtokens {my ($self,$token,$subtokens)=@_;my$next=$self->next_tokens;my$line=$self->line;my$column=$self->offset;$token->{column}=$column;$token->{subtokens}=\my@sub;for (my$i=0;$i < @$subtokens;$i+=3){my$name=$subtokens->[$i ];my$value=$subtokens->[$i + 1 ];my$line=$subtokens->[$i + 2 ];my$push={name=>$subtokens->[$i ],line=>$line,column=>$column,};if (ref$value eq 'HASH'){%$push=(%$push,%$value);$column += length$value->{orig}}else {$push->{value}=$value;$column += length$value}if ($push->{name}eq 'EOL'){$column=0}push@sub,$push}$token->{line}=$sub[0]->{line};push @$next,$token;$self->set_offset($column);return$next}sub exception {my ($self,$msg)=@_;my$next=$self->next_tokens;$next=[];my$line=@$next ? $next->[0]->{line}: $self->line;my@caller=caller(0);my$yaml='';if (my$nl=$self->next_line){$yaml=join '',@$nl;$yaml=$nl->[1]}my$e=YAML::PP::Exception->new(line=>$line,column=>$self->offset + 1,msg=>$msg,next=>$next,where=>$caller[1].' line ' .$caller[2],yaml=>$yaml,);croak$e}1;
YAML_PP_LEXER

$fatpacked{"YAML/PP/Loader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_LOADER';
  use strict;use warnings;package YAML::PP::Loader;our$VERSION='0.030';use YAML::PP::Parser;use YAML::PP::Constructor;use YAML::PP::Reader;sub new {my ($class,%args)=@_;my$cyclic_refs=delete$args{cyclic_refs}|| 'allow';my$default_yaml_version=delete$args{default_yaml_version}|| '1.2';my$preserve=delete$args{preserve};my$duplicate_keys=delete$args{duplicate_keys};my$schemas=delete$args{schemas};$schemas ||= {'1.2'=>YAML::PP->default_schema(boolean=>'perl',)};my$constructor=delete$args{constructor}|| YAML::PP::Constructor->new(schemas=>$schemas,cyclic_refs=>$cyclic_refs,default_yaml_version=>$default_yaml_version,preserve=>$preserve,duplicate_keys=>$duplicate_keys,);my$parser=delete$args{parser};unless ($parser){$parser=YAML::PP::Parser->new(default_yaml_version=>$default_yaml_version,)}unless ($parser->receiver){$parser->set_receiver($constructor)}if (keys%args){die "Unexpected arguments: " .join ', ',sort keys%args}my$self=bless {parser=>$parser,constructor=>$constructor,},$class;return$self}sub clone {my ($self)=@_;my$clone={parser=>$self->parser->clone,constructor=>$self->constructor->clone,};bless$clone,ref$self;$clone->parser->set_receiver($clone->constructor);return$clone}sub parser {return $_[0]->{parser}}sub constructor {return $_[0]->{constructor}}sub filename {my ($self)=@_;my$reader=$self->parser->reader;if ($reader->isa('YAML::PP::Reader::File')){return$reader->input}die "Reader is not a YAML::PP::Reader::File"}sub load_string {my ($self,$yaml)=@_;$self->parser->set_reader(YAML::PP::Reader->new(input=>$yaml));$self->load()}sub load_file {my ($self,$file)=@_;$self->parser->set_reader(YAML::PP::Reader::File->new(input=>$file));$self->load()}sub load {my ($self)=@_;my$parser=$self->parser;my$constructor=$self->constructor;$constructor->init;$parser->parse();my$docs=$constructor->docs;return wantarray ? @$docs : $docs->[0]}1;
YAML_PP_LOADER

$fatpacked{"YAML/PP/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_PARSER';
  use strict;use warnings;package YAML::PP::Parser;our$VERSION='0.030';use constant TRACE=>$ENV{YAML_PP_TRACE}? 1 : 0;use constant DEBUG=>($ENV{YAML_PP_DEBUG}|| $ENV{YAML_PP_TRACE})? 1 : 0;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE YAML_DOUBLE_QUOTED_SCALAR_STYLE YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE YAML_FLOW_SEQUENCE_STYLE YAML_FLOW_MAPPING_STYLE/;use YAML::PP::Render;use YAML::PP::Lexer;use YAML::PP::Grammar qw/$GRAMMAR/;use YAML::PP::Exception;use YAML::PP::Reader;use Carp qw/croak/;sub new {my ($class,%args)=@_;my$reader=delete$args{reader}|| YAML::PP::Reader->new;my$default_yaml_version=delete$args{default_yaml_version};my$self=bless {default_yaml_version=>$default_yaml_version || '1.2',lexer=>YAML::PP::Lexer->new(reader=>$reader,),},$class;my$receiver=delete$args{receiver};if ($receiver){$self->set_receiver($receiver)}return$self}sub clone {my ($self)=@_;my$clone={default_yaml_version=>$self->default_yaml_version,lexer=>YAML::PP::Lexer->new(),};return bless$clone,ref$self}sub receiver {return $_[0]->{receiver}}sub set_receiver {my ($self,$receiver)=@_;my$callback;if (ref$receiver eq 'CODE'){$callback=$receiver}else {$callback=sub {my ($self,$event,$info)=@_;return$receiver->$event($info)}}$self->{callback}=$callback;$self->{receiver}=$receiver}sub reader {return $_[0]->lexer->{reader}}sub set_reader {my ($self,$reader)=@_;$self->lexer->set_reader($reader)}sub lexer {return $_[0]->{lexer}}sub callback {return $_[0]->{callback}}sub set_callback {$_[0]->{callback}=$_[1]}sub level {return $#{$_[0]->{offset}}}sub offset {return $_[0]->{offset}}sub set_offset {$_[0]->{offset}=$_[1]}sub events {return $_[0]->{events}}sub set_events {$_[0]->{events}=$_[1]}sub new_node {return $_[0]->{new_node}}sub set_new_node {$_[0]->{new_node}=$_[1]}sub tagmap {return $_[0]->{tagmap}}sub set_tagmap {$_[0]->{tagmap}=$_[1]}sub tokens {return $_[0]->{tokens}}sub set_tokens {$_[0]->{tokens}=$_[1]}sub event_stack {return $_[0]->{event_stack}}sub set_event_stack {$_[0]->{event_stack}=$_[1]}sub default_yaml_version {return $_[0]->{default_yaml_version}}sub yaml_version {return $_[0]->{yaml_version}}sub set_yaml_version {$_[0]->{yaml_version}=$_[1]}sub yaml_version_directive {return $_[0]->{yaml_version_directive}}sub set_yaml_version_directive {$_[0]->{yaml_version_directive}=$_[1]}sub rule {return $_[0]->{rule}}sub set_rule {my ($self,$name)=@_;no warnings 'uninitialized';DEBUG and $self->info("set_rule($name)");$self->{rule}=$name}sub init {my ($self)=@_;$self->set_offset([]);$self->set_events([]);$self->set_new_node(0);$self->set_tagmap({'!!'=>"tag:yaml.org,2002:",});$self->set_tokens([]);$self->set_rule(undef);$self->set_event_stack([]);$self->set_yaml_version($self->default_yaml_version);$self->set_yaml_version_directive(undef);$self->lexer->init}sub parse_string {my ($self,$yaml)=@_;$self->set_reader(YAML::PP::Reader->new(input=>$yaml));$self->parse()}sub parse_file {my ($self,$file)=@_;$self->set_reader(YAML::PP::Reader::File->new(input=>$file));$self->parse()}my%nodetypes=(MAPVALUE=>'NODETYPE_COMPLEX',MAP=>'NODETYPE_MAP',SEQ=>'NODETYPE_SEQ',SEQ0=>'NODETYPE_SEQ',FLOWMAP=>'NODETYPE_FLOWMAP',FLOWMAPVALUE=>'NODETYPE_FLOWMAPVALUE',FLOWSEQ=>'NODETYPE_FLOWSEQ',FLOWSEQ_NEXT=>'FLOWSEQ_NEXT',DOC=>'FULLNODE',DOC_END=>'DOCUMENT_END',STR=>'STREAM',END_FLOW=>'END_FLOW',);sub parse {my ($self)=@_;TRACE and warn "=== parse()\n";TRACE and $self->debug_yaml;$self->init;$self->lexer->init;eval {$self->start_stream;$self->set_rule('STREAM');$self->parse_tokens();$self->end_stream};if (my$error=$@){if (ref$error){croak "$error\n "}croak$error}DEBUG and $self->highlight_yaml;TRACE and $self->debug_tokens}sub lex_next_tokens {my ($self)=@_;DEBUG and $self->info("----------------> lex_next_tokens");TRACE and $self->debug_events;my$indent=$self->offset->[-1];my$event_types=$self->events;my$next_tokens=$self->lexer->fetch_next_tokens($indent);return unless @$next_tokens;my$next=$next_tokens->[0];return 1 if ($next->{name}ne 'SPACE');my$flow=$event_types->[-1]=~ m/^FLOW/;my$space=length$next->{value};my$tokens=$self->tokens;if (not $space){shift @$next_tokens}else {push @$tokens,shift @$next_tokens}if ($flow){if ($space >= $indent){return 1}$self->exception("Bad indendation in " .$self->events->[-1])}$next=$next_tokens->[0];if ($space > $indent){return 1 if$indent < 0;unless ($self->new_node){$self->exception("Bad indendation in " .$self->events->[-1])}return 1}if ($self->new_node){if ($space < $indent){$self->scalar_event({style=>YAML_PLAIN_SCALAR_STYLE,value=>'' });$self->remove_nodes($space)}else {my$exp=$self->events->[-1];my$seq_start=$next->{name}eq 'DASH';if ($seq_start and ($exp eq 'MAPVALUE' or $exp eq 'MAP')){}else {$self->scalar_event({style=>YAML_PLAIN_SCALAR_STYLE,value=>'' })}}}else {if ($space < $indent){$self->remove_nodes($space)}}my$exp=$self->events->[-1];if ($exp eq 'SEQ0' and $next->{name}ne 'DASH'){TRACE and $self->info("In unindented sequence");$self->end_sequence;$exp=$self->events->[-1]}if ($self->offset->[-1]!=$space){$self->exception("Expected " .$self->events->[-1])}return 1}my%next_event=(MAP=>'MAPVALUE',IMAP=>'IMAPVALUE',MAPVALUE=>'MAP',IMAPVALUE=>'IMAP',SEQ=>'SEQ',SEQ0=>'SEQ0',DOC=>'DOC_END',STR=>'STR',FLOWSEQ=>'FLOWSEQ_NEXT',FLOWSEQ_NEXT=>'FLOWSEQ',FLOWMAP=>'FLOWMAPVALUE',FLOWMAPVALUE=>'FLOWMAP',);my%event_to_method=(MAP=>'mapping',IMAP=>'mapping',FLOWMAP=>'mapping',SEQ=>'sequence',SEQ0=>'sequence',FLOWSEQ=>'sequence',DOC=>'document',STR=>'stream',VAL=>'scalar',ALI=>'alias',MAPVALUE=>'mapping',IMAPVALUE=>'mapping',);my%fetch_method=('"'=>'fetch_quoted',"'"=>'fetch_quoted','|'=>'fetch_block','>'=>'fetch_block',''=>'fetch_plain',);sub parse_tokens {my ($self)=@_;my$event_types=$self->events;my$offsets=$self->offset;my$tokens=$self->tokens;my$next_tokens=$self->lexer->next_tokens;unless ($self->lex_next_tokens){$self->end_document(1);return 0}unless ($self->new_node){if ($self->level > 0){my$new_rule=$nodetypes{$event_types->[-1]}or die "Did not find '$event_types->[-1]'";$self->set_rule($new_rule)}}my$rule_name=$self->rule;DEBUG and $self->info("----------------> parse_tokens($rule_name)");my$rule=$GRAMMAR->{$rule_name }or die "Could not find rule $rule_name";TRACE and $self->debug_rules($rule);TRACE and $self->debug_yaml;DEBUG and $self->debug_next_line;RULE: while ($rule_name){DEBUG and $self->info("RULE: $rule_name");TRACE and $self->debug_tokens($next_tokens);unless (@$next_tokens){$self->exception("No more tokens")}TRACE and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$next_tokens->[0]],['next_token']);my$got=$next_tokens->[0]->{name};if ($got eq 'CONTEXT'){my$context=shift @$next_tokens;my$indent=$offsets->[-1];$indent++ unless$self->lexer->flowcontext;my$method=$fetch_method{$context->{value}};my$partial=$self->lexer->$method($indent,$context->{value});next RULE}my$def=$rule->{$got };if ($def){push @$tokens,shift @$next_tokens}elsif ($def=$rule->{DEFAULT}){$got='DEFAULT'}else {$self->expected(expected=>[keys %$rule],got=>$next_tokens->[0],)}DEBUG and $self->got("---got $got");if (my$sub=$def->{match}){DEBUG and $self->info("CALLBACK $sub");$self->$sub(@$tokens ? $tokens->[-1]: ())}my$eol=$got eq 'EOL';my$new=$def->{new};if ($new){DEBUG and $self->got("NEW: $new");$rule_name=$new;$self->set_rule($rule_name)}elsif ($eol){}elsif ($def->{return}){$rule_name=$nodetypes{$event_types->[-1]}or die "Unexpected event type $event_types->[-1]";$self->set_rule($rule_name)}else {$rule_name .= " - $got";$rule=$def;next RULE}if ($eol){unless ($self->lex_next_tokens){if ($rule_name eq 'DIRECTIVE'){$self->exception("Directive needs document start")}$self->end_document(1);return 0}unless ($self->new_node){if ($self->level > 0){$rule_name=$nodetypes{$event_types->[-1]}or die "Did not find '$event_types->[-1]'";$self->set_rule($rule_name)}}$rule_name=$self->rule}$rule=$GRAMMAR->{$rule_name }or die "Unexpected rule $rule_name"}die "Unexpected"}sub end_sequence {my ($self)=@_;my$event_types=$self->events;pop @{$event_types};pop @{$self->offset};my$info={name=>'sequence_end_event' };$self->callback->($self,$info->{name}=>$info);$event_types->[-1]=$next_event{$event_types->[-1]}}sub remove_nodes {my ($self,$space)=@_;my$offset=$self->offset;my$event_types=$self->events;my$exp=$event_types->[-1];while (@$offset){if ($offset->[-1 ]<= $space){last}if ($exp eq 'MAPVALUE'){$self->scalar_event({style=>YAML_PLAIN_SCALAR_STYLE,value=>'' });$exp='MAP'}my$info={name=>$exp };$info->{name}=$event_to_method{$exp }.'_end_event';pop @{$event_types};pop @{$offset};$self->callback->($self,$info->{name}=>$info);$event_types->[-1]=$next_event{$event_types->[-1]};$exp=$event_types->[-1]}return$exp}sub start_stream {my ($self)=@_;push @{$self->events},'STR';push @{$self->offset},-1;$self->callback->($self,'stream_start_event',{name=>'stream_start_event',})}sub start_document {my ($self,$implicit)=@_;push @{$self->events},'DOC';push @{$self->offset},-1;my$directive=$self->yaml_version_directive;my%directive;if ($directive){my ($major,$minor)=split m/\./,$self->yaml_version;%directive=(version_directive=>{major=>$major,minor=>$minor })}$self->callback->($self,'document_start_event',{name=>'document_start_event',implicit=>$implicit,%directive,});$self->set_yaml_version_directive(undef);$self->set_rule('FULLNODE');$self->set_new_node(1)}sub start_sequence {my ($self,$offset)=@_;my$offsets=$self->offset;if ($offsets->[-1]==$offset){push @{$self->events},'SEQ0'}else {push @{$self->events},'SEQ'}push @{$offsets},$offset;my$event_stack=$self->event_stack;my$info={name=>'sequence_start_event' };if (@$event_stack and $event_stack->[-1]->[0]eq 'properties'){my$properties=pop @$event_stack;$self->node_properties($properties->[1],$info)}$self->callback->($self,'sequence_start_event',$info)}sub start_flow_sequence {my ($self,$offset)=@_;my$offsets=$self->offset;my$new_offset=$offsets->[-1];my$event_types=$self->events;if ($new_offset < 0){$new_offset=0}elsif ($self->new_node){if ($event_types->[-1]!~ m/^FLOW/){$new_offset++}}push @{$self->events},'FLOWSEQ';push @{$offsets},$new_offset;my$event_stack=$self->event_stack;my$info={style=>YAML_FLOW_SEQUENCE_STYLE,name=>'sequence_start_event' };if (@$event_stack and $event_stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($event_stack,$info)}$self->callback->($self,'sequence_start_event',$info)}sub start_flow_mapping {my ($self,$offset,$implicit_flowseq_map)=@_;my$offsets=$self->offset;my$new_offset=$offsets->[-1];my$event_types=$self->events;if ($new_offset < 0){$new_offset=0}elsif ($self->new_node){if ($event_types->[-1]!~ m/^FLOW/){$new_offset++}}push @{$self->events},$implicit_flowseq_map ? 'IMAP' : 'FLOWMAP';push @{$offsets},$new_offset;my$event_stack=$self->event_stack;my$info={name=>'mapping_start_event',style=>YAML_FLOW_MAPPING_STYLE };if (@$event_stack and $event_stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($event_stack,$info)}$self->callback->($self,'mapping_start_event',$info)}sub end_flow_sequence {my ($self)=@_;my$event_types=$self->events;pop @{$event_types};pop @{$self->offset};my$info={name=>'sequence_end_event' };$self->callback->($self,$info->{name},$info);if ($event_types->[-1]=~ m/^FLOW|^IMAP/){$event_types->[-1]=$next_event{$event_types->[-1]}}else {push @$event_types,'END_FLOW'}}sub end_flow_mapping {my ($self)=@_;my$event_types=$self->events;pop @{$event_types};pop @{$self->offset};my$info={name=>'mapping_end_event' };$self->callback->($self,$info->{name},$info);if ($event_types->[-1]=~ m/^FLOW|^IMAP/){$event_types->[-1]=$next_event{$event_types->[-1]}}else {push @$event_types,'END_FLOW'}}sub cb_end_outer_flow {my ($self)=@_;my$event_types=$self->events;pop @$event_types;$event_types->[-1]=$next_event{$event_types->[-1]}}sub start_mapping {my ($self,$offset)=@_;my$offsets=$self->offset;push @{$self->events},'MAP';push @{$offsets},$offset;my$event_stack=$self->event_stack;my$info={name=>'mapping_start_event' };if (@$event_stack and $event_stack->[-1]->[0]eq 'properties'){my$properties=pop @$event_stack;$self->node_properties($properties->[1],$info)}$self->callback->($self,'mapping_start_event',$info)}sub end_document {my ($self,$implicit)=@_;my$event_types=$self->events;if ($event_types->[-1]=~ m/FLOW/){die "Unexpected end of flow context"}if ($self->new_node){$self->scalar_event({style=>YAML_PLAIN_SCALAR_STYLE,value=>'' })}$self->remove_nodes(-1);if ($event_types->[-1]eq 'STR'){return}my$last=pop @{$event_types};if ($last ne 'DOC' and $last ne 'DOC_END'){$self->exception("Unexpected event type $last")}pop @{$self->offset};$self->callback->($self,'document_end_event',{name=>'document_end_event',implicit=>$implicit,});if ($self->yaml_version eq '1.2'){$self->set_tagmap({'!!'=>"tag:yaml.org,2002:" })}$event_types->[-1]=$next_event{$event_types->[-1]};$self->set_rule('STREAM')}sub end_stream {my ($self)=@_;my$last=pop @{$self->events};$self->exception("Unexpected event type $last")unless$last eq 'STR';pop @{$self->offset};$self->callback->($self,'stream_end_event',{name=>'stream_end_event',})}sub fetch_inline_properties {my ($self,$stack,$info)=@_;my$properties=$stack->[-1];$properties=$properties->[1];my$property_offset;if ($properties){for my$p (@{$properties->{inline}}){my$type=$p->{type};if (exists$info->{$type }){$self->exception("A node can only have one $type")}$info->{$type }=$p->{value};unless (defined$property_offset){$property_offset=$p->{offset};$info->{offset}=$p->{offset}}}delete$properties->{inline};undef$properties unless$properties->{newline}}unless ($properties){pop @$stack}}sub node_properties {my ($self,$properties,$info)=@_;if ($properties){for my$p (@{$properties->{newline}}){my$type=$p->{type};if (exists$info->{$type }){$self->exception("A node can only have one $type")}$info->{$type }=$p->{value}}undef$properties}}sub scalar_event {my ($self,$info)=@_;my$event_types=$self->events;my$event_stack=$self->event_stack;if (@$event_stack and $event_stack->[-1]->[0]eq 'properties'){my$properties=pop @$event_stack;$properties=$self->node_properties($properties->[1],$info)}$info->{name}='scalar_event';$self->callback->($self,'scalar_event',$info);$self->set_new_node(0);$event_types->[-1]=$next_event{$event_types->[-1]}}sub alias_event {my ($self,$info)=@_;my$event_stack=$self->event_stack;if (@$event_stack and $event_stack->[-1]->[0]eq 'properties'){$self->exception("Parse error: Alias not allowed in this context")}my$event_types=$self->events;$info->{name}='alias_event';$self->callback->($self,'alias_event',$info);$self->set_new_node(0);$event_types->[-1]=$next_event{$event_types->[-1]}}sub yaml_to_tokens {my ($class,$type,$input)=@_;my$yp=YAML::PP::Parser->new(receiver=>sub {});my@docs=eval {$type eq 'string' ? $yp->parse_string($input): $yp->parse_file($input)};my$error=$@;my$tokens=$yp->tokens;if ($error){my$remaining_tokens=$yp->_remaining_tokens;push @$tokens,map {+{%$_,name=>'ERROR' }}@$remaining_tokens}return$error,$tokens}sub _remaining_tokens {my ($self)=@_;my@tokens;my$next=$self->lexer->next_tokens;push@tokens,@$next;my$next_line=$self->lexer->next_line;my$remaining='';if ($next_line){if ($self->lexer->offset > 0){$remaining=$next_line->[1].$next_line->[2]}else {$remaining=join '',@$next_line}}$remaining .= $self->reader->read;$remaining='' unless defined$remaining;push@tokens,{name=>"ERROR",value=>$remaining };return \@tokens}sub event_to_test_suite {my ($self,$event)=@_;if (ref$event eq 'ARRAY'){return YAML::PP::Common::event_to_test_suite($event->[1])}return YAML::PP::Common::event_to_test_suite($event)}sub debug_events {my ($self)=@_;$self->note("EVENTS: (" .join (' | ',@{$_[0]->events}).')');$self->debug_offset}sub debug_offset {my ($self)=@_;$self->note(qq{OFFSET: (} .join (' | ',map {defined $_ ? sprintf "%-3d",$_ : '?'}@{$_[0]->offset}).qq/) level=@{[ $_[0]->level ]}]}/)}sub debug_yaml {my ($self)=@_;my$line=$self->lexer->line;$self->note("LINE NUMBER: $line");my$next_tokens=$self->lexer->next_tokens;if (@$next_tokens){$self->debug_tokens($next_tokens)}}sub debug_next_line {my ($self)=@_;my$next_line=$self->lexer->next_line || [];my$line=$next_line->[0];$line='' unless defined$line;$line =~ s/( +)$/'' x length $1/e;$line =~ s/\t//g;$self->note("NEXT LINE: >>$line<<")}sub note {my ($self,$msg)=@_;$self->_colorize_warn(["yellow"],"============ $msg")}sub info {my ($self,$msg)=@_;$self->_colorize_warn(["cyan"],"============ $msg")}sub got {my ($self,$msg)=@_;$self->_colorize_warn(["green"],"============ $msg")}sub _colorize_warn {my ($self,$colors,$text)=@_;require Term::ANSIColor;warn Term::ANSIColor::colored($colors,$text),"\n"}sub debug_event {my ($self,$event)=@_;my$str=YAML::PP::Common::event_to_test_suite($event);require Term::ANSIColor;warn Term::ANSIColor::colored(["magenta"],"============ $str"),"\n"}sub debug_rules {my ($self,$rules)=@_;local$Data::Dumper::Maxdepth=2;$self->note("RULES:");for my$rule ($rules){if (ref$rule eq 'ARRAY'){my$first=$rule->[0];if (ref$first eq 'SCALAR'){$self->info("-> $$first")}else {if (ref$first eq 'ARRAY'){$first=$first->[0]}$self->info("TYPE $first")}}else {eval {my@keys=sort keys %$rule;$self->info("@keys")}}}}sub debug_tokens {my ($self,$tokens)=@_;$tokens ||= $self->tokens;require Term::ANSIColor;for my$token (@$tokens){my$type=Term::ANSIColor::colored(["green"],sprintf "%-22s L %2d C %2d ",$token->{name},$token->{line},$token->{column}+ 1);local$Data::Dumper::Useqq=1;local$Data::Dumper::Terse=1;require Data::Dumper;my$str=Data::Dumper->Dump([$token->{value}],['str']);chomp$str;$str =~ s/(^.|.$)/Term::ANSIColor::colored(['blue'], $1)/ge;warn "$type$str\n"}}sub highlight_yaml {my ($self)=@_;require YAML::PP::Highlight;my$tokens=$self->tokens;my$highlighted=YAML::PP::Highlight->ansicolored($tokens);warn$highlighted}sub exception {my ($self,$msg,%args)=@_;my$next=$self->lexer->next_tokens;my$line=@$next ? $next->[0]->{line}: $self->lexer->line;my$offset=@$next ? $next->[0]->{column}: $self->lexer->offset;$offset++;my$next_line=$self->lexer->next_line;my$remaining='';if ($next_line){if ($self->lexer->offset > 0){$remaining=$next_line->[1].$next_line->[2]}else {$remaining=join '',@$next_line}}my$caller=$args{caller}|| [caller(0)];my$e=YAML::PP::Exception->new(got=>$args{got},expected=>$args{expected},line=>$line,column=>$offset,msg=>$msg,next=>$next,where=>$caller->[1].' line ' .$caller->[2],yaml=>$remaining,);croak$e}sub expected {my ($self,%args)=@_;my$expected=$args{expected};@$expected=sort grep {m/^[A-Z_]+$/}@$expected;my$got=$args{got}->{name};my@caller=caller(0);$self->exception("Expected (@$expected), but got $got",caller=>\@caller,expected=>$expected,got=>$args{got},)}sub cb_tag {my ($self,$token)=@_;my$stack=$self->event_stack;if (!@$stack or $stack->[-1]->[0]ne 'properties'){push @$stack,[properties=>{}]}my$last=$stack->[-1]->[1];my$tag=$self->_read_tag($token->{value},$self->tagmap);$last->{inline}||= [];push @{$last->{inline}},{type=>'tag',value=>$tag,offset=>$token->{column},}}sub _read_tag {my ($self,$tag,$map)=@_;if ($tag eq '!'){return "!"}elsif ($tag =~ m/^!<(.*)>/){return $1}elsif ($tag =~ m/^(![^!]*!|!)(.+)/){my$alias=$1;my$name=$2;$name =~ s/%([0-9a-fA-F]{2})/chr hex $1/eg;if (exists$map->{$alias }){$tag=$map->{$alias }.$name}else {if ($alias ne '!' and $alias ne '!!'){die "Found undefined tag handle '$alias'"}$tag="!$name"}}else {die "Invalid tag"}return$tag}sub cb_anchor {my ($self,$token)=@_;my$anchor=$token->{value};$anchor=substr($anchor,1);my$stack=$self->event_stack;if (!@$stack or $stack->[-1]->[0]ne 'properties'){push @$stack,[properties=>{}]}my$last=$stack->[-1]->[1];$last->{inline}||= [];push @{$last->{inline}},{type=>'anchor',value=>$anchor,offset=>$token->{column},}}sub cb_property_eol {my ($self,$res)=@_;my$stack=$self->event_stack;my$last=$stack->[-1]->[1];my$inline=delete$last->{inline}or return;my$newline=$last->{newline}||= [];push @$newline,@$inline}sub cb_mapkey {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}push @{$stack},[scalar=>$info ]}sub cb_send_mapkey {my ($self,$res)=@_;my$last=pop @{$self->event_stack};$self->scalar_event($last->[1]);$self->set_new_node(1)}sub cb_send_scalar {my ($self,$res)=@_;my$last=pop @{$self->event_stack};return unless$last;$self->scalar_event($last->[1]);my$e=$self->events;if ($e->[-1]eq 'IMAP'){$self->end_flow_mapping}}sub cb_empty_mapkey {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>'',offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}$self->scalar_event($info);$self->set_new_node(1)}sub cb_send_flow_alias {my ($self,$token)=@_;my$alias=substr($token->{value},1);$self->alias_event({value=>$alias })}sub cb_send_alias {my ($self,$token)=@_;my$alias=substr($token->{value},1);$self->alias_event({value=>$alias })}sub cb_send_alias_from_stack {my ($self,$token)=@_;my$last=pop @{$self->event_stack};$self->alias_event($last->[1])}sub cb_alias {my ($self,$token)=@_;my$alias=substr($token->{value},1);push @{$self->event_stack},[alias=>{value=>$alias,offset=>$token->{column},}]}sub cb_question {my ($self,$res)=@_;$self->set_new_node(1)}sub cb_flow_question {my ($self,$res)=@_;$self->set_new_node(2)}sub cb_empty_complexvalue {my ($self,$res)=@_;$self->scalar_event({style=>YAML_PLAIN_SCALAR_STYLE,value=>'' })}sub cb_questionstart {my ($self,$token)=@_;$self->start_mapping($token->{column})}sub cb_complexcolon {my ($self,$res)=@_;$self->set_new_node(1)}sub cb_seqstart {my ($self,$token)=@_;my$column=$token->{column};$self->start_sequence($column);$self->set_new_node(1)}sub cb_seqitem {my ($self,$res)=@_;$self->set_new_node(1)}sub cb_take_quoted {my ($self,$token)=@_;my$subtokens=$token->{subtokens};my$stack=$self->event_stack;my$info={style=>$subtokens->[0]->{value}eq '"' ? YAML_DOUBLE_QUOTED_SCALAR_STYLE : YAML_SINGLE_QUOTED_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}push @{$stack},[scalar=>$info ]}sub cb_quoted_multiline {my ($self,$token)=@_;my$subtokens=$token->{subtokens};my$stack=$self->event_stack;my$info={style=>$subtokens->[0]->{value}eq '"' ? YAML_DOUBLE_QUOTED_SCALAR_STYLE : YAML_SINGLE_QUOTED_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}push @{$stack},[scalar=>$info ];$self->cb_send_scalar}sub cb_take_quoted_key {my ($self,$token)=@_;$self->cb_take_quoted($token);$self->cb_send_mapkey}sub cb_send_plain_multi {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}push @{$stack},[scalar=>$info ];$self->cb_send_scalar}sub cb_start_plain {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}push @{$stack},[scalar=>$info ]}sub cb_start_flowseq {my ($self,$token)=@_;$self->start_flow_sequence($token->{column})}sub cb_start_flowmap {my ($self,$token)=@_;$self->start_flow_mapping($token->{column})}sub cb_end_flowseq {my ($self,$res)=@_;$self->cb_send_scalar;$self->end_flow_sequence;$self->set_new_node(0)}sub cb_flow_comma {my ($self)=@_;my$event_types=$self->events;$self->set_new_node(0);if ($event_types->[-1]=~ m/^FLOWSEQ/){$self->cb_send_scalar;$event_types->[-1]=$next_event{$event_types->[-1]}}}sub cb_flow_colon {my ($self)=@_;$self->set_new_node(1)}sub cb_empty_flow_mapkey {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>'',offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}$self->scalar_event($info)}sub cb_end_flowmap {my ($self,$res)=@_;$self->end_flow_mapping;$self->set_new_node(0)}sub cb_end_flowmap_empty {my ($self,$res)=@_;$self->cb_empty_flowmap_value;$self->end_flow_mapping;$self->set_new_node(0)}sub cb_flowkey_plain {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}$self->scalar_event($info)}sub cb_flowkey_quoted {my ($self,$token)=@_;my$stack=$self->event_stack;my$subtokens=$token->{subtokens};my$info={style=>$subtokens->[0]->{value}eq '"' ? YAML_DOUBLE_QUOTED_SCALAR_STYLE : YAML_SINGLE_QUOTED_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}$self->scalar_event($info)}sub cb_empty_flowmap_key_value {my ($self,$token)=@_;$self->cb_empty_flow_mapkey($token);$self->cb_empty_flowmap_value;$self->cb_flow_comma}sub cb_end_empty_flowmap_key_value {my ($self,$token)=@_;$self->cb_empty_flow_mapkey($token);$self->cb_empty_flowmap_value;$self->cb_flow_comma;$self->cb_end_flowmap}sub cb_empty_flowmap_value {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>'',offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}$self->scalar_event($info)}sub cb_empty_flowseq_comma {my ($self,$token)=@_;$self->cb_empty_flowmap_value($token);$self->cb_flow_comma}sub cb_empty_flowseq_end {my ($self,$token)=@_;$self->cb_empty_flowmap_value($token);$self->cb_end_flowseq}sub cb_insert_map_alias {my ($self,$res)=@_;my$stack=$self->event_stack;my$scalar=pop @$stack;my$info=$scalar->[1];$self->start_mapping($info->{offset});$self->alias_event($info);$self->set_new_node(1)}sub cb_insert_map {my ($self,$res)=@_;my$stack=$self->event_stack;my$scalar=pop @$stack;my$info=$scalar->[1];$self->start_mapping($info->{offset});$self->scalar_event($info);$self->set_new_node(1)}sub cb_insert_implicit_flowseq_map {my ($self,$res)=@_;my$stack=$self->event_stack;my$scalar=pop @$stack;my$info=$scalar->[1];$self->start_flow_mapping($info->{offset},1);$self->scalar_event($info);$self->set_new_node(1)}sub cb_insert_empty_implicit_flowseq_map {my ($self,$res)=@_;my$stack=$self->event_stack;my$scalar=pop @$stack;my$info=$scalar->[1];$self->start_flow_mapping($info->{offset},1);$self->cb_empty_flowmap_value;$self->set_new_node(2)}sub cb_insert_empty_map {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>'',offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}$self->start_mapping($info->{offset});$self->scalar_event($info);$self->set_new_node(1)}sub cb_send_block_scalar {my ($self,$token)=@_;my$type=$token->{subtokens}->[0]->{value};my$stack=$self->event_stack;my$info={style=>$type eq '|' ? YAML_LITERAL_SCALAR_STYLE : YAML_FOLDED_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}push @{$self->event_stack},[scalar=>$info ];$self->cb_send_scalar}sub cb_end_document {my ($self,$token)=@_;$self->end_document(0)}sub cb_end_document_empty {my ($self,$token)=@_;$self->end_document(0)}sub cb_doc_start_implicit {my ($self,$token)=@_;$self->start_document(1)}sub cb_doc_start_explicit {my ($self,$token)=@_;$self->start_document(0)}sub cb_end_doc_start_document {my ($self,$token)=@_;$self->end_document(1);$self->start_document(0)}sub cb_tag_directive {my ($self,$token)=@_;my ($name,$tag_alias,$tag_url)=split ' ',$token->{value};$self->tagmap->{$tag_alias }=$tag_url}sub cb_reserved_directive {}sub cb_set_yaml_version_directive {my ($self,$token)=@_;if ($self->yaml_version_directive){croak "Found duplicate YAML directive"}my ($version)=$token->{value}=~ m/^%YAML (1\.[12])/;$self->set_yaml_version($version);$self->set_yaml_version_directive(1)}1;
YAML_PP_PARSER

$fatpacked{"YAML/PP/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_PERL';
  use strict;use warnings;package YAML::PP::Perl;our$VERSION='0.030';use base 'Exporter';use base 'YAML::PP';our@EXPORT_OK=qw/Load Dump LoadFile DumpFile/;use YAML::PP;use YAML::PP::Schema::Perl;sub new {my ($class,%args)=@_;$args{schema}||= [qw/Core Perl/];$class->SUPER::new(%args)}sub Load {my ($yaml)=@_;__PACKAGE__->new->load_string($yaml)}sub LoadFile {my ($file)=@_;__PACKAGE__->new->load_file($file)}sub Dump {my (@data)=@_;__PACKAGE__->new->dump_string(@data)}sub DumpFile {my ($file,@data)=@_;__PACKAGE__->new->dump_file($file,@data)}1;
YAML_PP_PERL

$fatpacked{"YAML/PP/Reader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_READER';
  use strict;use warnings;package YAML::PP::Reader;our$VERSION='0.030';sub input {return $_[0]->{input}}sub set_input {$_[0]->{input}=$_[1]}sub new {my ($class,%args)=@_;my$input=delete$args{input};return bless {input=>$input,},$class}sub read {my ($self)=@_;my$pos=pos$self->{input}|| 0;my$yaml=substr($self->{input},$pos);$self->{input}='';return$yaml}sub readline {my ($self)=@_;unless (length$self->{input}){return}if ($self->{input}=~ m/\G([^\r\n]*(?:\n|\r\n|\r|\z))/g){my$line=$1;unless (length$line){$self->{input}='';return}return$line}return}package YAML::PP::Reader::File;use Scalar::Util qw/openhandle/;our@ISA=qw/YAML::PP::Reader/;use Carp qw/croak/;sub open_handle {if (openhandle($_[0]->{input})){return $_[0]->{input}}open my$fh,'<:encoding(UTF-8)',$_[0]->{input}or croak "Could not open '$_[0]->{input}' for reading: $!";return$fh}sub read {my$fh=$_[0]->{filehandle}||= $_[0]->open_handle;if (wantarray){my@yaml=<$fh>;return@yaml}else {local $/;my$yaml=<$fh>;return$yaml}}sub readline {my$fh=$_[0]->{filehandle}||= $_[0]->open_handle;return scalar <$fh>}1;
YAML_PP_READER

$fatpacked{"YAML/PP/Render.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_RENDER';
  use strict;use warnings;package YAML::PP::Render;our$VERSION='0.030';use constant TRACE=>$ENV{YAML_PP_TRACE}? 1 : 0;sub render_quoted {my ($self,$style,$lines)=@_;my$quoted='';my$addspace=0;for my$i (0 .. $#$lines){my$line=$lines->[$i ];my$value=$line->{value};my$last=$i==$#$lines;my$first=$i==0;if ($value eq ''){if ($first){$addspace=1}elsif ($last){$quoted .= ' ' if$addspace}else {$addspace=0;$quoted .= "\n"}next}$quoted .= ' ' if$addspace;$addspace=1;if ($style eq '"'){if ($line->{orig}=~ m/\\$/){$line->{value}=~ s/\\$//;$value =~ s/\\$//;$addspace=0}}$quoted .= $value}return$quoted}sub render_block_scalar {my ($self,$block_type,$chomp,$lines)=@_;my ($folded,$keep,$trim);if ($block_type eq '>'){$folded=1}if ($chomp eq '+'){$keep=1}elsif ($chomp eq '-'){$trim=1}my$string='';if (not $keep){while (@$lines){last if$lines->[-1]ne '';pop @$lines}}if ($folded){my$prev='START';for my$i (0 .. $#$lines){my$line=$lines->[$i ];my$type=$line eq '' ? 'EMPTY' : $line =~ m/\A[ \t]/ ? 'MORE' : 'CONTENT';if ($prev eq 'MORE' and $type eq 'EMPTY'){$type='MORE'}elsif ($prev eq 'CONTENT'){if ($type ne 'CONTENT'){$string .= "\n"}elsif ($type eq 'CONTENT'){$string .= ' '}}elsif ($prev eq 'START' and $type eq 'EMPTY'){$string .= "\n";$type='START'}elsif ($prev eq 'EMPTY' and $type ne 'CONTENT'){$string .= "\n"}$string .= $line;if ($type eq 'MORE' and $i < $#$lines){$string .= "\n"}$prev=$type}$string .= "\n" if @$lines and not $trim}else {for my$i (0 .. $#$lines){$string .= $lines->[$i ];$string .= "\n" if ($i!=$#$lines or not $trim)}}TRACE and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$string],['string']);return$string}sub render_multi_val {my ($self,$multi)=@_;my$string='';my$start=1;for my$line (@$multi){if (not $start){if ($line eq ''){$string .= "\n";$start=1}else {$string .= " $line"}}else {$string .= $line;$start=0}}return$string}1;
YAML_PP_RENDER

$fatpacked{"YAML/PP/Representer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_REPRESENTER';
  use strict;use warnings;package YAML::PP::Representer;our$VERSION='0.030';use Scalar::Util qw/reftype blessed refaddr/;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE YAML_DOUBLE_QUOTED_SCALAR_STYLE YAML_ANY_SCALAR_STYLE YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE YAML_FLOW_SEQUENCE_STYLE YAML_FLOW_MAPPING_STYLE YAML_BLOCK_MAPPING_STYLE YAML_BLOCK_SEQUENCE_STYLE PRESERVE_ORDER PRESERVE_SCALAR_STYLE PRESERVE_FLOW_STYLE PRESERVE_ALIAS/;use B;sub new {my ($class,%args)=@_;my$preserve=delete$args{preserve}|| 0;if ($preserve==1){$preserve=PRESERVE_ORDER | PRESERVE_SCALAR_STYLE | PRESERVE_FLOW_STYLE | PRESERVE_ALIAS}my$self=bless {schema=>delete$args{schema},preserve=>$preserve,},$class;if (keys%args){die "Unexpected arguments: " .join ', ',sort keys%args}return$self}sub clone {my ($self)=@_;my$clone={schema=>$self->schema,preserve=>$self->{preserve},};return bless$clone,ref$self}sub schema {return $_[0]->{schema}}sub preserve_order {return $_[0]->{preserve}& PRESERVE_ORDER}sub preserve_scalar_style {return $_[0]->{preserve}& PRESERVE_SCALAR_STYLE}sub preserve_flow_style {return $_[0]->{preserve}& PRESERVE_FLOW_STYLE}sub preserve_alias {return $_[0]->{preserve}& PRESERVE_ALIAS}sub represent_node {my ($self,$node)=@_;my$preserve_alias=$self->preserve_alias;my$preserve_style=$self->preserve_scalar_style;if ($preserve_style or $preserve_alias){if (ref$node->{value}eq 'YAML::PP::Preserve::Scalar'){my$value=$node->{value}->value;if ($preserve_style and $node->{value}->style!=YAML_FOLDED_SCALAR_STYLE){$node->{style}=$node->{value}->style}$node->{value}=$value}}$node->{reftype}=reftype($node->{value});if (not $node->{reftype}and reftype(\$node->{value})eq 'GLOB'){$node->{reftype}='GLOB'}if ($node->{reftype}){$self->represent_noderef($node)}else {$self->represent_node_nonref($node)}$node->{reftype}=(reftype$node->{data})|| '';if ($node->{reftype}eq 'HASH' and my$tied=tied(%{$node->{data}})){my$representers=$self->schema->representers;$tied=ref$tied;if (my$def=$representers->{tied_equals}->{$tied }){my$code=$def->{code};my$done=$code->($self,$node)}}if ($node->{reftype}eq 'HASH'){unless (defined$node->{items}){my@keys;if ($self->preserve_order){@keys=keys %{$node->{data}}}else {@keys=sort keys %{$node->{data}}}for my$key (@keys){push @{$node->{items}},$key,$node->{data}->{$key }}}my%args;if ($self->preserve_flow_style and reftype$node->{value}eq 'HASH'){if (my$tied=tied %{$node->{value}}){$args{style}=$tied->{style}}}return [mapping=>$node,%args ]}elsif ($node->{reftype}eq 'ARRAY'){unless (defined$node->{items}){@{$node->{items}}=@{$node->{data}}}my%args;if ($self->preserve_flow_style and reftype$node->{value}eq 'ARRAY'){if (my$tied=tied @{$node->{value}}){$args{style}=$tied->{style}}}return [sequence=>$node,%args ]}elsif ($node->{reftype}){die "Cannot handle reftype '$node->{reftype}' (you might want to enable YAML::PP::Schema::Perl)"}else {unless (defined$node->{items}){$node->{items}=[$node->{data}]}return [scalar=>$node ]}}sub represent_node_nonref {my ($self,$node)=@_;my$representers=$self->schema->representers;if (not defined$node->{value}){if (my$undef=$representers->{undef}){return 1 if$undef->($self,$node)}else {$node->{style}=YAML_SINGLE_QUOTED_SCALAR_STYLE;$node->{data}='';return 1}}for my$rep (@{$representers->{flags}}){my$check_flags=$rep->{flags};my$flags=B::svref_2object(\$node->{value})->FLAGS;if ($flags & $check_flags){return 1 if$rep->{code}->($self,$node)}}if (my$rep=$representers->{equals}->{$node->{value}}){return 1 if$rep->{code}->($self,$node)}for my$rep (@{$representers->{regex}}){if ($node->{value}=~ $rep->{regex}){return 1 if$rep->{code}->($self,$node)}}unless (defined$node->{data}){$node->{data}=$node->{value}}unless (defined$node->{style}){$node->{style}=YAML_ANY_SCALAR_STYLE;$node->{style}=""}}sub represent_noderef {my ($self,$node)=@_;my$representers=$self->schema->representers;if (my$classname=blessed($node->{value})){if (my$def=$representers->{class_equals}->{$classname }){my$code=$def->{code};return 1 if$code->($self,$node)}for my$matches (@{$representers->{class_matches}}){my ($re,$code)=@$matches;if (ref$re and $classname =~ $re or $re){return 1 if$code->($self,$node)}}for my$isa (@{$representers->{class_isa}}){my ($class_name,$code)=@$isa;if ($node->{value }->isa($class_name)){return 1 if$code->($self,$node)}}}if ($node->{reftype}eq 'SCALAR' and my$scalarref=$representers->{scalarref}){my$code=$scalarref->{code};return 1 if$code->($self,$node)}if ($node->{reftype}eq 'REF' and my$refref=$representers->{refref}){my$code=$refref->{code};return 1 if$code->($self,$node)}if ($node->{reftype}eq 'CODE' and my$coderef=$representers->{coderef}){my$code=$coderef->{code};return 1 if$code->($self,$node)}if ($node->{reftype}eq 'GLOB' and my$glob=$representers->{glob}){my$code=$glob->{code};return 1 if$code->($self,$node)}$node->{data}=$node->{value}}1;
YAML_PP_REPRESENTER

$fatpacked{"YAML/PP/Schema.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA';
  use strict;use warnings;package YAML::PP::Schema;use B;use Module::Load qw//;our$VERSION='0.030';use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE/;use Scalar::Util qw/blessed/;sub new {my ($class,%args)=@_;my$yaml_version=delete$args{yaml_version};my$bool=delete$args{boolean};$bool='perl' unless defined$bool;if (keys%args){die "Unexpected arguments: " .join ', ',sort keys%args}my$true;my$false;my$bool_class='';if ($bool eq 'JSON::PP'){require JSON::PP;$true=\&bool_jsonpp_true;$false=\&bool_jsonpp_false;$bool_class='JSON::PP::Boolean'}elsif ($bool eq 'boolean'){require boolean;$true=\&bool_booleanpm_true;$false=\&bool_booleanpm_false;$bool_class='boolean'}elsif ($bool eq 'perl'){$true=\&bool_perl_true;$false=\&bool_perl_false}else {die "Invalid value for 'boolean': '$bool'. Allowed: ('perl', 'boolean', 'JSON::PP')"}my%representers=('undef'=>undef,flags=>[],equals=>{},regex=>[],class_equals=>{},class_matches=>[],class_isa=>[],scalarref=>undef,refref=>undef,coderef=>undef,glob=>undef,tied_equals=>{},);my$self=bless {yaml_version=>$yaml_version,resolvers=>{},representers=>\%representers,true=>$true,false=>$false,bool_class=>$bool_class,},$class;return$self}sub resolvers {return $_[0]->{resolvers}}sub representers {return $_[0]->{representers}}sub true {return $_[0]->{true}}sub false {return $_[0]->{false}}sub bool_class {return $_[0]->{bool_class}}sub yaml_version {return $_[0]->{yaml_version}}my%LOADED_SCHEMA=(JSON=>1,);my%DEFAULT_SCHEMA=('1.2'=>'Core','1.1'=>'YAML1_1',);sub load_subschemas {my ($self,@schemas)=@_;my$yaml_version=$self->yaml_version;my$i=0;while ($i < @schemas){my$item=$schemas[$i ];if ($item eq '+'){$item=$DEFAULT_SCHEMA{$yaml_version }}$i++;if (blessed($item)){$item->register(schema=>$self,);next}my@options;while ($i < @schemas and ($schemas[$i ]=~ m/^[^A-Za-z]/ or $schemas[$i ]=~ m/^[a-zA-Z0-9]+=/)){push@options,$schemas[$i ];$i++}my$class;if ($item =~ m/^\:(.*)/){$class="$1";unless ($class =~ m/\A[A-Za-z0-9_:]+\z/){die "Module name '$class' is invalid"}Module::Load::load$class}else {$class="YAML::PP::Schema::$item";unless ($class =~ m/\A[A-Za-z0-9_:]+\z/){die "Module name '$class' is invalid"}$LOADED_SCHEMA{$item }||= Module::Load::load$class}$class->register(schema=>$self,options=>\@options,)}}sub add_resolver {my ($self,%args)=@_;my$tag=$args{tag};my$rule=$args{match};my$resolvers=$self->resolvers;my ($type,@rule)=@$rule;my$implicit=$args{implicit};$implicit=1 unless defined$implicit;my$resolver_list=[];if ($tag){if (ref$tag eq 'Regexp'){my$res=$resolvers->{tags}||= [];push @$res,[$tag,{}];push @$resolver_list,$res->[-1]->[1]}else {my$res=$resolvers->{tag}->{$tag }||= {};push @$resolver_list,$res}}if ($implicit){push @$resolver_list,$resolvers->{value}||= {}}for my$res (@$resolver_list){if ($type eq 'equals'){my ($match,$value)=@rule;unless (exists$res->{equals}->{$match }){$res->{equals}->{$match }=$value}next}elsif ($type eq 'regex'){my ($match,$value)=@rule;push @{$res->{regex}},[$match=>$value ]}elsif ($type eq 'all'){my ($value)=@rule;$res->{all}=$value}}}sub add_sequence_resolver {my ($self,%args)=@_;return$self->add_collection_resolver(sequence=>%args)}sub add_mapping_resolver {my ($self,%args)=@_;return$self->add_collection_resolver(mapping=>%args)}sub add_collection_resolver {my ($self,$type,%args)=@_;my$tag=$args{tag};my$implicit=$args{implicit};my$resolvers=$self->resolvers;if ($tag and ref$tag eq 'Regexp'){my$res=$resolvers->{$type }->{tags}||= [];push @$res,[$tag,{on_create=>$args{on_create},on_data=>$args{on_data},}]}elsif ($tag){my$res=$resolvers->{$type }->{tag}->{$tag }||= {on_create=>$args{on_create},on_data=>$args{on_data},}}}sub add_representer {my ($self,%args)=@_;my$representers=$self->representers;if (my$flags=$args{flags}){my$rep=$representers->{flags};push @$rep,\%args;return}if (my$regex=$args{regex}){my$rep=$representers->{regex};push @$rep,\%args;return}if (my$regex=$args{class_matches}){my$rep=$representers->{class_matches};push @$rep,[$args{class_matches},$args{code}];return}if (my$class_equals=$args{class_equals}){my$rep=$representers->{class_equals};$rep->{$class_equals }={code=>$args{code},};return}if (my$class_isa=$args{class_isa}){my$rep=$representers->{class_isa};push @$rep,[$args{class_isa},$args{code}];return}if (my$tied_equals=$args{tied_equals}){my$rep=$representers->{tied_equals};$rep->{$tied_equals }={code=>$args{code},};return}if (defined(my$equals=$args{equals})){my$rep=$representers->{equals};$rep->{$equals }={code=>$args{code},};return}if (defined(my$scalarref=$args{scalarref})){$representers->{scalarref}={code=>$args{code},};return}if (defined(my$refref=$args{refref})){$representers->{refref}={code=>$args{code},};return}if (defined(my$coderef=$args{coderef})){$representers->{coderef}={code=>$args{code},};return}if (defined(my$glob=$args{glob})){$representers->{glob}={code=>$args{code},};return}if (my$undef=$args{undefined}){$representers->{undef}=$undef;return}}sub load_scalar {my ($self,$constructor,$event)=@_;my$tag=$event->{tag};my$value=$event->{value};my$resolvers=$self->resolvers;my$res;if ($tag){$res=$resolvers->{tag}->{$tag };if (not $res and my$matches=$resolvers->{tags}){for my$match (@$matches){my ($re,$rule)=@$match;if ($tag =~ $re){$res=$rule;last}}}}else {$res=$resolvers->{value};if ($event->{style}ne YAML_PLAIN_SCALAR_STYLE){return$value}}if (my$equals=$res->{equals}){if (exists$equals->{$value }){my$res=$equals->{$value };if (ref$res eq 'CODE'){return$res->($constructor,$event)}return$res}}if (my$regex=$res->{regex}){for my$item (@$regex){my ($re,$sub)=@$item;my@matches=$value =~ $re;if (@matches){return$sub->($constructor,$event,\@matches)}}}if (my$catch_all=$res->{all}){if (ref$catch_all eq 'CODE'){return$catch_all->($constructor,$event)}return$catch_all}return$value}sub create_sequence {my ($self,$constructor,$event)=@_;my$tag=$event->{tag};my$data=[];my$on_data;my$resolvers=$self->resolvers->{sequence};if ($tag){if (my$equals=$resolvers->{tag}->{$tag }){my$on_create=$equals->{on_create};$on_data=$equals->{on_data};$on_create and $data=$on_create->($constructor,$event);return ($data,$on_data)}if (my$matches=$resolvers->{tags}){for my$match (@$matches){my ($re,$actions)=@$match;my$on_create=$actions->{on_create};if ($tag =~ $re){$on_data=$actions->{on_data};$on_create and $data=$on_create->($constructor,$event);return ($data,$on_data)}}}}return ($data,$on_data)}sub create_mapping {my ($self,$constructor,$event)=@_;my$tag=$event->{tag};my$data={};my$on_data;my$resolvers=$self->resolvers->{mapping};if ($tag){if (my$equals=$resolvers->{tag}->{$tag }){my$on_create=$equals->{on_create};$on_data=$equals->{on_data};$on_create and $data=$on_create->($constructor,$event);return ($data,$on_data)}if (my$matches=$resolvers->{tags}){for my$match (@$matches){my ($re,$actions)=@$match;my$on_create=$actions->{on_create};if ($tag =~ $re){$on_data=$actions->{on_data};$on_create and $data=$on_create->($constructor,$event);return ($data,$on_data)}}}}return ($data,$on_data)}sub bool_jsonpp_true {JSON::PP::true()}sub bool_booleanpm_true {boolean::true()}sub bool_perl_true {1}sub bool_jsonpp_false {JSON::PP::false()}sub bool_booleanpm_false {boolean::false()}sub bool_perl_false {!1}1;
YAML_PP_SCHEMA

$fatpacked{"YAML/PP/Schema/Binary.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_BINARY';
  use strict;use warnings;package YAML::PP::Schema::Binary;our$VERSION='0.030';use MIME::Base64 qw/decode_base64 encode_base64/;use YAML::PP::Common qw/YAML_ANY_SCALAR_STYLE/;sub register {my ($self,%args)=@_;my$schema=$args{schema};$schema->add_resolver(tag=>'tag:yaml.org,2002:binary',match=>[all=>sub {my ($constructor,$event)=@_;my$base64=$event->{value};my$binary=decode_base64($base64);return$binary}],implicit=>0,);$schema->add_representer(regex=>qr{.*},code=>sub {my ($rep,$node)=@_;my$binary=$node->{value};unless ($binary =~ m/[\x{7F}-\x{10FFFF}]/){return}if (utf8::is_utf8($binary)){return}my$base64=encode_base64($binary);$node->{style}=YAML_ANY_SCALAR_STYLE;$node->{data}=$base64;$node->{tag}="tag:yaml.org,2002:binary";return 1},)}1;
YAML_PP_SCHEMA_BINARY

$fatpacked{"YAML/PP/Schema/Core.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_CORE';
  use strict;use warnings;package YAML::PP::Schema::Core;our$VERSION='0.030';use YAML::PP::Schema::JSON qw/represent_int represent_float represent_literal represent_bool represent_undef/;use B;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE/;my$RE_INT_CORE=qr{^([+-]?(?:[0-9]+))$};my$RE_FLOAT_CORE=qr{^([+-]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)(?:[eE][+-]?[0-9]+)?)$};my$RE_INT_OCTAL=qr{^0o([0-7]+)$};my$RE_INT_HEX=qr{^0x([0-9a-fA-F]+)$};sub _from_oct {oct $_[2]->[0]}sub _from_hex {hex $_[2]->[0]}sub register {my ($self,%args)=@_;my$schema=$args{schema};$schema->add_resolver(tag=>'tag:yaml.org,2002:null',match=>[equals=>$_=>undef ],)for (qw/null NULL Null ~/,'');$schema->add_resolver(tag=>'tag:yaml.org,2002:bool',match=>[equals=>$_=>$schema->true ],)for (qw/true TRUE True/);$schema->add_resolver(tag=>'tag:yaml.org,2002:bool',match=>[equals=>$_=>$schema->false ],)for (qw/false FALSE False/);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_CORE=>\&YAML::PP::Schema::JSON::_to_int ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_OCTAL=>\&_from_oct ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_HEX=>\&_from_hex ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[regex=>$RE_FLOAT_CORE=>\&YAML::PP::Schema::JSON::_to_float ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[equals=>$_=>0 + "inf" ],)for (qw/.inf .Inf .INF +.inf +.Inf +.INF/);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[equals=>$_=>0 - "inf" ],)for (qw/-.inf -.Inf -.INF/);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[equals=>$_=>0 + "nan" ],)for (qw/.nan .NaN .NAN/);$schema->add_resolver(tag=>'tag:yaml.org,2002:str',match=>[all=>sub {$_[1]->{value}}],);my$int_flags=B::SVp_IOK;my$float_flags=B::SVp_NOK;$schema->add_representer(flags=>$int_flags,code=>\&represent_int,);$schema->add_representer(flags=>$float_flags,code=>\&represent_float,);$schema->add_representer(undefined=>\&represent_undef,);$schema->add_representer(equals=>$_,code=>\&represent_literal,)for ("",qw/true TRUE True false FALSE False null NULL Null ~ .inf .Inf .INF +.inf +.Inf +.INF -.inf -.Inf -.INF .nan .NaN .NAN/);$schema->add_representer(regex=>qr{$RE_INT_CORE|$RE_FLOAT_CORE|$RE_INT_OCTAL|$RE_INT_HEX},code=>\&represent_literal,);if ($schema->bool_class){$schema->add_representer(class_equals=>$schema->bool_class,code=>\&represent_bool,)}return}1;
YAML_PP_SCHEMA_CORE

$fatpacked{"YAML/PP/Schema/Failsafe.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_FAILSAFE';
  use strict;use warnings;package YAML::PP::Schema::Failsafe;our$VERSION='0.030';sub register {my ($self,%args)=@_;return}1;
YAML_PP_SCHEMA_FAILSAFE

$fatpacked{"YAML/PP/Schema/Include.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_INCLUDE';
  use strict;use warnings;package YAML::PP::Schema::Include;our$VERSION='0.030';use Carp qw/croak/;use Scalar::Util qw/weaken/;use File::Basename qw/dirname/;sub new {my ($class,%args)=@_;my$paths=delete$args{paths};if (defined$paths){unless (ref$paths eq 'ARRAY'){$paths=[$paths]}}else {$paths=[]}my$allow_absolute=$args{allow_absolute}|| 0;my$loader=$args{loader}|| \&default_loader;my$self=bless {paths=>$paths,allow_absolute=>$allow_absolute,last_includes=>[],cached=>{},loader=>$loader,},$class;return$self}sub init {my ($self)=@_;$self->{last_includes}=[];$self->{cached}=[]}sub paths {$_[0]->{paths}}sub allow_absolute {$_[0]->{allow_absolute}}sub yp {my ($self,$yp)=@_;if (@_==2){$self->{yp}=$yp;weaken$self->{yp};return$yp}return$self->{yp}}sub register {my ($self,%args)=@_;my$schema=$args{schema};$schema->add_resolver(tag=>'!include',match=>[all=>sub {$self->include(@_)}],implicit=>0,)}sub include {my ($self,$constructor,$event)=@_;my$yp=$self->yp;my$search_paths=$self->paths;my$allow_absolute=$self->allow_absolute;my$relative=not @$search_paths;if ($relative){my$last_includes=$self->{last_includes};if (@$last_includes){$search_paths=[$last_includes->[-1]]}else {my$filename=$yp->loader->filename;$search_paths=[dirname$filename]}}my$filename=$event->{value};my$fullpath;if (File::Spec->file_name_is_absolute($filename)){unless ($allow_absolute){croak "Absolute filenames not allowed"}$fullpath=$filename}else {my@paths=File::Spec->splitdir($filename);unless ($allow_absolute){@paths=File::Spec->no_upwards(@paths)}for my$candidate (@$search_paths){my$test=File::Spec->catfile($candidate,@paths);if (-e $test){$fullpath=$test;last}}croak "File '$filename' not found" unless defined$fullpath}if ($self->{cached}->{$fullpath }++){croak "Circular include '$fullpath'"}if ($relative){push @{$self->{last_includes}},dirname$fullpath}my$clone=$yp->clone;my ($data)=$self->loader->($clone,$fullpath);if ($relative){pop @{$self->{last_includes}}}unless (--$self->{cached}->{$fullpath }){delete$self->{cached}->{$fullpath }}return$data}sub loader {my ($self,$code)=@_;if (@_==2){$self->{loader}=$code;return$code}return$self->{loader}}sub default_loader {my ($yp,$filename)=@_;$yp->load_file($filename)}1;
YAML_PP_SCHEMA_INCLUDE

$fatpacked{"YAML/PP/Schema/JSON.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_JSON';
  use strict;use warnings;package YAML::PP::Schema::JSON;our$VERSION='0.030';use base 'Exporter';our@EXPORT_OK=qw/represent_int represent_float represent_literal represent_bool represent_undef/;use B;use Carp qw/croak/;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE/;my$RE_INT=qr{^(-?(?:0|[1-9][0-9]*))$};my$RE_FLOAT=qr{^(-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?)$};sub _to_int {0 + $_[2]->[0]}sub _to_float {unpack F=>pack F=>$_[2]->[0]}sub register {my ($self,%args)=@_;my$schema=$args{schema};my$options=$args{options};my$empty_null=0;for my$opt (@$options){if ($opt eq 'empty=str'){}elsif ($opt eq 'empty=null'){$empty_null=1}else {croak "Invalid option for JSON Schema: '$opt'"}}$schema->add_resolver(tag=>'tag:yaml.org,2002:null',match=>[equals=>null=>undef ],);if ($empty_null){$schema->add_resolver(tag=>'tag:yaml.org,2002:null',match=>[equals=>''=>undef ],implicit=>1,)}else {$schema->add_resolver(tag=>'tag:yaml.org,2002:str',match=>[equals=>''=>'' ],implicit=>1,)}$schema->add_resolver(tag=>'tag:yaml.org,2002:bool',match=>[equals=>true=>$schema->true ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:bool',match=>[equals=>false=>$schema->false ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT=>\&_to_int ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[regex=>$RE_FLOAT=>\&_to_float ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:str',match=>[all=>sub {$_[1]->{value}}],);$schema->add_representer(undefined=>\&represent_undef,);my$int_flags=B::SVp_IOK;my$float_flags=B::SVp_NOK;$schema->add_representer(flags=>$int_flags,code=>\&represent_int,);my%special=((0+'nan').''=>'.nan',(0+'inf').''=>'.inf',(0-'inf').''=>'-.inf');$schema->add_representer(flags=>$float_flags,code=>\&represent_float,);$schema->add_representer(equals=>$_,code=>\&represent_literal,)for ("",qw/true false null/);$schema->add_representer(regex=>qr{$RE_INT|$RE_FLOAT},code=>\&represent_literal,);if ($schema->bool_class){$schema->add_representer(class_equals=>$schema->bool_class,code=>\&represent_bool,)}return}sub represent_undef {my ($rep,$node)=@_;$node->{style}=YAML_PLAIN_SCALAR_STYLE;$node->{data}='null';return 1}sub represent_literal {my ($rep,$node)=@_;$node->{style}||= YAML_SINGLE_QUOTED_SCALAR_STYLE;$node->{data}="$node->{value}";return 1}sub represent_int {my ($rep,$node)=@_;if (int($node->{value})ne $node->{value}){return 0}$node->{style}=YAML_PLAIN_SCALAR_STYLE;$node->{data}="$node->{value}";return 1}my%special=((0+'nan').''=>'.nan',(0+'inf').''=>'.inf',(0-'inf').''=>'-.inf');sub represent_float {my ($rep,$node)=@_;if (exists$special{$node->{value}}){$node->{style}=YAML_PLAIN_SCALAR_STYLE;$node->{data}=$special{$node->{value}};return 1}if (0.0 + $node->{value}ne $node->{value}){return 0}if (int($node->{value})eq $node->{value}and not $node->{value}=~ m/\./){$node->{value}.= '.0'}$node->{style}=YAML_PLAIN_SCALAR_STYLE;$node->{data}="$node->{value}";return 1}sub represent_bool {my ($rep,$node)=@_;my$string=$node->{value}? 'true' : 'false';$node->{style}=YAML_PLAIN_SCALAR_STYLE;@{$node->{items}}=$string;$node->{data}=$string;return 1}1;
YAML_PP_SCHEMA_JSON

$fatpacked{"YAML/PP/Schema/Merge.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_MERGE';
  use strict;use warnings;package YAML::PP::Schema::Merge;our$VERSION='0.030';use YAML::PP::Type::MergeKey;sub register {my ($self,%args)=@_;my$schema=$args{schema};$schema->add_resolver(tag=>'tag:yaml.org,2002:merge',match=>[equals=>'<<'=>YAML::PP::Type::MergeKey->new ],)}1;
YAML_PP_SCHEMA_MERGE

$fatpacked{"YAML/PP/Schema/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_PERL';
  use strict;use warnings;package YAML::PP::Schema::Perl;our$VERSION='0.030';use Scalar::Util qw/blessed reftype/;my$qr_prefix;{$qr_prefix=qr{\(\?-xism\:};if ($] >= 5.014){$qr_prefix=qr{\(\?\^(?:[uadl])?\:}}}sub new {my ($class,%args)=@_;my$tags=$args{tags}|| [];my$loadcode=$args{loadcode};$loadcode ||= 0;my$classes=$args{classes};my$self=bless {tags=>$tags,loadcode=>$loadcode,classes=>$classes,},$class}sub register {my ($self,%args)=@_;my$schema=$args{schema};my$tags;my$loadcode=0;my$classes;if (blessed($self)){$tags=$self->{tags};@$tags=('!perl')unless @$tags;$loadcode=$self->{loadcode};$classes=$self->{classes}}else {my$options=$args{options};my$tagtype='!perl';for my$option (@$options){if ($option =~ m/^tags?=(.+)$/){$tagtype=$1}elsif ($option eq '+loadcode'){$loadcode=1}}$tags=[split m/\+/,$tagtype]}my$perl_tag;my%tagtypes;my@perl_tags;for my$type (@$tags){if ($type eq '!perl'){$perl_tag ||= $type;push@perl_tags,'!perl'}elsif ($type eq '!!perl'){$perl_tag ||= 'tag:yaml.org,2002:perl';push@perl_tags,'tag:yaml.org,2002:perl'}else {die "Invalid tagtype '$type'"}$tagtypes{$type }=1}my$perl_regex='!perl';if ($tagtypes{'!perl'}and $tagtypes{'!!perl'}){$perl_regex='(?:tag:yaml\\.org,2002:|!)perl'}elsif ($tagtypes{'!perl'}){$perl_regex='!perl'}elsif ($tagtypes{'!!perl'}){$perl_regex='tag:yaml\\.org,2002:perl'}my$class_regex=qr{.+};my$no_objects=0;if ($classes){if (@$classes){$class_regex='(' .join('|',map "\Q$_\E",@$classes).')'}else {$no_objects=1;$class_regex=''}}if ($loadcode){my$load_code=sub {my ($constructor,$event)=@_;return$self->evaluate_code($event->{value})};my$load_code_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/code:}{};my$sub=$self->evaluate_code($event->{value});return$self->object($sub,$class)};$schema->add_resolver(tag=>"$_/code",match=>[all=>$load_code],implicit=>0,)for@perl_tags;$schema->add_resolver(tag=>qr{^$perl_regex/code:$class_regex$},match=>[all=>$load_code_blessed ],implicit=>0,);$schema->add_resolver(tag=>qr{^$perl_regex/code:.+},match=>[all=>$load_code ],implicit=>0,)if$no_objects}else {my$loadcode_dummy=sub {return sub {}};my$loadcode_blessed_dummy=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/code:}{};return$self->object(sub {},$class)};$schema->add_resolver(tag=>"$_/code",match=>[all=>$loadcode_dummy ],implicit=>0,)for@perl_tags;$schema->add_resolver(tag=>qr{^$perl_regex/code:$class_regex$},match=>[all=>$loadcode_blessed_dummy ],implicit=>0,);$schema->add_resolver(tag=>qr{^$perl_regex/code:.+},match=>[all=>$loadcode_dummy ],implicit=>0,)if$no_objects}my$load_glob=sub {my$value=undef;return \$value};my$load_glob_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/glob:}{};my$value=undef;return$self->object(\$value,$class)};$schema->add_mapping_resolver(tag=>"$_/glob",on_create=>$load_glob,on_data=>sub {my ($constructor,$ref,$list)=@_;$$ref=$self->construct_glob($list)},)for@perl_tags;if ($no_objects){$schema->add_mapping_resolver(tag=>qr{^$perl_regex/glob:.+$},on_create=>$load_glob,on_data=>sub {my ($constructor,$ref,$list)=@_;$$ref=$self->construct_glob($list)},)}else {$schema->add_mapping_resolver(tag=>qr{^$perl_regex/glob:$class_regex$},on_create=>$load_glob_blessed,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_glob($list)},)}my$load_regex=sub {my ($constructor,$event)=@_;return$self->construct_regex($event->{value})};my$load_regex_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/regexp:}{};my$qr=$self->construct_regex($event->{value});return$self->object($qr,$class)};$schema->add_resolver(tag=>"$_/regexp",match=>[all=>$load_regex ],implicit=>0,)for@perl_tags;$schema->add_resolver(tag=>qr{^$perl_regex/regexp:$class_regex$},match=>[all=>$load_regex_blessed ],implicit=>0,);$schema->add_resolver(tag=>qr{^$perl_regex/regexp:$class_regex$},match=>[all=>$load_regex ],implicit=>0,)if$no_objects;my$load_sequence=sub {return []};my$load_sequence_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/array:}{};return$self->object([],$class)};$schema->add_sequence_resolver(tag=>"$_/array",on_create=>$load_sequence,)for@perl_tags;$schema->add_sequence_resolver(tag=>qr{^$perl_regex/array:$class_regex$},on_create=>$load_sequence_blessed,);$schema->add_sequence_resolver(tag=>qr{^$perl_regex/array:.+$},on_create=>$load_sequence,)if$no_objects;my$load_mapping=sub {return {}};my$load_mapping_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/hash:}{};return$self->object({},$class)};$schema->add_mapping_resolver(tag=>"$_/hash",on_create=>$load_mapping,)for@perl_tags;$schema->add_mapping_resolver(tag=>qr{^$perl_regex/hash:$class_regex$},on_create=>$load_mapping_blessed,);$schema->add_mapping_resolver(tag=>qr{^$perl_regex/hash:.+$},on_create=>$load_mapping,)if$no_objects;my$load_ref=sub {my$value=undef;return \$value};my$load_ref_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/ref:}{};my$value=undef;return$self->object(\$value,$class)};$schema->add_mapping_resolver(tag=>"$_/ref",on_create=>$load_ref,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_ref($list)},)for@perl_tags;$schema->add_mapping_resolver(tag=>qr{^$perl_regex/ref:$class_regex$},on_create=>$load_ref_blessed,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_ref($list)},);$schema->add_mapping_resolver(tag=>qr{^$perl_regex/ref:.+$},on_create=>$load_ref,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_ref($list)},)if$no_objects;my$load_scalar_ref=sub {my$value=undef;return \$value};my$load_scalar_ref_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/scalar:}{};my$value=undef;return$self->object(\$value,$class)};$schema->add_mapping_resolver(tag=>"$_/scalar",on_create=>$load_scalar_ref,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_scalar($list)},)for@perl_tags;$schema->add_mapping_resolver(tag=>qr{^$perl_regex/scalar:$class_regex$},on_create=>$load_scalar_ref_blessed,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_scalar($list)},);$schema->add_mapping_resolver(tag=>qr{^$perl_regex/scalar:.+$},on_create=>$load_scalar_ref,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_scalar($list)},)if$no_objects;$schema->add_representer(scalarref=>1,code=>sub {my ($rep,$node)=@_;$node->{tag}=$perl_tag ."/scalar";$node->{data}=$self->represent_scalar($node->{value})},);$schema->add_representer(refref=>1,code=>sub {my ($rep,$node)=@_;$node->{tag}=$perl_tag ."/ref";$node->{data}=$self->represent_ref($node->{value})},);$schema->add_representer(coderef=>1,code=>sub {my ($rep,$node)=@_;$node->{tag}=$perl_tag ."/code";$node->{data}=$self->represent_code($node->{value})},);$schema->add_representer(glob=>1,code=>sub {my ($rep,$node)=@_;$node->{tag}=$perl_tag ."/glob";$node->{data}=$self->represent_glob($node->{value})},);$schema->add_representer(class_matches=>1,code=>sub {my ($rep,$node)=@_;my$blessed=blessed$node->{value};my$tag_blessed=":$blessed";if ($blessed !~ m/^$class_regex$/){$tag_blessed=''}$node->{tag}=sprintf "$perl_tag/%s%s",lc($node->{reftype}),$tag_blessed;if ($node->{reftype}eq 'HASH'){$node->{data}=$node->{value}}elsif ($node->{reftype}eq 'ARRAY'){$node->{data}=$node->{value}}elsif ($node->{reftype}eq 'REGEXP'){if ($blessed eq 'Regexp'){$node->{tag}=$perl_tag ."/regexp"}$node->{data}=$self->represent_regex($node->{value})}elsif ($node->{reftype}eq 'SCALAR'){if ($blessed eq 'Regexp'){$node->{tag}=$perl_tag .'/regexp';$node->{data}=$self->represent_regex($node->{value})}elsif ($] <= 5.010001 and not defined ${$node->{value}}and $node->{value}=~ m/^\(\?/){$node->{tag}=$perl_tag .'/regexp' .$tag_blessed;$node->{data}=$self->represent_regex($node->{value})}else {$node->{data}=$self->represent_scalar($node->{value})}}elsif ($node->{reftype}eq 'REF'){$node->{data}=$self->represent_ref($node->{value})}elsif ($node->{reftype}eq 'CODE'){$node->{data}=$self->represent_code($node->{value})}elsif ($node->{reftype}eq 'GLOB'){$node->{data}=$self->represent_glob($node->{value})}else {die "Reftype '$node->{reftype}' not implemented"}return 1},);return}sub evaluate_code {my ($self,$code)=@_;unless ($code =~ m/^ \s* \{ .* \} \s* \z/xs){die "Malformed code"}$code="sub $code";my$sub=eval$code;if ($@){die "Couldn't eval code: $@>>$code<<"}return$sub}sub construct_regex {my ($self,$regex)=@_;if ($regex =~ m/^$qr_prefix(.*)\)\z/s){$regex=$1}my$qr=qr{$regex};return$qr}sub construct_glob {my ($self,$list)=@_;if (@$list % 2){die "Unexpected data in perl/glob construction"}my%globdata=@$list;my$name=delete$globdata{NAME}or die "Missing NAME in perl/glob";my$pkg=delete$globdata{PACKAGE};$pkg='main' unless defined$pkg;my@allowed=qw(SCALAR ARRAY HASH CODE IO);delete@globdata{@allowed };if (my@keys=keys%globdata){die "Unexpected keys in perl/glob: @keys"}no strict 'refs';return *{"${pkg}::$name"}}sub construct_scalar {my ($self,$list)=@_;if (@$list!=2){die "Unexpected data in perl/scalar construction"}my ($key,$value)=@$list;unless ($key eq '='){die "Unexpected data in perl/scalar construction"}return$value}sub construct_ref {&construct_scalar}sub represent_scalar {my ($self,$value)=@_;return {'='=>$$value }}sub represent_ref {&represent_scalar}sub represent_code {my ($self,$code)=@_;require B::Deparse;my$deparse=B::Deparse->new("-p","-sC");return$deparse->coderef2text($code)}my@stats=qw/device inode mode links uid gid rdev size atime mtime ctime blksize blocks/;sub represent_glob {my ($self,$glob)=@_;my%glob;for my$type (qw/PACKAGE NAME SCALAR ARRAY HASH CODE IO/){my$value=*{$glob}{$type};if ($type eq 'SCALAR'){$value=$$value}elsif ($type eq 'IO'){if (defined$value){undef$value;$value->{stat}={};if ($value->{fileno}=fileno(*{$glob})){@{$value->{stat}}{@stats }=stat(*{$glob});$value->{tell}=tell *{$glob}}}}$glob{$type }=$value if defined$value}return \%glob}sub represent_regex {my ($self,$regex)=@_;$regex="$regex";if ($regex =~ m/^$qr_prefix(.*)\)\z/s){$regex=$1}return$regex}sub object {my ($self,$data,$class)=@_;return bless$data,$class}1;
YAML_PP_SCHEMA_PERL

$fatpacked{"YAML/PP/Schema/Tie/IxHash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_TIE_IXHASH';
  use strict;use warnings;package YAML::PP::Schema::Tie::IxHash;our$VERSION='0.030';use base 'YAML::PP::Schema';use Scalar::Util qw/blessed reftype/;my$ixhash=eval {require Tie::IxHash};sub register {my ($self,%args)=@_;my$schema=$args{schema};unless ($ixhash){die "You need to install Tie::IxHash in order to use this module"}$schema->add_representer(tied_equals=>'Tie::IxHash',code=>sub {my ($rep,$node)=@_;$node->{items}=[%{$node->{data}}];return 1},);return}1;
YAML_PP_SCHEMA_TIE_IXHASH

$fatpacked{"YAML/PP/Schema/YAML1_1.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_YAML1_1';
  use strict;use warnings;package YAML::PP::Schema::YAML1_1;our$VERSION='0.030';use YAML::PP::Schema::JSON qw/represent_int represent_float represent_literal represent_bool represent_undef/;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE/;my$RE_INT_1_1=qr{^([+-]?(?:0|[1-9][0-9_]*))$};my$RE_FLOAT_1_1=qr{^([+-]?(?:[0-9][0-9_]*)?\.[0-9_]*(?:[eE][+-][0-9]+)?)$};my$RE_SEXAGESIMAL=qr{^([+-]?[0-9][0-9_]*(:[0-5]?[0-9])+\.[0-9_]*)$};my$RE_SEXAGESIMAL_INT=qr{^([-+]?[1-9][0-9_]*(:[0-5]?[0-9])+)$};my$RE_INT_OCTAL_1_1=qr{^([+-]?)0([0-7_]+)$};my$RE_INT_HEX_1_1=qr{^([+-]?)(0x[0-9a-fA-F_]+)$};my$RE_INT_BIN_1_1=qr{^([-+]?)(0b[0-1_]+)$};sub _from_oct {my ($constructor,$event,$matches)=@_;my ($sign,$oct)=@$matches;$oct =~ tr/_//d;my$result=oct$oct;$result=-$result if$sign eq '-';return$result}sub _from_hex {my ($constructor,$event,$matches)=@_;my ($sign,$hex)=@$matches;my$result=hex$hex;$result=-$result if$sign eq '-';return$result}sub _sexa_to_float {my ($constructor,$event,$matches)=@_;my ($float)=@$matches;my$result=0;my$i=0;my$sign=1;$float =~ s/^-// and $sign=-1;for my$part (reverse split m/:/,$float){$result += $part * (60 ** $i);$i++}$result=unpack F=>pack F=>$result;return$result * $sign}sub _to_float {my ($constructor,$event,$matches)=@_;my ($float)=@$matches;$float =~ tr/_//d;$float=unpack F=>pack F=>$float;return$float}sub _to_int {my ($constructor,$event,$matches)=@_;my ($int)=@$matches;$int =~ tr/_//d;0 + $int}sub register {my ($self,%args)=@_;my$schema=$args{schema};$schema->add_resolver(tag=>'tag:yaml.org,2002:null',match=>[equals=>$_=>undef ],)for (qw/null NULL Null ~/,'');$schema->add_resolver(tag=>'tag:yaml.org,2002:bool',match=>[equals=>$_=>$schema->true ],)for (qw/true TRUE True y Y yes Yes YES on On ON/);$schema->add_resolver(tag=>'tag:yaml.org,2002:bool',match=>[equals=>$_=>$schema->false ],)for (qw/false FALSE False n N no No NO off Off OFF/);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_OCTAL_1_1=>\&_from_oct ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_1_1=>\&_to_int ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_HEX_1_1=>\&_from_hex ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[regex=>$RE_FLOAT_1_1=>\&_to_float ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_BIN_1_1=>\&_from_oct ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_SEXAGESIMAL_INT=>\&_sexa_to_float ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[regex=>$RE_SEXAGESIMAL=>\&_sexa_to_float ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[equals=>$_=>0 + "inf" ],)for (qw/.inf .Inf .INF +.inf +.Inf +.INF/);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[equals=>$_=>0 - "inf" ],)for (qw/-.inf -.Inf -.INF/);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[equals=>$_=>0 + "nan" ],)for (qw/.nan .NaN .NAN/);$schema->add_resolver(tag=>'tag:yaml.org,2002:str',match=>[all=>sub {$_[1]->{value}}],implicit=>0,);my$int_flags=B::SVp_IOK;my$float_flags=B::SVp_NOK;$schema->add_representer(flags=>$int_flags,code=>\&represent_int,);$schema->add_representer(flags=>$float_flags,code=>\&represent_float,);$schema->add_representer(undefined=>\&represent_undef,);$schema->add_representer(equals=>$_,code=>\&represent_literal,)for ("",qw/true TRUE True y Y yes Yes YES on On ON false FALSE False n N n no No NO off Off OFF null NULL Null ~ .inf .Inf .INF -.inf -.Inf -.INF +.inf +.Inf +.INF .nan .NaN .NAN/);$schema->add_representer(regex=>qr{$RE_INT_1_1|$RE_FLOAT_1_1|$RE_INT_OCTAL_1_1|$RE_INT_HEX_1_1|$RE_INT_BIN_1_1|$RE_SEXAGESIMAL_INT|$RE_SEXAGESIMAL},code=>\&represent_literal,);if ($schema->bool_class){$schema->add_representer(class_equals=>$schema->bool_class,code=>\&represent_bool,)}return}1;
YAML_PP_SCHEMA_YAML1_1

$fatpacked{"YAML/PP/Type/MergeKey.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_TYPE_MERGEKEY';
  use strict;use warnings;package YAML::PP::Type::MergeKey;our$VERSION='0.030';sub new {my ($class)=@_;return bless {},$class}1;
YAML_PP_TYPE_MERGEKEY

$fatpacked{"YAML/PP/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_WRITER';
  use strict;use warnings;package YAML::PP::Writer;our$VERSION='0.030';sub output {return $_[0]->{output}}sub set_output {$_[0]->{output}=$_[1]}sub new {my ($class,%args)=@_;my$output=delete$args{output};$output='' unless defined$output;return bless {output=>$output,},$class}sub write {my ($self,$line)=@_;$self->{output}.= $line}sub init {$_[0]->set_output('')}sub finish {my ($self)=@_;$_[0]->set_output(undef)}1;
YAML_PP_WRITER

$fatpacked{"YAML/PP/Writer/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_WRITER_FILE';
  use strict;use warnings;package YAML::PP::Writer::File;our$VERSION='0.030';use Scalar::Util qw/openhandle/;use base qw/YAML::PP::Writer/;use Carp qw/croak/;sub _open_handle {my ($self)=@_;if (openhandle($self->{output})){$self->{filehandle}=$self->{output};return$self->{output}}open my$fh,'>:encoding(UTF-8)',$self->{output}or croak "Could not open '$self->{output}' for writing: $!";$self->{filehandle}=$fh;return$fh}sub write {my ($self,$line)=@_;my$fh=$self->{filehandle};print$fh $line}sub init {my ($self)=@_;my$fh=$self->_open_handle}sub finish {my ($self)=@_;if (openhandle($self->{output})){return}close$self->{filehandle}}1;
YAML_PP_WRITER_FILE

$fatpacked{"newgetopt.pl"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NEWGETOPT.PL';
  {package newgetopt;$REQUIRE_ORDER=0;$PERMUTE=1;$RETURN_IN_ORDER=2;if (defined$ENV{"POSIXLY_CORRECT"}){$autoabbrev=0;$getopt_compat=0;$option_start="(--|-)";$order=$REQUIRE_ORDER;$bundling=0;$passthrough=0}else {$autoabbrev=1;$getopt_compat=1;$option_start="(--|-|\\+)";$order=$PERMUTE;$bundling=0;$passthrough=0}$debug=0;$ignorecase=1;$argv_end="--"}use Getopt::Long;sub NGetOpt {$Getopt::Long::debug=$newgetopt::debug if defined$newgetopt::debug;$Getopt::Long::autoabbrev=$newgetopt::autoabbrev if defined$newgetopt::autoabbrev;$Getopt::Long::getopt_compat=$newgetopt::getopt_compat if defined$newgetopt::getopt_compat;$Getopt::Long::option_start=$newgetopt::option_start if defined$newgetopt::option_start;$Getopt::Long::order=$newgetopt::order if defined$newgetopt::order;$Getopt::Long::bundling=$newgetopt::bundling if defined$newgetopt::bundling;$Getopt::Long::ignorecase=$newgetopt::ignorecase if defined$newgetopt::ignorecase;$Getopt::Long::ignorecase=$newgetopt::ignorecase if defined$newgetopt::ignorecase;$Getopt::Long::passthrough=$newgetopt::passthrough if defined$newgetopt::passthrough;&GetOptions}1;
NEWGETOPT.PL

$fatpacked{"parent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARENT';
  package parent;use strict;our$VERSION='0.238';sub import {my$class=shift;my$inheritor=caller(0);if (@_ and $_[0]eq '-norequire'){shift @_}else {for (my@filename=@_){s{::|'}{/}g;require "$_.pm"}}{no strict 'refs';push @{"$inheritor\::ISA"},@_}};1;
PARENT

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use 5.8.1;
use strict;
use warnings;

use Digest::MD5 ();
use File::Basename qw(basename);
use File::Copy ();
use File::Find ();
use File::Path ();
use File::Spec;
use File::Temp ();
use File::pushd qw(pushd);
use Getopt::Long ();
use GitHub::Release;
use HTTP::Tinyish;
use IPC::Run3 ();
use POSIX ();
use YAML::PP;

use constant DEBUG => $ENV{DEBUG} ? 1 : 0;

our $VERSION = '0.0.1';

sub catpath { File::Spec->catfile(@_) }
my $TAR = qr/\.(?:tgz|tar\.(?:gz|bz2|xz))$/;
my $ZIP = qr/\.zip$/;
my $ARCHIVE = qr/(?:$TAR|$ZIP)/;

sub new {
    my ($class, $base_dir, $target_dir) = @_;
    my $cache_dir = catpath $base_dir, "cache";
    my $work_dir = catpath $base_dir, "work";
    File::Path::mkpath $_ for $base_dir, $cache_dir, $work_dir, $target_dir;

    my $os = $^O =~ /linux/i ? "linux" : $^O =~ /darwin/i ? "darwin" : die;
    my $_arch = (POSIX::uname)[4];
    my $arch = $_arch eq "x86_64" ? "amd64" : $_arch eq "arm64" ? "arm64" : die;
    bless {
        os => $os,
        arch => $arch,
        work_dir => $work_dir,
        cache_dir => $cache_dir,
        target_dir => $target_dir,
        http => HTTP::Tinyish->new(verify_SSL => 1),
        github_release => GitHub::Release->new,
    }, $class;
}

sub download {
    my ($self, $url) = @_;
    my $md5 = substr Digest::MD5::md5_hex($url), 0, 8;
    my $local_file = catpath $self->{cache_dir}, $md5 . "-" . basename($url);
    my $res = $self->{http}->mirror($url => $local_file);
    die "$res->{status}, $url\n" if !$res->{success};
    $local_file;
}

sub unpack {
    my ($self, $archive) = @_;
    my $tempdir = File::Temp::tempdir
        TEMPLATE => "unpack-XXXXX",
        CLEANUP => 0,
        DIR => $self->{work_dir},
    ;
    my $guard = pushd $tempdir;
    if ($archive =~ $TAR) {
        !system "tar", "xf", $archive or die;
    } elsif ($archive =~ $ZIP) {
        !system "unzip", "-q", $archive or die;
    } else {
        die;
    }
    $tempdir;
}

sub cleanup {
    my $self = shift;
    opendir my ($dh), $self->{work_dir} or die;
    my $one_week_ago = time - 7*24*60*60;
    my @obsolete =
        grep { (stat $_)[9] < $one_week_ago }
        map { catpath $self->{work_dir}, $_ }
        grep { /^unpack-/ }
        readdir $dh
    ;
    closedir $dh;
    for my $dir (@obsolete) {
        warn "Remove $dir\n";
        File::Path::rmtree $dir;
    }
}

sub probe_release {
    my ($self, @release) = @_;
    my ($want_os, $want_archs);
    if ($self->{os} eq "linux") {
        $want_os = qr/linux/i;
    } else {
        $want_os = qr/(?:darwin|macos|osx)/i;
    }
    if ($self->{arch} eq "amd64") {
        $want_archs = [qr/(?:amd64|x86_64)/i, qr/64/, qr/all/i];
    } else {
        $want_archs = [qr/(?:arm64|AArch64)/i, qr/(?:amd64|x86_64)/i, qr/64/, qr/all/i];
    }

    my @candidate;
    for my $i (0 .. $#{$want_archs}) {
        my $want_arch = $want_archs->[$i];
        for my $release (@release) {
            DEBUG and $i == 0 and warn $release;
            (my $file = $release) =~ s{.*/releases/download/}{};
            if ($file =~ $want_os && $file =~ $want_arch) {
                push @candidate, $release;
            }
        }
        last if @candidate;
    }
    if (!@candidate) {
        die "cannot probe release @release";
    }
    my $sort_by = sub {
        my ($b, $a) = @_;
        if ($b =~ $ARCHIVE && $a =~ $ARCHIVE) {
            return 0;
        } elsif ($b =~ $ARCHIVE) {
            return 1;
        } elsif ($a =~ $ARCHIVE) {
            return -1;
        } else {
            return 0;
        }
    };
    (sort { $sort_by->($b, $a) } @candidate)[0];
}

sub probe_local_version {
    my ($self, $name) = @_;
    for my $option (qw(--version version -v -V --help help -h)) {
        my $out;
        my $bin = catpath $self->{target_dir}, $name;
        IPC::Run3::run3 [$bin, $option], \undef, \$out, \$out, { return_if_system_error => 1 };
        if ($? == -1) {
            DEBUG and warn "$bin $option: $out";
            return;
        }
        if ($? == 0) {
            if ($out =~ /(\d+\.\d+\.\d+)/) {
                return $1;
            } elsif ($out =~ /(\d+\.\d+)/) {
                return $1;
            }
        }
        DEBUG and warn "$bin $option: $out\n";
    }
    die "cannot probe version";
}

sub probe_binary_in_dir {
    my ($self, $name, $dir) = @_;
    my $guard = pushd $dir;
    my @candidate;
    File::Find::find({no_chdir => 1, wanted => sub {
        my $file = $_;
        DEBUG and warn $file;
        return if !-f $file;
        if (basename($file) eq $name) {
            push @candidate, { file => $file, size => 1_000_000_000 };
        } elsif (-x $file) {
            my $size = (stat $file)[7];
            push @candidate, { file => $file, size => $size };
        }
    }}, ".");
    @candidate = sort { $b->{size} <=> $a->{size} } @candidate;
    if (@candidate) {
        return catpath $dir, $candidate[0]{file};
    }
    die "cannot find binary";
}

sub install {
    my ($self, $argv) = @_;
    my $name = $argv->{name};
    my $github_url = $argv->{github_url};

    if (my $local_version = $self->probe_local_version($name)) {
        my $latest_tag = $self->{github_release}->get_latest_tag($github_url);
        if ($latest_tag =~ /$local_version/) {
            warn "[$name] You have $local_version, latest_tag $latest_tag, OK\n";
            return 1;
        }
        warn "[$name] You have $local_version, latest_tag $latest_tag, GO!\n";
    } else {
        warn "[$name] You don't have one, GO!\n";
    }

    my @release = $self->{github_release}->get_latest_assets($github_url);
    my $release = $self->probe_release(@release);
    warn "[$name] Downloading $release\n";
    my $local_file = $self->download($release);
    my $binary = $local_file;
    if ($local_file =~ $ARCHIVE) {
        my $dir = $self->unpack($local_file);
        $binary = $self->probe_binary_in_dir($name, $dir);
    }
    my $target = catpath $self->{target_dir}, $name;
    warn "[$name] Install $binary as $target\n";
    {
        my $tmp = "$target.tmp";
        File::Copy::copy $binary, $tmp or die "copy $binary, $tmp: $!";
        chmod 0755, $tmp or die;
        rename $tmp, $target or die "rename $tmp, $target: $!";
    }
    1;
}

sub run {
    my ($self, $file) = @_;
    my ($yaml) = YAML::PP->new->load_file($file);
    for my $binary (@{ $yaml->{binaries} }) {
        $self->install($binary);
    }
    $self->cleanup;
}

Getopt::Long::Parser->new(
    config => [qw(no_auto_abbrev no_ignore_case bundling)],
)->getoptionsfromarray(\@ARGV,
    "h|help" => sub { die "Usage: binary-install spec.yaml\n" },
    "v|version" => sub { print "binary-install $VERSION\n"; exit },
) or exit;

my $file = shift or die "missing spec.yaml\n";
my $home = (<~>)[0];
my $base_dir = catpath $home, ".binary-install";
my $target_dir = catpath $home, "bin";
my $app = __PACKAGE__->new($base_dir, $target_dir);
$app->run($file);
